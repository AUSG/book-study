# 1. HTTP 개관

## 웹의 구성 요소

- 프락시 : 클라이언트와 서버 사이에서 요청을 전달
- 캐시 : 특별한 HTTP 프락시 서버
- 게이트웨이 : 서버들의 중개자
- 터널 : raw data를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
- 에이전트 : 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램

# 2. URL과 리소스

URL 구조는 `〈스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트〉`

## 단축 URL

- url은 상대URL과 절대URL 두 개가 있음
  - 상대URL은 ./tools.html 같은 애
  - 절대URL은 https://www.naver.com 같은 애
- 상대URL이 들어오면 기저URL을 찾아서 절대URL로 바꿔줘야함
  - 기저URL찾는 법
    - 리소스에 명시된 경우(HTML의 <base>태그)
    - 리소스를 포함하고 있는 경우(html에서 ./tools.html같은 경우)는 해당 리소스를 기저URL로 사용
    - 기저URL이 없는 경우 보통 절대URL이다
      ![스크린샷 2024-10-12 오전 2.52.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/af55a34b-9237-4a8d-9996-7f267aeaa8d5/0bf6c4d0-e7ff-47fc-b3dd-420da3f0312f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.52.02.png)

# 3. HTTP 메시지

## METHOD

- GET : 리소스를 달라고 요청
- HEAD : GET처럼 행동하지만 헤더만 반환
- PUT : 문서를 작성, 새 문서를 만들거나 이미 있으면 교체
- POST : 서버에 데이터를 전송
- TRACE : 클라이언트에 요청이 서버에 어떻게 도달했는지 알려줌
- OPTIONS : 웹 서버에게 여러가지 종류의 지원 범위를 물어봄
- DELETE : 삭제

# 4. 커넥션 관리

## TCP에서 성능 관련 중요 요소

### 1. TCP 커넥션 핸드셰이크 지연

커넥션에 시간이 듦

### 2. 인터넷 혼잡을 제어하기 위한 TCP slow-start

갑작스런 인터넷의 부하와 혼잡을 막기 위해 최대 속도를 크게 가졌다가 점점 줄여가면서 조율하는 것.

- TCP가 한 번에 전송할 수 있는 패킷 수 제한함으로써 속도를 제한. 간단히 말하면 하나의 패킷이 성공적으로 전달되면 추가로 2개의 패킷을 더 전송할 수 있도록 함.
- 때문에 처음에는 튜닝된 커넥션보다 느림

### 3. 데이터를 한데 모아 한 번에 전송하기 위한 nagle 알고리즘

데이터가 작으면 헤더가 더 커서 낭비임.

⇒ 많은 양의 TCP 데이터를 한 개의 덩어리로 합쳐서 보냄(RFC896)

문제1 : 바이트를 못 채우면 전송이 안되어버림

문제2 : 확인응답 지연과 같이 사용되면 형편없이 동작. 네이글 알고리즘은 확인응답이 도착할 때까지 데이터 전송을 멈추고 있는 반면 확인응답 지연 알고리즘은 확인응답을 100~200밀리초 지연

### 4. TCP의 piggyback acknowledgment를 위한 확인 응답 지연 알고리즘

- 확인응답 : 수신자가 세그먼트를 온전히 받으면 확인응답을 송신자에게 반환
- piggyback : 확인응답은 크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승(piggyback)시킴

확인응답이 같은 방향으로 가는 데이터 패킷에 편승되는 경우를 늘리기 위해 많은 TCP 스택은 확인응답지연 알고리즘을 구현

### 5. TIME_WAIT 누적과 포트 고갈

테스트시에는 자주 발생하지만 실제 상황에서는 문제를 발생시키지 않음. 오해하지 않도록 조심

- TCP 커넥션 종단에서 커넥션을 끊으면 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 control block에 기록.
  이는 같은 주소와 포트를 사용하는 새로운 TCP 커넥션이 당분간 생기지 않도록 하기 위함.
  ⇒ 이렇게 함으로써 패킷이 중복해서 도달하는 것을 방지

<aside>
💡

패킷이 네트워크에서 막 돌아다니다가 다시 소켓으로 들어와서 중복 패킷이 들어오는 걸 막아주는 것. 이라고 내가 이해함

</aside>

## HTTP의 커넥션 관리

### connection 헤더

![스크린샷 2024-10-12 오전 4.08.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/af55a34b-9237-4a8d-9996-7f267aeaa8d5/636567bc-0599-4063-b52d-f8f65858ed1d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.08.57.png)

위 그림에서 meter 가 `hop-by-hop`임.

### 병렬 커넥션

항상 더 빠르진 않다. 대역폭이 좁으면 장점 없어짐

- 각 트랜잭션마다 커넥션을 새로 맺어야됨. 시간과 대역폭이 소요
- slow-start
- 실제 병렬 연결 커넥션 수는 제한이 있음

### 지속 커넥션

HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있음.

- 커넥션 튜닝 가능 (slow start 해결)

### HTTP/1.0+의 Keep-Alive 커넥션

Keep-Alive는 HTTP/1.1 명세에서 제외되었으나 아직도 브라우저와 서버간에 Keep-Alive 핸드셰이크가 널리 사용되고 있음.

Connection:Keep-Alive 헤더를 포함함.

- timeout : 커넥션이 얼마나 유지될 것인가
- max : 몇 개의 트랜잭션을 처리할 때까지 유지될 것인가

```json
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

근데 이런 헤더를 받은 서버에서 꼭 Keep-Alive를 따를 필욘 없다고함. (아마 표준이 아니라 그런 듯?)

정석대로면 keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와는 연결되면 안됨. 허나 이는 dump proxy로 인해 현실적으로 쉽지 않음

기술적으론 HTTP/1.0 을 따르는 기기로부터 받는 모든 Connection 헤더는 무시해야함. 오래된 프락시 서버로부터 실수로 전달될 수 있기 때문.

자세한건 RFC2068 참고

### HTTP/1.1의 지속 커넥션

1.0에선 디폴트가 keep-alive의 비활성이었는데 1.1에서는 디폴트가 지속 커넥션 활성임.

오히려 끊으려면 connection : close를 명시해야 함

### 파이프라인 커넥션

큐를 사용해 요청을 와다다보냄

### 커넥션 끊기

커넥션 끊기에 대한 명확한 기준이 없다

1. 마음대로 끊기
2. Content-Length와 Truncation
3. 커넥션 끊기의 허용, 재시도, 멱등성
4. 우아한 커넥션 끊기
