## 15장 엔터티와 인코딩
> 엔터티 및 그와 연관된 엔터티 헤더들과 그들이 웹상의 화물을 수송하기 위해 하는일
### 메시지는 컨테이너, 엔티티는 화물
- HTTP 메시지 = 인터넷 운송 시스템의 컨테이너
- HTTP 엔터티 = 메시지의 실질적인 ㅣ화물
- 엔터티 본문
  - 가공되지않은 데이터만을 담고 있다. 나머지는 헤더에!
### Content-Length : 엔티티의 길이
- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트로 나타냄
- 필수적으로 있어야함
- 서버 충돌로 인해 메시지가 잘렸는지 감지할때, 지속 커넥션을 공유하는 메시지를 올바르게 분할할때 필요
- 잘림 검출
  - 옛날버전 HTTP는 커넥션 닫힘 = 메세지 끝났음 이렇게 인지함
  - 그러나 Content-Length가 없다면 메시지 전송 중에 서버에 충돌이 발생한건지, 커넥션이 정상적으로 닫혔는지 구분하지 못한다.
  - 즉 메시지 잘림을 검출하기 위해 Content-Length가 필요
  - 메시지 잘림은 프락시 서버에 특히 취약
    - 명시적으로 Content-Length 헤더를 가지고 있지 않은 HTTP 본문은 캐시하지 않음
- 잘못된 Content-Length
- 콘텐츠 인코딩
  - 인코딩 되지 않은 원본의 길이가 아닌, 인코딩된 본문의 길이를 바이트 단위로 정의
  - 어떤 HTTP 애플리케이션은 인코딩 전의 크기를 보내기도 하는데 이는 지속커넥션일때 심각한 오류를 유발함
- 엔터티 본문 길이 판별을 위한 규칙
  - 본문을 갖는 것이 허용되지 않는 특정 타업의 HTTP 메시지에서는， 본문 계산을 위한 Content-Length 헤더가 무시된다.
  - 메시지가 Transfer-Encoding 헤더를 포함하고 있다면， 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0 바이트 청크’라 불리는 특별한 패턴으로 끝나야 한다.
  -  메시지가 Content-Length 헤더를 갖는다면， Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
  - 메시지가 multipart/byteranges’ 미디어 타입을 사용하고 엔터티 길이가 Content-Length 헤더로 별도로 정의되지 않았다면， 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다.
  - 위의 어떤규칙에도해당되지 않는다면， 엔터티는커넥션이 닫힐 때 끝난다.
  - HTTP/1.0 애플리케이션과의 호환을 위해，엔터티 본문을 갖고있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다
### 미디어 타입과 차셋
Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술
- 텍스트 매체를 위한 문자 인코딩
  - 엔터티의 비트 집합을 텍스트 파일의 글자로 변환하기 위해 charset 매개변수 사용
- 멀티파트 미디어 타입
  - 서로 붙어있는 여러 개의 메시지를 포함하며 하나의 복합 메시지로 보내짐
  - 각각 자신에 대해 서술하는 헤더 포함
- 멀티파트 폼 제출
- 멀티파트 범위 응답
  - 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있다.
### 콘텐츠 인코딩
HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고한다.
- 콘텐츠 인코딩 과정
- 콘텐츠 인코딩 유형
- Accept-Encoding 헤더
  - 지원하는 인코딩 목록
  - Q값의 범위는 가장 원치 않음을 의미하는 0.0에서 가장 선호함을 나타내는 1.0
  - *는 그 외 모두 를 의미
### 전송 인코딩과 청크 인코딩
- 안전한 전송
  - HTTP에 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유
    - 알 수 없는 크기, 보안
- Transfer-Encoding 헤어
  - 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두 개뿐
    - Transfer-Encoding, TE
- 청크 인코딩
  - 메시지를 청크 여럿으로 쪼갠다. 서버가 각 청크를 순차적으로 보낸다.
    - 이를 이용하면 메세지를 전송하기 전에 전체 크기를 알 필요가 없어짐.
    - 본문이 동적 생성됨에 따라 서버는 그 중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보냄 -> 본문 전체를 보낼때까지 반복
  - 청크와 지속 커넥션
    - if 클라와 서버 사이의 커넥션이 지속적이지 않으면, 클라는 본문의 크기를 알 필요가 없다. 서버가 커넥션을 닫을때까지가 본문으로 인식
    - 청크 인코딩에서는 크기가 0인 청크로 본문이 끝났음을 알리고, 다음 응답을 위해 커넥션을 열린채로 유지
      - 클라는 서버가 청크 인코딩을 받아들여줄지 모르기 때문에 청크 요청이 411 Length Required 응답으로 거절당하는 것에 대비해야함
  - 청크 인코딩된 메시지 트레일러
    - 두 조건 중 하나 이상을 만족하면 청크 메시지에 트레일러 추가 가능
      - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
      - 트레일러가 웅답을 만든 서버에 의해 추가되었으며， 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
    - 트레일러에는 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있음.
- 콘텐츠와 전송 인코딩의 조합
  - 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있음
- 전송 인코딩 규칙
  - 수신자가 메시지의 전송 길이를 알아낼 수 있게 하기 위함
  - 전송 인코딩의 집합은 반드시 ‘chunked’를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.
  - 청크 전송 인코딩이 사용되었다면， 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야한다.
  - 청크 전송 인코딩은 반드시 메시지 본문에 한번 이상 적용되어야한다.
### 시간에 따라 바뀌는 인스턴스
- 웹 객체는 정적이지 않다.
- 인스턴스 조작 = HTTP 프로토콜이 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의
  - 대표적인 두가지가 범위 요청과 델타 인코딩
  - 둘 모두 클라이언트가 자신이 가지고 있는 리소스의 사본이 서버가 가지고 있는 것과 정확히 같은지 판단하고, 상황에 따라서 새 인스턴스를 요청할 수 있는 능력을 가질것을 요구
### 검사기와 신선도
> 조건부 요청이라고 불리는 이 특별한 요청은， 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것이다.
- 신선도
- 조건부 요청과 검사기
  - 만약 서버의 문서가 캐시가 갖고 있는 것과 같음에도 불구하고 항상 그 문서를 가져온다면 캐시는 네트 워크의 대역폭을 낭비하고， 캐시와 서버에 불필요한 부하를 주고， 모든 것을 느려지게 만들게 된다.
  - 이를 고치기 위해， HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공한다.
  - 조건부 요청은 if- 로 시작하는 조건부 헤더에 의해 구현
    - if-Modified-Since, if-Unmodified-Since, if-Match, if-None-Match
  - 검사기 2 종류 : 강한 검사기, 약한 검사기('W/'를 붙여서 표시)
### 범위 요청
- 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해줌
- Range 헤더
### 델타 인코딩
> 델타 인코딩은 객체 전체가 아닌 변경된 부분에대해서만 통신하여 전송량을 최적화하는，HTTP 프로토콜의 확장이다.