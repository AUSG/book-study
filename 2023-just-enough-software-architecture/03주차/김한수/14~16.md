# 14~16

- [14~16](#1416)
- [14. 아키텍처 스타일](#14-아키텍처-스타일)
  - [아키텍처의 장점](#아키텍처의-장점)
  - [개념 아키텍처 스타일 vs 구현 아키텍처 스타일](#개념-아키텍처-스타일-vs-구현-아키텍처-스타일)
  - [제약 조건 및 아키텍처 집중 설계](#제약-조건-및-아키텍처-집중-설계)
  - [아키텍처 스타일 카탈로그](#아키텍처-스타일-카탈로그)
    - [계층 아키텍처 스타일(layered)](#계층-아키텍처-스타일layered)
    - [큰 진흙 뭉치 아키텍처 스타일(big ball of mud)](#큰-진흙-뭉치-아키텍처-스타일big-ball-of-mud)
    - [파이프와 필터 아키텍처 스타일(pipe-and-filter)](#파이프와-필터-아키텍처-스타일pipe-and-filter)
    - [일괄-순차 아키텍처 스타일(batch-sequential)](#일괄-순차-아키텍처-스타일batch-sequential)
    - [모델 중심 아키텍처 스타일(model-centered)](#모델-중심-아키텍처-스타일model-centered)
    - [발행-구독 아키텍처 스타일(publish-subscribe)](#발행-구독-아키텍처-스타일publish-subscribe)
    - [클라이언트-서버 아키텍처 스타일 및 다중 계층](#클라이언트-서버-아키텍처-스타일-및-다중-계층)
    - [P2P 아키텍처 스타일 (peer-to-peer)](#p2p-아키텍처-스타일-peer-to-peer)
    - [맵리듀스 아키텍처 스타일(map-reduce)](#맵리듀스-아키텍처-스타일map-reduce)
  - [마치며](#마치며)
- [15. 아키텍처 모델 사용하기](#15-아키텍처-모델-사용하기)
  - [바람직한 모델 특성](#바람직한-모델-특성)
    - [충분한 정밀도](#충분한-정밀도)
    - [정확성](#정확성)
    - [예측](#예측)
    - [이해력 증진](#이해력-증진)
    - [일괄된 세부 수준](#일괄된-세부-수준)
    - [단일 주제 뷰](#단일-주제-뷰)
    - [낮은 비용](#낮은-비용)
  - [뷰를 이용한 작업](#뷰를-이용한-작업)
    - [분할 정복](#분할-정복)
    - [각 관심사에 대한 뷰](#각-관심사에-대한-뷰)
    - [주의점](#주의점)
    - [피해야 할 안티패턴](#피해야-할-안티패턴)
  - [뷰 품질 향상](#뷰-품질-향상)
    - [기능 시나리오 작성](#기능-시나리오-작성)
    - [시나리오 구동](#시나리오-구동)
    - [작업 사양 작성](#작업-사양-작성)
  - [다이어그램 품질 개선](#다이어그램-품질-개선)
  - [테스트 및 증명](#테스트-및-증명)
  - [아키텍처 모델 분석](#아키텍처-모델-분석)
  - [아키텍처 불일치](#아키텍처-불일치)
  - [추상화 수준 선택](#추상화-수준-선택)
  - [사용자 인터페이스 계획](#사용자-인터페이스-계획)
  - [규범 모델(prescriptive model)과 설명 모델(descriptive model)](#규범-모델prescriptive-model과-설명-모델descriptive-model)
  - [기존 시스템을 모델링하기](#기존-시스템을-모델링하기)

# 14. 아키텍처 스타일

- 아키텍처 스타일은 사용할 수 있는 요소 타입의 집합을 정의한다.
  - e.g. 모듈, 컴포넌트, 커넥터, 포트

## 아키텍처의 장점

**제약 조건은 가이드 역할을 할 수 있다.**

- 아키텍처 스타일을 이미 지정하고 프로젝트를 시작하면 나중에 변경하기 어렵다.
- 그리고 어떤 스타일이 최선의 선택인지 미리 명확하게 결정하기도 어렵다
- 제약 조건을 적용하면 스타일의 제약 조건을 유지하려고 명확하지 않은 설계를 찾아야 하므로 시스템 유지 관리가 더 어려워진다.
- 그럼에도 제약 조건과 스타일을 사용해야 하는 이유는 무엇인가?
- `부분별로 미리 만들어진 조립식 제약조건 집합이 된다`(prefabricated set of constaints)
  - 이미 만들어진 제약조건들을 조립해서 개발할 수 있고
  - 이런 방식은 설계와 디버깅 작업을 절약하게 도와준다.
  - 필요에 따라 완벽하게 맞출 수 없을 수 있지만 이미 존재하는 코드들이 도움을 줄 수 있다는 장점이 있다.
- `일관성과 이해가능성을 높인다`
  - 아키텍처 스타일의 제약 조건으로 인해 일관성을 띄고 이는 시스템의 깔끔한 진화를 가능하게 하며 유지 관리를 쉽게 한다.
- `약속된 내용들이므로 소통에 있어서도 이점을 가진다`
- `설계 재사용이 가능하다`
  - 모든 엔지니어가 선임 엔지니어의 설계 지식을 재사용할 수 있다.
- `품질이 어느정도 보장된다`
  - 제약 조건이 없는 임의 코드에는 어떤 일이든 일어날 수 있다는 문제가 있다.
  - 유지보수성, 규모확장성, 보안과 같이 코드의 품질이 중요할 경우 제약 조건을 만들어 제어해야 한다.
- `분석하기 쉽다`
  - 제약 조건이 없는 코드는 뭘 원하는지 분석하기 어렵다.
  - 특정 아키텍처 스타일에 대한 이해도가 있다면 처음 접하는 프로젝트의 코드를 보더라도 더 쉽게 분석하고 의사결정할 수 있을 것이다.

## 개념 아키텍처 스타일 vs 구현 아키텍처 스타일

사실 실제 코드는 설계 책들에 나오는 패턴의 이상적인 버전과는 다르다.

- 우리는 아키텍처 스타일이나 패턴에 관해 두 가지 컨셉으로 바라봐야 한다.
  - `개념 아키텍처 스타일(platonic style)`
    - 개념 아키텍처 스타일은 이상적인 스타일은 뜻하고 흔히 책에서 볼 수 있는 스타일과 패턴이며 소스 코드에서는 거의 찾아볼 수 없다.
  - `구현 아키텍처 스타일(embodied style)`
    - 실제 시스템에서 볼 수 있는 아키텍처 스타일.
    - 개념 스타일에서 제안하는 엄격한 제약 조건을 자주 위반하고 이러한 위반에는 흔히 큰 트레이드오프를 포함한다.

## 제약 조건 및 아키텍처 집중 설계

- `개념 아키텍처 스타일`과 아키텍처 집중 설계는 개념적으로 관련이 있다.
  - 아키텍처 집중 설계는 결국 리스크를 줄이고, 기능을 달성하거나, 품질을 보장하려고 아키텍처에 의존함을 의미한다.
  - 목표를 달성하려고 의식적으로 아키텍처에 의존하는 것이다.
- 반대로 아키텍처 무관 설계를 따를 때 스타일 제약 조건을 엄격하게 따르지 않는 `구현 스타일`을 사용할 수 있다.
  - 그럼에도 품질을 어느정도 보장할 수 있고 잘 알려진 스타일들은 여전히 설계의 염감이나 가이드 역할을 한다.
  - 구현 스타일을 사용하는 일은 잘못이 아니지만 스타일의 제약 조건을 위반하고도 여전히 그 이점을 기대하는 것은 어리석은 일이므로 이를 염두해두어라.

## 아키텍처 스타일 카탈로그

### 계층 아키텍처 스타일(layered)

- 가장 일반적인 스타일이다.
- 많은 개발자가 모든 시스템은 이미 계층화되었거나 계층화되어야 한다고 가정한다.
- `요소와 제약 조건(element and constraint)`
  - 계층 스타일의 필수 요소는 계층과 종속성이다.
  - 계층의 순서는 한 방향으로 향하는 방향성 비순환 그래프(directed acyclic graph)를 이루고
  - 보통 각 계층은 바로 아래 계층만 사용할 수 있도록 제한한다.
  - e.g. JVM
- `이점(resulting quality)`
  - 수정가능성, 이식성, 재사용성과 같은 품질을 얻을 수 있다.
- `변형(variant)`
  - `계층 건너뛰기`
    - 변형된 케이스로는 하위 계층을 건너뛸 수 있도록 제약 조건을 회피하는 경우도 있다.
  - `모든 계층이 공유하는 shared layer`
    - 임의의 계층을 공유 계층으로 만들어 모든 계층이 shared layer를 사용할 수 있다
- 계층 스타일은 개념적인 스타일과 구현에서 나오는 스타일이 매우 다양하다.
  - 하위 계층은 callback 매커니즘을 이용해서 역으로 상위 계층과 안전하게 통신할 수도 있다.

### 큰 진흙 뭉치 아키텍처 스타일(big ball of mud)

- `큰 진흙 뭉치(big ball of mud)`는 명백한 아키텍처 없거나 기존의 아키텍처가 침식되어 흔적으로 남은 아키텍처다.
- 계층 스타일이 목표를 가지고 만들어지는 가장 일반적인 아키텍처이지만, 실제로는 큰 진흙 덩어리가 되는 경우가 가장 많다.
  - 일반적으로 정보를 무차별적으로 공유하며 때로는 자료 구조를 시스템의 전역에서 사용하는 모습을 볼 수 있다.
  - 모듈, 런타임, 할당 구성이 엉망이 될 수 있지만, 모듈 뷰타입에서 시작하여 다른 곳으로 퍼질 때가 많고
  - 수정과 유지보수는 편리하며 우아한 리팩터링이 아니라 조잡한 패치와 유사하다.
  - 개념적 무결성이나 일관성을 강화하려고 노력하지 않는다.
  - 기술 부채는 천문학적으로 높다.
- **당연하게도 이런 시스템은 유지보수성과 확장성이 떨어진다.**
- 시스템을 큰 진흙 덩어리로 만드는 힘에는 독특한 안정성이 있다.
  - 시스템이 큰 진흙 덩어리가 되면 이를 이해하고 발전시킬 수 있는 일부 개발자는 선택되어 고용 안정과 명성을 얻는다.
  - 반면 큰 진흙 덩어리를 싫어하는 (그리고 아마도 이를 정리할 수 있는) 사람들은 도망칠 것이다.
  - 결론적으로 이 큰 진흙 덩어리는 정리되지 않는다.

### 파이프와 필터 아키텍처 스타일(pipe-and-filter)

![Untitled](https://github.com/AUSG/2023-book-study/assets/72328687/43be3c26-1463-4cdd-831c-a1031e316f3a)

- 전체 파이프와 필터 네트워크가 지속해서 점진적으로 데이터를 처리하는 아키텍처
- 파이프와 필터 아키텍처에서 데이터는 화학 처리 공장의 파이프를 통해 순차적으로 흘러가는 것과 유사하다.
- `요소와 제약 조건(element and constraint)`
  - 파이프(pipe), 필터(filter), 읽기 포트(read port), 쓰기 포트(write port)로 총 4가지 요소로 구성된다.
  - 필터는 하나 이상의 입력 포트에서 일부 입력을 읽고 일부 처리를 수행하며 출력을 하나 이상의 출력 포트에 쏜다. 그리고 이를 멈출 때까지 반복한다.
  - 필터는 데이터를 수정할 수 있지만 순서대로 한 방향으로만 전송해야 한다.
  - 필터는 업스트림과 다운스트림에 대해 관여할 수 없으므로 독립적이어야 한다.
  - 파이프와 필터 네트워크의 정확성은 동시성에 대해서 결정적이어야 한다. 즉. 구현이 동시성으로 구현되었는지에 관계없이 주어진 입력에 대해서 항상 동일한 출력이 나와야 한다.
  - 그리고 이렇게 구성된 네트워크에서 loop는 드물며 보통 금지된다.
- `이점(resulting quality)`
  - 나중에도 네트워크의 구성이나 재구성이 가능하다.
  - e.g. linux의 cli 파이프라인
  - 단, 대화형 애플리케이션에는 적합하지 않다.
- `변형(variant)`
  - 때로는 루프를 적용할 수도 있고 일부 제약 조건들을 무시하고 각 포트로 부터 데이터를 가져오거나 보낼 수 있다.
- `주의`
  - 이 아키텍처는 중단 방법에 대해 주의를 기울여야 한다.
    - 프로세스를 제거하여 종료할 수도 있지만 이렇게 하면 처리 완료 여부를 알 수 없다.
    - 파이프라인 중간에 흐름에 대한 흔적을 어딘가에 전송해서 확인할 수도 있고
    - 파이프가 아직 열려 있는지 필터가 테스트하도록 하는 방법도 있다.
  - 추상적으로 파이프는 무한히 빠르고 크다. 하지만 실제로는 제한된 버퍼 크기로 구현되고 환경에 따라 성능 차이가 있다

### 일괄-순차 아키텍처 스타일(batch-sequential)

![Untitled](https://github.com/AUSG/2023-book-study/assets/72328687/1ee8d808-43e0-4fbf-8ef0-f49bf1b1143f)

- 일괄-순차 아키텍처는 데이터는 단계에서 단계로 흐르고 점진적으로 처리된다.
- 파이프와 필터 아키텍처와 달리 각 스테이지는 출력을 작성하기 전에 모든 처리를 완료한다.
- 데이터가 스트림처럼 쭉 흐르듯이 처리될 수도 있지만 보통 디스크 파일에 저장될 때가 더 많다.
- `요소와 제약 조건(element and constraint)`
  - 일괄-순차 아키텍처의 처리 컴포넌트는 다양한 이름으로 불리는데, 스테이지(stage)나 스텝(step)이라고 한다.
  - 그리고 이 아키텍처를 통과하는 단일 작업을 일괄 처리(batch process)나 작업(job)이라고 한다.
  - 각 단계는 독릭접이며 가져오는 데이터에 의존하지만 이전 단계에 의존하는 것은 아니다.
  - 단계는 입력을 완전히 처리한 후 종료되며 그 후 다음 단계에서 동일하게 수행된다.
  - 대부분 선형적인 일련의 스테이지 모음이고 방향성 비순환 그래프로 구조화되는 일은 드물지만 그렇게 하면 병렬로 실행할 수도 있다.
- `이점(resulting quality)`
  - 각 스테이지가 독립적이므로 `수정가능성`
  - 한 스테이지를 병렬로 실행할 수 없으므로 동시성에 대한 기회가 적음
  - 주어진 시간에 하나의 스테이지만 실행하기 때문에 개념적으로 더 간단하고 처리량이 더 클 수 있음

### 모델 중심 아키텍처 스타일(model-centered)

![Untitled](https://github.com/AUSG/2023-book-study/assets/72328687/93341321-72f7-4ba0-9b88-c07c257b7586)

- 모델 중심 아키텍처 스타일에서 독립 컴포넌트는 서로 상호작용하지 않고 `중앙 모델`(**데이터 저장소(data store나 저장소(repository)라고도 함**)과 상호작용한다.
- `저장소 스타일(repository style)`, `공유 데이터 스타일(shared data style)`, `데이터 중심 스타일(data-centered style)`이라고도 한다.
- `요소와 제약 조건(element and constraint)`
  - 모든 모델 중심 시스템에는 모델 컴포넌트와 하나 이상의 뷰, 컨트롤러 또는 뷰-컨트롤러 컴포넌트가 있다.
  - 뷰와 컨트롤러는 서로가 아닌 모델에만 의존하고
- `이점(resulting quality)`
  - 뷰 및 컨트롤러 컴포넌트가 모델 컴포넌트에서 독립적이며 최소한의 종속성만 있기 때문에 고도의 `수정가능성`을 제공한다.
  - 뷰와 컨트롤러를 나중에 쉽게 추가할 수 있으므로 `확장성`이 높아지고
  - 상태가 모델 컴포넌트에 집중되어 상태를 관리하기 더 쉬어지며 뷰와 컨트롤러가 자체 스레드나 프로스 또는 다른 하드웨어에서 실행될 수 있으므로 `동시성`이 확장될 수 있다.

### 발행-구독 아키텍처 스타일(publish-subscribe)

![Untitled](https://github.com/AUSG/2023-book-study/assets/72328687/f0e00197-3cbd-498a-b6f2-d67d7588fd1e)

- pub-sub 또는 이벤트 기반 아키텍처라고도 하는 발행-구독 아키텍처는 각 독립 컴포넌트가 이벤트를 발행하고 구독하는 형태다.
- `요소와 제약 조건(element and constraint)`
  - 발행 포트와 구독 포트라는 두 종류의 포트와 하나의 커넥터, 이벤트 버스 커넥터로 구성된다.
  - 이벤트 버스 커텍터는 이벤트 전달을 담당하고 이벤트를 발행하는 컴포넌트는 이벤트가 구독자에게 전달된다는 점을 신뢰하고 구독자는 구독하는 이벤트를 수신한다는 점을 신뢰하는 구조다.
    - 마찬가지로 발행자는 이벤트 소비를 알지 못한다
    - 이 아키텍처에서 중요한 건 커넥터이고 모든 컴포넌트가 커넥터를 바라보게 되므로 커넥터가 상당히 많은 작업을 담당하게 된다.
- `이점(resulting quality)`
  - 발행-구독 아키텍처의 가장 큰 이점은 이벤트의 생상자와 소비자를 분리한다는 점이다.
  - 의존성이 없어지므로 결과적으로 시스템의 유지보수성과 진화가능성이 더 향상된다.
  - 만약 새 컴포넌트가 이미 많은 컴포넌트가 구독하고 있던 이벤트를 사용하고 싶다면 단순히 그 이벤트를 구독하면 될 뿐 사이드이펙트는 없다.
- `변형(variant)`
  - 일부 발행-구독 아키텍처의 변형에서는 이벤트 등록 및 등록 취소를 구독자가 해야 하는 경우도 있다.
    - 또 다른 경우는 configuration file 등을 이용해 다른 사람들이 구독자가 단순히 이벤트를 수신해야 한다고 말하는 선언적 모델을 사용한다.
      - 이는 이벤트 타입, 발행자, 구독자의 동적 생성과 같은 또 다른 변형된 형태다.
    - 스타일 변형이 이러한 런타임 변경을 허용할 때는 동적 아키텍처로 볼 수 있다.
  - 이벤트 버스는 지원하는 속성에 따라 다양하다.
    - 일부는 수신한 모든 메시지가 손실되지 않도록 보장한다는 점에서 내구성이 있고
    - 일반적으로 모든 이벤트는 신뢰할 수 있는 저장소에 기록하여 내구성을 보장하지만, 레이턴시의 측면에서 트레이드오프가 생긴다.
    - 또한 이벤트의 순서 유지 배송(in-order delivery)와 우선순위 배송(prioritized delivery)을 보장할 수 없다.
    - 일부는 이벤트를 함께 일괄 처리해서 대량의 유사한 이벤트를 피하기도 한다.
- **소프트웨어 유지보수성과 진화가능성 관점에서 발행-구독 아키텍처는 이벤트 발행자와 소비자를 분리하지만 이를 시스템 개발자의 지식이나 의도와 혼동하지 말자.**
  - 예를 들면, 발행-구독 시스템을 설계할 때는 ‘신규 직원’이벤트의 발행자와 소비자를 의도적으로 도입한다.
  - 추후에 추적이 어려움을 대비해서 이 지식과 의도가 다이어그램에서 손실되지 않도록 주의하자.

### 클라이언트-서버 아키텍처 스타일 및 다중 계층

![Untitled](https://github.com/AUSG/2023-book-study/assets/72328687/12f3ed49-424c-4817-a1ca-6748458e691c)

- 클라이언트-서버 아키텍처는 현재도 많이 사용하는 전형적 아키텍처다.
- 클라이언트가 서버에 요청을 보내고 응답을 받는 형태. 반대는 불가능하다. 일반적으로 동기식이며 비동기로 동작하는 경우도 있다.
- `요소와 제약 조건(element and constraint)`
  - 서버는 통신을 받기만 하고 클라이언트는 통신을 요청하기만 한다.
  - 서버는 연결될 때까지 클라이언트의 ID를 알지 못한다.
- `변형(variant)`
  - 커넥터가 동기식일 수도 비동기 식일 수도 있고, 클라이언트나 서버 수에 제약이 있을 수 있다.
  - 연결은 무상태(stateless) 또는 상태(stateful)일 수 있으며 시스템 연결 방식은 정적이거나 동적일 수 있다.
  - 다중 계층이 될 수도 있다.
- `이점(resulting quality)`
  - 서비스를 제공하는 서버가 일반적으로 더 많은 영향력을 갖게 되고 조직은 클라이언트가 아무리 많아도 서버에서 구현을 변경하여 요구사항을 수정할 수 있으므로 `유지보수성`이 향상된다.
  - 그리고 중앙 제어가 가능하므로 시스템의 진화가능성도 지원한다.
  - 클라이언트-서버 스타일은 기존 시스템 주변에 퍼사드를 만들고 이를 서버로 취급하여 기존 시스템을 `통합`하는 데 사용할 수도 있다.

### P2P 아키텍처 스타일 (peer-to-peer)

- P2P 아키텍처 스타일은 각 노드가 서로 통신하고 노드 사이의 계층적 관계는 금지된다.
- 각 노드는 서버와 클라이언트 역할을 모두 수행할 수 있지만 필수는 아니다.
- `요소와 제약 조건(element and constraint)`
  - P2P 스타일의 구성은 클라이언트-서버 스타일의 구성과 유사하지만 각 노드가 클라이언트와 서버 역할을 모두 수행할 수 있다는 점에서 차이가 있다.
  - P2P 스타일은 계층이 존재하지 않고 모든 노드가 평등한 관계이다.
- `이점(resulting quality)`
  - P2P 네트워크는 여러 노드에 파일의 중복 사복을 놓는 식으로 주로 사용되는데,
    한 노드가 오프라인이 되더라도 다른 노드가 살아있으므로 가용성이 향상된다.
  - 그리고 개별 노드의 장애 때문에 시스팀에 손상될 가능성이 적어 복원력이 높아진다.
  - 또한 노드를 추가하기만 하면 되므로 P2P 네트워크는 규모확장성과 확장성이 뛰어나다
- P2P 네트워크의 일부 강점은 노드의 상호 연결성에서 비롯되지만 노드 집단이 주 네트워크에서 분리되어 외딴 섬이 된다면 정상 동작하지 않을 수 있다.
  - 이러 섬 현상을 피하는 것은 새로운 노드를 메인 네트워크에 연결하는 걸 제어하면 되는데, 이것은 마스터 노드를 지정하는 것과 같이 엄격한 P2P의 지침을 위반할 수 있다.

### 맵리듀스 아키텍처 스타일(map-reduce)

- 맵리듀스 스타일은 검색 엔진이나 소셜 네트워킹 사이트와 같은 인터넷 기반의 시스템에서 볼 수 있는 대규모 테이터 셋을 처리하는 데 적합하다.
- 정렬이나 검색과 같이 개념적으로 간단한 프로그앰은 단일 컴퓨터를 사용할 때 대용량 데이터 셋에서 느리게 실행되는데, 맵리듀스를 활용하면 계산을 여러 컴퓨터에 분산할 수 있고
- 사용하는 컴퓨터 수가 증가하면 컴퓨터 하나가 실패할 가능성도 증가하는데, 이러한 실패에서 복구할 수 있도록한다.

![Untitled](https://github.com/AUSG/2023-book-study/assets/72328687/207c277c-d23c-4731-956c-3141d673fd18)

- 위 이미지는 맵리듀스 시스템에서 일반적인 배열의 모습이다.
  - 큰 데이터 셋은 스플릿(split)이라고 불리는 더 작은 데이터 셋으로 분할되고 전역 파일 시스템(Global FS)에 저장된다. 이러한 데이터 셋 중 하나 이상을 Map Worker 가 처리(mapped 라고 표현)하고 중간 결과가 로컬 파일 시스템(Local FS)에 기록된다.
  - 중간 결과와 Map Worker는 다른 사람의 출력을 읽을 수 없다.
  - 리듀스 작업자(Preduce Worker) 컴포넌트는 여러 로컬 파일 시스템에서 로컬 결과를 읽고 결과를 결합(축소=reduce 라고 표현)하여 전체 파일 시스템에 저장할 완전한 최종 결과를 생성한다.
  - 여기서 맵 작업자와 리듀스 작업자는 독립적이고 각각 고유한 로컬 파일 시스템이 있는 컴퓨터 셋에서 실행된다.
  - 마스터 작업자는 다른 작업자를 생성하고 분할 작업을 Map Worker에게 할당한다.
  - 또한 작업자의 상태를 모니터링하고 작업자에서 실패가 발생하면 작업 일정을 다시 설정한다.
  - 이 스타일로 작업하는 개발자는 단일 시스템이 단일 데이터 청크를 처리하는 방법의 정확성에 관해서만 추론하면 된다.
- `이점(resulting quality)`
  - 맵리듀스가 개선하는 주요 품질은 `규모확장성`이다. 단일 컴퓨터로 계산하기에는 비현실적인 작업을 여러 컴퓨터로 나누어 성능을 향상시킬 수 있다.
  - 또한 맵리듀스는 작업자의 상태를 모니터링하고 작업자에서 실패가 발생하면 다른 시스템에서 작업을 다시 예약하여 시스템 장애를 복구하므로 시스템 장애를 복구하므로 가용성이 높다.
- 맵리듀스의 성능은 데이터 지역성(data locality)의 영향을 많이 받는다.
  - 중간 결과를 맵 작업자와 리듀스 작업자에 가깝에 유지해서 네트워크 대역폭을 줄이는 것이 중요하고 전역 파일 시스템은 대개 분산된 중복 파일 시스템이다.

## 마치며

- 아키텍처 스타일을 사용하면 아키텍처의 일관성과 이해도가 향상되고, 개발자 간 의사소통의 밀도와 정확성이 높아지며, 설계 재사용이 촉진된다.
  - 아마도 제약 조건을 활용해 아키텍처가 품질 속성을 홍보하거나 보장할 수 있게 하고 설계 인력의 분석 능력을 촉진한다는 점이 가장 중요하다.

# 15. 아키텍처 모델 사용하기

## 바람직한 모델 특성

- 좋은 모델에 있는 바람직한 특성을 몇 가지 설명한다.

### 충분한 정밀도

보통 인기있는 두 가지 모델링 접근 방식은 다음과 같다.

- `만화처럼 그리기`
  - 대력적인 아이디어를 제공하기 위해 간단한 그림을 짧은 회의 시간 안에 그린다.
  - 모델의 부정확성을 인식하기 어렵다.
  - 가장 나쁜 예시는 충분히 정확한 것 같아 보이지만 실제로 그러지 않은 케이스다.
- `청사진 활용하기`
  - 몇몇 부분을 배제하는 반면 일부 내용을 매우 상세하게 다룬다.
  - 매우 상세하게 다루기 때문에, 좀 더 쉽게 형식화하거나 보다 쉽게 이해할 수 있는 아이디어를 눈 앞에 두고 괜한 고생을 하는 것이 아닌가하는 의구심이 들 수 있지만, 정확한 모델을 만드는 데는 오랜 시간이 걸리지만 노력할 만한 가치가 있다.
- 결국 **두 접근 방식 중 현재 상황에 맞게 트레이드오프를 고려해서 선택하는 것이 가장 중요하다.**

### 정확성

- 정확성은 `현실 세계와의 일관성`, `모델 내 일관성 및 참조 무결성`, `반증 가능성`을 포함한 여러 가지 고유한 아이디어에 관련된 광범위한 용어다.
- `현실 세계와의 일관성`
  - 작업을 수행한 모델의 결과물이 현실 세계와 일치해야 한다.
- `자체 일관성 및 참조 무결성`
  - 자체 일관성을 유지하기 위해 모델 내부에 모순이 없어야 하고
  - 모델은 모델의 요소만 참조하고 모델에 언급되지 않은 항목. 즉 유효하지 않은 객체에 대한 dangling reference가 없이 참조 무결성을 유지해야 한다.
- `반증가능성`
  - 모델에서 내린 결론이 참인지 거짓인지 판단하는 능력을 요구한다.

### 예측

- 미래에 대해 알려줄 수 있는. 즉, 리스크를 줄일 수 있는 예측 가능한 모델을 구축하려고 노력해야한다.
- 구축가능성(constructability)과 적합성(suitability)에 관한 예측도 중요하다. 두 컴포넌트가 호환되지 않는 다는 사실을 구현 중에 알아내는 것보다 더 빨리 알아내는 것이 좋다.

### 이해력 증진

- 정확성과 마찬가지로 모델이 이해력을 증진해야 함은 분명하다. 문제에 대한 이해도를 떨어뜨리는 모델은 다른 이점을 통해 한계를 보완해야 한다.
- `세부 사항 제약`
  - 모델의 이해 가능성을 높이는 가장 확실한 방법으로 세부 사항을 제한하는 것이다.
  - 이런 식으로 큰 문제를 사람들이 이해할 수 있을 정도의 제약된 크기로 조정하면 더 쉽게 이해력 증진이 된다.
- `주의를 집중 시키는 방법`
  - 사실 세상이 점점 복잡해지고 있지만 관심은 제약적이다. - 허버트 사이먼(Herbert Simon)
  - 문제의 중요한 세부 사항에 제한된 주의가 집중되도록 하여 모델에 대한 이해도를 높일 수 있다.
  - 모델을 구축하고 선택한 세부 사항을 노출할 때 세부 사항을 선택하여 다른 사람들에게 전문 지식의 이점을 제공할 수 있다.
- `적절한 형식과 표기법`
  - 적절한 형식과 표기법을 활용하여 표현력을 높이고 독자의 이해가능성을 높여라
  - 모든 모델의 이해가능성이 동일한 것은 아니다.
  - 일반적으로 모델의 본질을 다른 형태로 표현할 수 있고 표현력에 따라 이해가능성이 다르다.
    - 대부분의 프로그래머가 객체 추상화를 쉽게 이해하기 때문에 객체지향 프로그래밍이 대중화되었을 가능성이 높다.
    - 함수형 프로그래밍에는 많은 이점이 있지만 대부분의 프로그래머는 함수보다는 객체에 관해 더 쉽게 추론하는 경향이 있다.
- `모델을 여러 level로 분리해 구성하기`
  - 모델을 여러 level로 분리해 조각으로 구성하면 모델의 이해도를 높일 수 있다.
  - 대부분의 복잡한 것은 내부 구조를 갖도록 설계되어 컴포넌트를 전체와 분리하여 이해할 수 있으며, 컴포넌트가 작업을 수행하는 방법을 정확히 알지 못해도 전체를 이해할 수 있다.
  - 설계의 최상위 수준은 서브 컴포넌트를 자세히 들여다 보지 않고도 이해할 수 있어야 하며 서브 컴포넌트도 자체 서브 컴포넌트를 열지 않고도 이해할 수 있어야 한다.

### 일괄된 세부 수준

- 세부 사항이 적은 모델보다 많은 모델을 항상 선호하는 것은 아니다. 대신 모델은 일부 컴포넌트를 다른 컴포넌트보다 더 자세하게 유지하기보다는 일관된 세부 수준(consistent level of detail)을 지키려 노력해야 한다.
- 여러 세부 수준이 혼합된 모델은 다양한 이유 때문에 다른 추가 세부 정보가 발생할 수 있으므로 모델을 살펴보는 독자에게 혼동을 줄 수 있다.
- 모델의 독자는 모델 작성자가 공개하고 싶을 때가 아니라 독자가 원할 때 추가 세부 사항을 흡수할 수 있어야 한다.
  - 대부분의 독자는 더 간단한 모델에서 큰 그림을 먼저 이해한 다음 필요하거나 호기심이 들 때 세부 사항을 선택적으로 탐색하는 편이 더 쉽다고 생각한다.

### 단일 주제 뷰

- 정보를 의도적인 포함하고 배제하는 과정을 거쳐 가장 좋고 유용한 모델이 생성된다.
- 모델의 뷰를 표시할 때는 모델의 정보 범주를 선택적으로 일관되게 표시하는 `단일 주제 뷰`를 사용하면 가장 좋다
- `단일 주제(monothematic)` 라는 이름은 뷰가 일관되게 단일 항목을 표시한다는 생각을 강조하지만 단일 범주의 정보만 표시한다는 의미는 아니므로 처리량과 신뢰성을 모두 표시해도 된다.
  - 하지만 일관성 없이 정보만 뿌려선 안되고 적절하게 조절해야 한다.
  - 일부 커넥터에만 구현 기술을 표시하는 주석을 추가하는 것은 바람직하지 않고
  - 다양한 정보를 비슷한 정도로 제공하는 뷰는 설명하려는 포인트가 명확하지 않아 주의를 흩뜨려 금방 엉망이 된다.

### 낮은 비용

- 이 책의 중심 주제는 엔지니어링에 드는 노력이 인지된 리스크와 일치해야 한다는 점이다.
- 그리고 비용이 낮은 모델이 아키텍처를 정당화하기 더 쉽다.
- 보통 이익 곡선이 비용 곡선보다 앞서기 때문에 리스크를 해결하는 가장 비용이 낮은 모델을 찾아야 한다.

## 뷰를 이용한 작업

- 뷰를 잘 다루는 방법에 대해서 알아보자.
- 하나의 뷰타입 또는 하나의 뷰로 시스템에 대해 추론하기가 쉬웠다면 계속 그렇게 해도 된다. 하지만 이런 상황에서 여러 뷰를 만드는 건 구축하고 저장하기가 어려워서 사용하지 않을 것이다.
- 그러나 소프트웨어 규모가 커지면 단일 모델로는 이해하기 어렵고 눈에 띄는 세부 사항이 외부 세부 사항과 섞여 있어서 분석하기도 어렵다.

### 분할 정복

- 대형 모델을 마스터 모델로 유지하되 일부 세부 정보를 선택해서 표시하는 뷰를 구성한다.
- 마스터 모델을 작업하기 더 쉬운 뷰로 분할하는 것은 분할 정복 전략의 대표적인 예시다.

### 각 관심사에 대한 뷰

- 각 관심사에 대한 뷰를 구축하여 뷰를 분할하자.
- 각 관심사에 따라 중요하다고 판단하고 보고 싶어하는 부분이 다를 것이다 그래서 관심사에 따라 뷰를 분할 구축하면 자신이 전문으로 하는 문제를 해결하는데 도움이 될 것이다.

### 주의점

- 일반적으로 큰 문제를 작은 문제로 나누는 것은 좋은 전략이지만, 각 뷰의 초점이 좁고 이러한 좁은 뷰 사이에는 몇 가지 문제가 있어서 어려움을 겪에 된다. 이 어려움에 대해 알아보자.
- `좁은 초점을 만드는 전문화된 뷰`
  - 전문화되고 좁은 뷰의 모음을 볼 때 이러한 뷰를 머릿속에서 합성해서 마스터 모델이나 전체 시스템을 구상하기 어려울 수 있다.
  - 좁은 시야는 코끼리를 이해하는 세 명의 장님 이야기와 매우 흡사한데, 한 사람은 코끼리가 나무처럼 둥글고 강하다고 말하고, 다른 사람은 뱀처럼 유연하다고 말하는 등 각각 이해하는 관점이 다르고 이 관점을 통합해 코끼리를 이해해야하는 복잡한 상황에 놓인다.
  - 반대로 뷰를 빌드할 때 모듈, 런타임, 할당과 같은 각 뷰타입의 뷰를 하나씩 포함하면 독자가 뷰를 재조립해서 시스템을 이해하기가 한결 수월해질 수 있다.
- `뷰 사이의 몇가지 문제`
  - 좁고 전문화된 뷰는 특별한 관심사에 집중할 수 있도록 불필요한 세부 정보를 제외하고
  - 이러한 뷰를 생성하여 지렛대 효과를 얻지만 관심사 간의 상호작용에 관한 지식을 어디에 넣어야하는지 등 비용이 발생한다.
    - 한 가지 해결책으로는 둘 이상의 관심사와 관련된 세부 정보를 보여주는 혼합 관심사 뷰를 만드는 방법이 있다.
- `뷰 간의 불일치`
  - 여러 뷰를 만들다보면 뷰 간의 불일치가 발생하기 시작한다.
  - 마스터 모델 접근 방식에서는 마스터 모델에 결함이 있거나 마스터 모델의 뷰를 그릴 때 실수를 했기 때문에 불일치가 발생할 수 있다고 한다.
    - 따라서 모순되는 뷰를 발견하면 해당 모순을 마스터 모델의 버그나 뷰를 생성한 프로세스의 버그로 간주하고 찾아야 한다.

### 피해야 할 안티패턴

- `선호하는 뷰`
  - 다양한 문제를 해결하려면 다양한 뷰가 필요하지만 당면한 문제에 부적절하더라도 개발자가 선호하는 뷰에 집착할 수 있다.
  - 일반적으로 선호하는 뷰를 계속 사용하여 시스템에 관해 추론할 수는 있지만 더 적절한 뷰나 뷰타입을 사용할 때보다 어렵다.
  - 따라서 일반적으로는 이런 어려움을 겪는 것보다는 문제에 적합한 뷰와 뷰타입을 사용해야 한다.
- `모든 것을 통제하는 하나의 다이어그램`
  - 하나의 뷰에 초점을 맞추는 아이디어는 하나의 다이어그램이 모든 용도와 적합하도록 만드는 시도와 밀접한 관련이 있다.
    - 이는 다이어그램 작성자가 뷰타입을 조정하기 어렵거나 불가능하다는 점을 아직 깨닫지 못하고 모든 세부 사항을 단일 다이어그램에 넣으려 해서 자주 발생한다.
  - 결국 단일 다이어그램이 복잡해지고 이해하기 어려워지므로 다이어그램 작성자는 독자가 쉽게 파악할 수 있도록 표현하기 어려운 관련 세부 사항을 생략할 수 있다.

## 뷰 품질 향상

- 뷰를 관리하고 불일치를 감지하고, 일관성을 유지하는 데 도움이 되는 기법인 세 가지를 알아보자
  - 기능 시나리오 작성
  - 시나리오 구동
  - 작업 사양 작성

### 기능 시나리오 작성

- 기능 시나리오는 자유롭게 작성하더라도 항상 이야기처럼 읽는 이점이 있다.
- `좋은 시나리오를 작성하기 위한 체크리스트`
  - `액터(actor)`
    - 능통태를 사용하면 액터가 숨겨지는 것을 피할 수 있다.
  - `동작(action)`
    - 각 단계는 대상 모델에 정의된 단일 작업을 명확하게 다루어야 한다.
    - 좋은 시나리오는 여러 단계에서 단일 수준의 추상화를 갖는다.
  - `참조(reference)`
    - 시나리오 단계는 전달된 매개변수나 반환값과 같은 모델 요소를 참조한다.
  - `대상 모델(target model)`
    - 각 단계는 대상 모델을 하나의 허용되는 구성이나 상태에서 다른 구성으로 변환해야 한다.
    - 어떤 단계도 모델의 불변 사항이나 제약 조건을 깨뜨리지 않아야 한다.
  - `종합(overall)`
    - 시나리오 작성 후에 전반적으로 이런 질문들을 해보자
      - 시나리오가 전반적으로 말이 되는가?
      - 어떤 단계나 어려움을 건너뛰지는 않았나?
      - 찾아보는 단계가 필요한데도 시나리오의 어떤 액터가 무언의 위치를 ‘그냥 알고’ 어떤 다른 물체나 액터와 대화해야 하는지를 ‘그냥 알고’있지는 않은가?
      - 임의의 어려운 시작이나 해지 단계를 생략하지는 않았는가?
    - 시나리오 단계를 작성할 때는 이런 질문들을 해보자
      - 정확히 올바른 단어인가?
      - 나머지 모델과 일치하는가?
      - 대상 모델을 비워 놓고 시나리오에서 언급한 항목을 추가하는 방법을 사용할 수도 있음.
- 참조에 주의를 기울이지 않은 시나리오도 설계를 이해하고 문서화하는 데 유용할 수 있지만 신중하게 구성한 시나리오는 작성하는 동안 오류나 누락을 포착하는 데 도움이 되며 뷰가 어떻게 결합되어 전체 설계를 드러내는 지 생각하는 데 유용하다.

### 시나리오 구동

- 시나리오를 작성했으니 모델의 문제를 확인하기 위해 시나리오를 구동해봐야한다(animating scenario)
- 시나리오 구동이란 개발자가 시나리오를 따라 진행하고 단계별로 상상하며 동작시켜 보는 일을 의미한다.
  - 개발자는 이 과정에서 각 단계에서 모델이 변화하는 모습을 상상하고 이러한 작업은 모델을 이해하는 데 도움을 주어 불일치와 누락 오류를 포착하는 데 도움을 준다.

### 작업 사양 작성

- 사전 조건과 사후 조건 등 어떤 동작에 스펙을 작성한다
- 다만 시간이 오래 걸리고 비용이 큰 작업이기 때문에 작업 사양을 적지 않아도 ‘사전 조건과 사후 조건을 충족하는 데 필요한 모든 용어를 정의했는가?’라고 생각 해볼수있다.

## 다이어그램 품질 개선

- 다이어그램에 범례 넣기
  - 다이어그램을 잘 이해할 수 있는 요소들을 적당하게 넣어라.
- 커넥터에 화살촉 방지
  - 화살촉이 무엇을 의미하는지 잘못 추측할 수 있으니 주의하자
  - 화살촉 사용 자체가 옳고 그른 것은 아니고 선택의 문제다
  - 화살촉을 사용할 때는 꼭 범례를 사용해 화살촉의 의미를 나타내자

## 테스트 및 증명

- 모델을 테스트해보는 것도 중요하다.
- 실제 데이터로 모델을 테스트해보기
- 분석 모델을 활용해 증명하기
  - 격리, 교착 상태 ,성능, 보안과 같은 속성을 증명하려면 유추 모델 대신 분석 모델이 필요하다.

## 아키텍처 모델 분석

- 사람이 분석하기
  - 인간의 두뇌는 정보를 처리하는 데 탁월하지만 정보의 형태에 상당히 의존한다.
  - 인간의 기본 분석 능력을 향상시킬 수 있게 올바른 표현이 되어있는지 확인하자.
  - 아키텍처 모델에 그라데이션 등 이를 꾸미고 싶다면 그게 모델의 이해를 돕는 걸 방해하진 않을지 고민하자.
- 분석을 위해 모델 변환하기
- 보안 분석
- 신뢰성 분석
  - 버그 등
- 성능 분석
- 정확성, 완전성 등

## 아키텍처 불일치

- 실제 만들 것과 아키텍처가 불일치할 수 있는데 그 대표적인 영역은 다음과 같다.
  - 컴포넌트에 대한 가정: 인프라, 제어 권한, 데이터 사용
  - 커넥터에 대한 가정: 프로토콜, 전송된 데이터의 구조
  - 시스템에 대한 가정: 시스템 토폴로지, 컴포넌트 유무
  - 개발 과정에 대한 가정: 초기화 순서

## 추상화 수준 선택

- 모델을 구축할 때 명시적 또는 암시적으로 추상화 수준을 선택한다는 점을 인지해야 한다.
- 모델이 만족해야하는 부분들(보안, 성능 등)을 파악하고 이에 만족하면서 가장 비용이 낮은 모델을 구축해야한다.

## 사용자 인터페이스 계획

- 소프트웨어를 설계할 때 백엔드와 UI를 독립적으로 구축할 수 있다는 것은 오래된 지혜이고
- 새로운 지혜는 백엔드 설계가 일부 UI 선택을 비현실적으로 만들 정도로 UI의 사용성을 활성화하거나 억제할 수 있다는 점이다.
  - UI를 예상하고 좀 더 유연한 설계를 가져갈 순 없을지 고민하라

## 규범 모델(prescriptive model)과 설명 모델(descriptive model)

- 아키텍처 모델을 사용할 때는 이 두 가지 모델의 차이점을 알아야한다.
  - 규범 모델은 사물이 어떻게 되어야 하는지를 말하고
  - 설명 모델은 사물이 어떠한지 이야기 한다.
- 표준 아키텍처의 추상화 집합(모듈, 컴포넌트, 커넥터, 포트, 역할 등)은 향후 소프트웨어 개발이 올바르게 진행되도록 방향을 제시하므로 캡슐화와 명확한 통신 채널을 장려한다는 점에서 규범적이다

## 기존 시스템을 모델링하기

- 이미 기존 시스템이 있는 경우라면 어떻게 이를 설명하는 아키텍처 모델을 구축할 수 있을까?
- 시스템에 백만 줄의 코드가 있다면 모든 코드를 읽을 시간이 없으므로 먼저 모델링을 원하는 이유와 모델이 무엇을 해야하는지 스스로에게 질문해볼 필요가 있다.
  - 필요에 따라 모델링할 부분을 선택하라
