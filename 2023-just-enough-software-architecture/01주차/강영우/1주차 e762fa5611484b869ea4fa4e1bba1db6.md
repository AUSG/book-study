# 1주차

## Chapter 1 개요

개발자가 ‘정신적 추상화’ 개념을 갖췄다면 소프트웨어의 세부 정보를 이용하여 더 깊이 이해할 수 있다.

### 1.1 분할, 지식, 추상화

- 소프트웨어의 복잡성을 성공적으로 해결하기 위한 덕목
    - 분할
        - 분할한 부분이 다른사람이 해결할 수 있을 정도로 작고, 어떻게 부품으로 전체를 조림하는지 추론할 수 있으면 효과적이다.
        - 일시적으로 다른 부분의 세부사항을 잊어버려도 되기 때문에 유용하다.
    - 지식
        - 이전에 해결한 지식을 활용해 문제를 해결한다.
    - 추상화
        - 문제를 축소해서 해결하기 쉬운 더 작은 문제로 만들어 규모와 복잡성의 문제를 효과적으로 해결한다.
- 소프트웨어 아키텍처로 위의 세가지 덕목을 모두 갖출 수 있다.

### 1.2 소프트웨어 아키텍처 세 가지 예시

- 아키텍처: 소프트웨어 시스템의 거시적 설계
- 랙 스페이스의 고객문의를 대처하기 위한 세가지 버전의 시스템
    - 버전1: 로컬 로그 파일
    - 버전2: 중앙 데이터베이스
    - 버전3: 인덱싱 클러스터

### 1.3 되돌아보기

- 동일한 기능을 제공하지만 아키텍처가 다르다. → 시스템 아키텍처는 기능과는 별개의 선택이다.
- 품질 속성(quality attribute): 수정가능성, 규모확장성, 레이턴시
    - 트레이드 오프를 잘 생각하면서 결정해야 한다.
- 개념 모델(conceptual model)
    - 아키텍처 전문가는 각 시스템 분할의 차이를 알 수 있다.
    - 아키텍처 전문가는 도메인 사실, 설계 결정, 구현 세부 정보를 구분하고 묶을 수 있다.
- 추상화(abstraction)와 제약 조건(constraint)
    - 소프트웨어는 작은 것을 모아 큰 것을 만들지만, 이해하기에는 큰 것을 보는 것이 더 효율적이다.
    - 임의의 코드보다 작업은 더 많은 제약 조건을 따르는 추상화이다.
    - 코드가 무엇을 하지 않는지 알 수 없기 때문에 임의의 코드만으로는 추론하기 어렵다.

### 1.4 관점 이동

- 소프트웨어 아키텍처 아이디어를 효과적으로 적용하려면 주류 프로그래밍 언어에서 볼 수 있는 추상화(클래스/객체)만 사용하지 않고, 컴포넌트와 커넥터 같은 조금 더 넓은 추상화까지도 수용하는 의식적이고 명시적인 전환이 필요하다.
- 그렇지 않으면 클래스만 잔뜩있는 프로그램이 만들어진다.

### 1.5 아키텍처를 아키텍처링하는 아키텍트

- 직책: 아키텍트(architect)
    - 소프트웨어 아키텍트라는 직책을 사용한다면 개발에 지속적으로 관여해야한다.
    - 모든 소프트웨어 개발자는 소프트웨어 아키텍처를 이해해야한다.
- 프로세스: 아키텍팅(architecting)
    - 개발 프로세스와 설계(아키텍처)는 격리되어있다.
- 엔지니어링 결과물: 아키텍처(architecture)
    - 모든 자동차 구조와 설계가 있듯이 모든 소프트웨어 시스템에는 아키텍처가 있다.
    - 직책과 프로세스와는 완전히 격리된 고유한 아키텍처가 생긴다.

### 1.6 리스크 주도 소프트웨어 아키텍처

- 개발해야하는 소프트웨어 리스크로 아키텍처 작업량을 결정해야한다.
- 리스크 주도 모델: 적절한 아키텍처링 기법을 선택, 적용하고 시간을 가늠할 수 있어 적정 아키텍처 작업을 수행하도록 도와준다.
- 각 프로젝트의 리스크를 평가하고, 리스크를 기반으로 아키텍처 작업을 시작할건지, 어떤 부분을 시작할건지를 정해야한다.
- 리스크 주도 모델은 아키텍처 작업의 공수와 종류 선정에 대한 대답을 주는 데 도움이 된다.

### 1.7 애자일 개발자를 위한 아키텍처

- 적정 아키텍처
    - 리스크 주도 모델은 개발자가 충분한 아키텍처링을 수행한 다음 코딩을 시작할 수 있도록 안내한다.
    - 리팩터링으로 해결하기 힘든 ‘보안’, ‘규모확장성’을 확보하기 위해서는 아키텍팅을 하고, 다시 코딩으로 돌아갈 수 있도록 한다.
- 개념 모델
    - 리스크 주도 접근으로 아키텍처를 애자일에서 빈틈이 있는 부분들을 메워줌으로써 더 나은 시스템을 구축할 수 있다.

### 1.8 이 책에 대하여

- 소프트웨어 아키텍처와 리스크 주도 접근 방식 소개
- 소프트웨어 아키텍처 개념 모델 설명

# Part 1 리스크 주도 소프트웨어 아키텍처

## Chapter 2 소프트웨어 아키텍처

### 2.1 소프트웨어 아키텍처 개요

- 아키텍처 및 상세 설계
    - 설계는 결정과 의도로 이루어지고, 아키텍처와 상세 설계로 나눌 수 있다.
    - 아키텍처: 전체 시스템 구조의 설계와 사양
    - 상세 설계: 알고리즘, 계산 자료구조
- 정의
    - 아키텍처는 시스템에 대해 추론하는 데 필요한 구조의 집합으로 소프트웨어 요소, 이들 간의 관계 그리고 이 둘의 속성으로 구성된다.
- 아키텍처의 범위는?
    - 아키텍처와 상세 설계 사이의 경계는 모호하다.
    - 모듈 및 모듈 연결 방식과 같이 설계의 거시적인 부분이다.
    - 상세설계는 그 외의 모든 것이다.
- 의도
    - 일부 낮은 수준의 세부사항까지 도달하는 아키텍트의 몇가지 높은 수준의 의도나 결정에서 ’일련의 의도‘가 존재한다.
    - 시스템 전반적인 품질을 달성하는 데 세부 사항이 중요하다면 아키텍처와 관련이 있다고 할 수 있다.

### 2.2 소프트웨어 아키텍처가 중요한 이유

- 소프트웨어 아키텍처를 잘 선택하면 리스크가 줄어든다.
- 아키텍처는 시스템의 골격 역할을 한다.
    - 목적에 맞는 골격을 고르면 더 좋은 시너지를 낸다.
    - 하지만 뼈보다 더 많은 부분을 차지하고, 보이지 않는 제약조건이 더 중요하다.
- 아키텍처는 품질 속성에 영향을 미친다.
    - 개발자는 ‘기능’에 집중해야하고, 시스템은 ‘품질 속성’ 요구사항을 기능과 함께 충족해야한다.
    - 적절한 아키텍처를 선택하면 품질 속성을 달성할 수 있다. 성장하는 품질 속성을 충족하기 위해서 아키텍팅을 지속적으로 해야한다.
- 아키텍처는 (대부분) 기능과 직교한다.
    - 기능과는 별개의 선택이지만, 적절한 아키텍처를 선택하면 이득을 볼 수 있다.
- 아키텍처는 시스템을 제한한다.
    - 고의로 제약을 함으로써 예상치 못한 방향을 배제하고 목표를 잘 수행할 수 있도록 한다.
    - 시스템이 하지 않는 일을 파악해서 하지 말아야 하도록 제약해야 한다.
    - 적절한 제약조건은 다음 이점을 제공한다.
        - 판단을 구체화한다.
        - 개념적 무결성을 장려한다.
        - 복잡성을 줄인다.
        - 런타임 동작을 이해한다.

### 2.3 아키텍처가 중요한 상황은?

- 규모가 크거나 복잡도가 높은 시스템에서 아키텍처에 시간을 더 할애해야할 수 있음
- 아키텍처 리스크가 높은 5가지 구체적인 사례
    - 선택할 수 있는 해결책이 적음 (인간 동력 비행기)
    - 높은 실패 리스크 (병원 시스템)
    - 어려운 품질 속성 (수백만명의 사용자가 있는 서비스의 빠른 속도)
    - 새로운 도메인 (경험이 없는 분야)
    - 제품 라인 (공통 아키텍처를 사용하는 경우)
- 암달의 법칙: 시스템에 기여하는 바가 높은 부분을 가속화하면 그만큼 큰 영향을 준다.

### 2.4 추정 아키텍처

- 추정 아키텍처: 특정 도메인에서 지배적인 아키텍처군
- 레퍼런스 아키텍처와 비슷하지만 레퍼런스 아키텍처는 염원이 담긴 표준이고, 추정 아키텍처는 사실상 표준이다.

### 2.5 소프트웨어 아키텍처 사용법

- 세 가지 아키텍처 설계 접근법
    - 아키텍처 무관 설계
        - 추정아키텍처를 사용하거나, 별 생각 없이 아키텍처 선정
    - 아키텍처 집중 설계
        - 기능, 품질을 고려해 의도적으로 아키텍처 선정
        - 목표를 달성할 기회를 제공함
    - 아키텍처 상향 설계
        - 시스템의 목표나 속성을 보장하기 위해 아키텍처를 설계
        - 목표를 달성할 수 있음

### 2.6 아키텍처 무관 설계

- 개발자가 시스템 아키텍처를 인식하지 못하는 경우
- 의도적으로 선택된 아키텍처가 없다.
- 리스크가 적은 프로젝트에 적합하다.
- 아키텍처 비전이 부족하다면 개발자마다 다양한 변경이 일어나고 시스템의 복잡성이 증가된다.
- 서비스 버스와 관계형 데이터베이스 같은 것들로 일부 개선 가능하다.

### 2.7 아키텍처 집중 설계

- 어떤 아키텍처가 시스템에 적절한지 판단하고 선택한다.
- 아키텍처가 최소한 시스템에 적합하고, 목표 달성을 방해하지 않아야 한다.
- 직면한 문제에 관한 지엽적 수정이 아닌 아키텍처 수준의 해결책을 찾는다.
- 아키텍처 선택에 영향을 미칠 요구사항을 찾아야 하지만 요구사항은 명확하게 설명하기 어렵다.
    - 요구사항을 인식하게 된다면 아키텍처가 어떤 영향을 미칠지 검토해야 한다.

### 2.8 아키텍처 상향 설계

- 시스템의 목표나 속성을 보장하는 아키텍처를 설계한다.
- 아키텍처가 자신을 위해 일하거나 작업을 더 쉽게 하도록 만들어 준다.
- 일반적으로 트레이드오프를 포함한다.
- 개발자가 전문적이지 못한 부분을 아키텍처에서 처리하면, 자신의 전문 분야에 집중해서 처리할 수 있다.

### 2.9 대규모 조직에서의 아키텍처

- 엔터프라이즈 아키텍트와 애플리케이션 아키텍트가 필요하다.
- 엔터프라이즈 아키텍트
    - 많은 애플리케이션을 담당하는 개발자
    - 전체 기업에 기여하도록 하는 에코시스템을 설계한다.
    - 소프트웨어의 품질에 직접적인 영향을 미칠 수 없다.
    - 아키텍처와 제약 조건을 선택해서 애플리케이션 아키텍트를 제한한다.
- 애플리케이션 아키텍트
    - 단일 애플리케이션을 담당하는 개발자
    - 애플리케이션을 구성하는 수천 개의 객체를 이해하고 관리할 수 있다.
- 장단점
    - 이 두 아키텍트를 분리하면 고도의 표준화를 하지 않아도 이질성과 혼란을 피할 수 있다.
    - 하지만 다중 상사 문제가 있어 일정/통합에서 우선순위가 다를 수 있다.
    - 적절한 아키텍처 제약 조건 선택을 잘못하면 오히려 어려워질 수 있다.

### 2.10 마치며

- 아키텍처는 대규모 결정 및 거시적 요소를 다루는 설계이다.

## Chapter 3 리스크 주도 모델

- 성공적인 소프트웨어를 만드는 일 === 발생할 만한 실패를 예상하고 실패할 만한 설계를 피하는 일을 의미
- 실패를 제거하는 관점에서 생각하면 성공적인 설계가 만들어진다.
- 개발자가 사용해야하는 설계 및 아키텍처링 기법은 무엇인가?
    - 모든 기법을 사용하면 된다. 하지만 시간을 많이 할애하게 되므로 실용적이지 못하다.
    - 설계에 너무 많은 시간을 낭비하는 것도 개발자가 직면하는 리스크이다.
- 개발자는 얼마나 많은 설계와 아키텍처를 수행해야하는가?
    - 선행 설계 없음 / 척도 사용 / 문서 패키지 구축 / 즉흥 접근 방식
    - 또는 리스크 주도 모델

### 3.1 리스크 주도 모델 개요

- 리스크 주도 모델의 세 단계
    1. 리스크 식별 및 우선순위 지정
    2. 일련의 기법 선택 및 적용
    3. 리스크 감소 평가
- 리스크 집중 또는 기능 집중
    - 리스크 주도 모델의 핵심 요소는 리스크를 눈에 띄게 홍보하는 것.
    - 리스크가 아닌 다른 고려사항에 매몰된다면 결국 리스크를 따라갈 수 없다.
- 논리적 근거
    - 리스크 주도 모델에는 평가할 수 있는 논거를 생성하는 유용한 속성이 있다.
    - 여러 리스크 중 가장 중요한 리스크를 선정하고, 리스크를 줄이는 기법을 적용해보고 개선되었다면 지속적으로 구현한다.

### 3.2 리스크 주도성 자가 진단

- 본인이 설계를 하고 있다면, 직면한 리스크와 리스크를 다루는데 이용한 기법을 나열할 수 있어야 한다.
- 개발자가 문서 템플릿이나 설계 활동 목록을 포함하는 프로세스를 따르도록 하는 것은 유용할 수는 있지만 실수로 개발자를 잘못된 길로 들어서게 한다.
- 표준 프로세스나 템플릿 을 사용하면 특정 리스크와의 연관성이 없어지는 문제가 생길 수 있다.

### 3.3 리스크

- 리스크 = 인지한 실패 확률 * 인지한 영향
    - 이 식을 통해 리스크가 존재하지 않더라도 인지할 수 있다.
- 리스크는 모호해질 수 있다. 나중에도 리스크가 완화되었는지 테스트할 수 있도록 실패 시나리오를 이용해 리스크를 설명하는 것이 좋다.
- 리스크는 ‘엔지니어링 리스크’와 ‘프로젝트 관리 리스크’로 분류된다.
    - 각 리스크는 각 리스크에 맞는 기법을 사용해서 리스크를 줄여야 한다.
- 리스크를 식별하는 방법
    - 가장 달성하기 어려운 요구사항을 찾아야한다.
- 원형적 리스크
    - 도메인에 따라서 공통적인 리스크를 알 수 있다. 이것은 역사적으로 증명되었으며 중요한 체크리스트이자 리마인더다
    - 하지만 프로젝트가 표준과 다를 수도 있기 때문에 사각지대를 조심하자.
- 우선순위 지정
    - 리스크의 우선순위를 지정해야한다.
    - 보통 팀 내 인원들이 리스크를 결정한다.
    - 리스크를 두 가지 차원으로 분류해보자
        - 이해관계자의 우선순위
            - 기술적인 리스크는 이해관계자가 쉽게 평가 불가능하다
        - 개발자가 인식하는 어려움

### 3.4 기법

- 소프트웨어 엔지니어링 리스크 감소 기법 (이하 기법)
- 분석에서 해결책까지의 스펙트럼
    - 리스크를 해결하는데는 분석적 특징을 가지거나 알려진 좋은 해결책이 될 수도 있다.
        - 이를 전술 또는 패턴이라고 부른다.
- 리스크 주도 모델은 분석쪽에 해당하는 절차적이고 독립적인 기법에 중점을 둔다.
- 기법으로 리스크 완화
    - 리스크가 있다면, 이를 줄이는 기법을 고려하자.
    - 해결해야하는 리스크가 큰 의미가 있을 때만 기법을 사용하자.
- 최적의 기법 목록
    - 리소스 절약을 위해 우선순위를 지정한 리스크 목록을 적은 기법으로 완화시키는 기법을 사용하자.
- 리스크를 완전히 제거할 수 없다.
    - 리스크를  제거하려는 노력의 단점은 시간이 소모되는 점 때문이다.

### 3.5 기법 선택 가이드

- 기법 X가 리스크 Y를 완화하려고 동작하는 이유를 설명하는 원칙 세가지
    - 문제를 찾아야하고 때로는 문제를 증명해야한다.
    - 모델의 종류를 구분해야 한다.
        - 유추모델: 간접적인 분석만을 지원하며 일반적으로 도메인 지식이나 사람의 추론이 필요하다.
        - 분석모델: 계산적 분석을 직접 지원한다.
    - 일부 기법에는 친화성이 있다.
        - 만들어진 목적이 뚜렷해서 다른 용도로 사용하기 힘든 경우가 있다.
- 뷰타입 매칭
    - 모듈 뷰타입: 소스코드와 클래스 같은 타입의 결과물 포함 (수정 가능성)
    - 런타임 뷰타입: 객체와 같은 런타임 구조를 포함한다. (성능)
    - 할당 뷰타입: 서버룸과 하드웨어 같은 할당 요소를 포함 (보안)

### 3.6 적정한 투자

- 아키텍처 설계에 들이는 노력은 실패 리스크에 상응해야 한다.
- 실패 리스크를 인식한 영역만 설계하므로 불완전할 수 있다.
- 구현 후 리스크를 충분히 완화했는지 평가해야한다.

### 3.7 계획 설계와 진화적 설계

- 진화적 설계
    - 시스템이 구현되면서 시스템 설계가 확장됨을 의미
    - 리팩터링, 테스트 주도 설계, 지속적 통합을 통해 강력해지고 있다.
- 계획 설계
    - 구현 시작 전 계획을 매우 자세하게 작성하는 것
    - 지나친 선행 설계라고도 부름
    - 여러팀이 병렬적으로 일하거나, 성공적인 구현이 불확실 할 경우 사용하면 좋다.
- 최소 계획 설계
    - 20%의 계획 설계와 80%의 진화적 설계를 섞은 것
    - 아키텍처 집중 설계를 수행하여 가장 큰 리스크를 처리한다고 알려진 아키텍처를 설정하여 다른 설계 결정에 더 많은 자유를 부여한다.

### 3.8 소프트웨어 개발 프로세스

- 소프트웨어 개발 프로세스는 엔지니어링 리스크와 프로젝트 관리 리스크의 균형을 맞추도록 팀의 활동을 조율한다.
- 리스크는 엔지니어와 프로젝트 관리자가 공유하는 어휘이다. 이를 공유해야 서로 완벽한 이해도 없이도 트레이드 오프를 계산할 수 있다.
- 반복할때마다 리스크를 순서대로 세우고 그에 따라 다음 단계를 계획하고 시스템이 배포될 때까지 반복한다.
    - 의도적으로 리스크 완화단계를 개발 프로세스에 포함시킨다.
    - 하지만 잘못 포함되면 저주가 되기도 한다. 대규모에 적합한 프로세스를 소규모 팀에 적용시키는 등..

### 3.9 프로세스 변동의 이해

- 소프트웨어 개발 프로세스의 예와 설계 문제를 처리하는 방법

![Untitled](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20e762fa5611484b869ea4fa4e1bba1db6/Untitled.png)

- 개발 프로세스에 관해 이야기할 때 발생하는 다른 두 가지 중요한 변이점
    - 디자인 모델이 얼마나 상세해야 하는가
    - 디자인 모델을 얼마나 유지해야 하는가
- 리스크 주도 모델을 적용했을 때의 개발 프로세스
    - 폭포수: 분석 및 설계 단계에서 아키텍처 작업 수행
    - 반복적: 각 반복 내에서, 선택적 선행 설계중에 아키텍처 작업 수행
    - 나선: 수행할 아키텍처/설계 작업의 양이나 사용할 아키텍처와 설계 기법에 관한 지침 제공 안함
    - 통합 프로세스: 초기 반복에서 아키텍처 관련 요구사항에 대해 작업하는 것을 지지
    - 익스트림 프로그래밍: 선행 설계 작업을 피하거나 최소화하고 대부분 진화적 설계만 사용한다.

### 3.10 리스크 주도 모델과 소프트웨어 프로세스

- 소프트웨어 프로세스 각각의 정신을 유지하면서 리스크 주도 모델을 적용할 수 있다.

### 3.11 애자일 프로세스에 적용

- 아키텍처 스타일 초기 선택, 프레임워크 선택, 기타 상용 기성품 컴포넌트 선택과 같은 프로젝트 시작 단계의 몇 가지 리스크를 확인 해야함
- 반복이 끝나면 리스크를 테스트할 수 있는 항목으로 작성해야하고, 이 리스크 백로그를 기반으로 얼마나 잘 완화했는지 평가해야한다.
- 리스크와 기능의 우선순위는 제품 책임자에게 있다. 각 반복이 끝날 때 회고로 소프트웨어 개발자는 아키텍처 리스크를 평가하고 백로그에 입력해야한다.

### 3.12 리스크와 아키텍처 리팩터링

- 설계는 프로세스의 앞부분에서만 진행하는 작업이 아니다.
- 실패리스크 때문에 아키텍처 리팩터링을 해야지 할 수 있다.

### 3.13 리스크 주도 모델의 대안

- 설계안함
    - 명시적/묵시적으로 유사한 성공적인 시스템에서 추정 아키텍처를 사용하는 경우
- 문서 패키지
    - 완전한 문서화를 만드는 것. 하지만 작은 규모에서는 하기 힘들다
- 척도
    - 경험적 데이터를 기반으로 아키텍처 설계에 특정 %의 시간을 할애하자는 척도를 내세울 수 있다.
    - 제안으로 받아들이고 가이드로 보지 말자
- 애드혹
    - 경험과 프로젝트 요구사항의 이해를 바탕으로 즉각적으로 결정하기

## Chapter 4 예제: 홈 미디어 플레이어

- 예제를 통해 리스크 주도 접근 방식을 사용해서 리스크에 대응해 적용할 기법을 명시적으로 선택했다.

## Chapter 5 모델링 관련 조언

### 5.1 리스크에 집중하기

- 리스크와 기법간의 매핑을 잘 해야한다.
- 소프트웨어 아키텍처 리스크 주도 모델은 프로세스에 구애받지 않으므로 지나친 선행 설계 및 애자일과 호환된다.

### 5.2 아키텍처 이해

- 소프트웨어 시스템에 관한 풍부한 이해를 바탕으로 올바른 기법을 선택해야 한다.
- 이해의 핵심은 ‘왜’로 시작하는 질문이다.

### 5.3 아키텍처 기술 배포

- 아키텍트 뿐만이 아니라 개발자도 아키텍처에 관한 지식이 있어야 한다
- 한명의 아키텍트와 무지한 개발자보다 지식이 있는 여러 개발자가 있는 것이 더 낫다.

### 5.4 합리적인 아키텍처 선택

- x가 우선이므로 설계 y를 선택하고 단점 z를 수용했다 → 트레이드 오프 고려해서 사용

### 5.5 지나친 선행 설계 미리 피하기

- 너무 많은 시간을 프로토타이핑이나 설계에 소비하는 행위는 피하자
    - 완벽할 때까지 설계
    - 모델링을 위한 모델링
- 대규모 프로젝트에서는 사용해도 될수도..?

### 5.6 하향식 설계 방지

- 하향식 설계: 컴포넌트, 모듈 등의 상위 수준 사양을 상세 설계로 구체화하는 과정
- 상위에서 설정한 설계를 위반하기 쉽다.

### 5.7 남은 과제

- 리스크 추정
    - 리스크 식별
    - 리스크 우선순위
- 대체 아키텍처 평가
    - 세부사항이 없어서 대안을 평가하기가 힘들다
- 모델 재사용
    - 모든 것을 재사용하고자 하는 욕구가 있다
    - 하지만 모든 모델을 완전히 같게 재사용하는 것은 불가능에 가까움
- 엔지니어링 및 관리에 걸친 이슈
    - 경영진과 실무자 간 관리 이슈
-