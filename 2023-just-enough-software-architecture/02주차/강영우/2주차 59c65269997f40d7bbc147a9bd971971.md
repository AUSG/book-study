# 2주차

# Part 2 아키텍처 모델링

## Chapter 6 엔지니어가 사용하는 모델

복잡한 문제는 추상화를 통해 해결하자

### 6.1 규모와 복잡성에 필요한 추상화

- 문제가 크거나 복잡 → 클래스 추상화 사용
    - → 클래스 수가 증가 → 클래스 디자인 패턴 사용
    - → 클래스 수 더증가 → 더 큰 추상화 사용

### 6.2 통찰력과 지렛대 효과를 제공하는 추상화

- 모델은 필수 문제에 대한 통찰력 제공

### 6.3 시스템 품질 추론

- 시스템 속성을 추론하려면 세부 사항을 구축하고 이해하는데 도움이 되는 모델이 머릿속에 있어야 한다.
- 아키텍처 모델은 세부사항을 잘라내고 필수 부분과 관계에 집중하고 예측하며 대안을 평가하는데 도움이 된다.

### 6.4 세부 사항을 제거하는 모델

- 모델은 세부사항을 제거한다.
- 유용한 모델을 만들려면 올바른 세부사항은 포함하고 다른 부분은 숨겨야 한다.
- 완전한 모델과 사용할 수 있는 모델 사이의 차이를 알아야 한다.

### 6.5 추론을 증폭하는 모델

- 모델링 기술의 세가지 기본 수준: 모델 읽기, 모델 작성, 모델 추론 증폭
- 사전 조건: 모델 읽기 > 모델 작성 > 추론 증폭
- 모델을 이용해서 설계를 하면 기억해야 하는 세부사항의 양의 줄어들고, 오류를 쉽게 감지하며, 명확하지 않는 진실을 바로 발견할 수 있다.

### 6.6 질문이 먼저, 모델은 그 다음

- 모델을 구축하기 전에 모델이 답하기 원하는 질문을 알아야 한다.
    - 그러면 추상화 수준과 포함할 세부 정보를 더 쉽게 선택 가능하다.

## Chapter 7 소프트웨어 아키텍처 개념 모델

모델을 사용하는 아이디어는 잘못 사용하게 되면 분석 마비로 연결되기도 한다.

- 모든 프로젝트는 아키텍처를 문서화해야 한다: 아니다
- 아키텍처 문서는 포괄적이어야 한다: 아니다
- 설계는 항상 코딩보다 선행해야 한다: 아니다

개념 모델은 학습을 가속한다.

- 다른 사람들이 쌓아둔 지식을 발판삼아 더 멀리 가보자
- 모든 것들이 추상화이다. 아키텍처에 대해 깊이 학습하고 지속해서 실천하자

정신을 자유롭게하는 개념 모델

- 요약된 이해는 개념 모델의 형태를 취할 수 있다.
- 디자인 패턴을 공부한 적이 있다면 마주치는 프로그램에서 이러한 패턴을 인식할 수 있다.
- 개념 모델은 더 빠른 인식과 일관성으로 시간을 절약하고 추론을 증폭시킬 수 있다.

### 7.1 정준 모델 구조

- 역할: 개발하면서 알게 되는 사실과 구축하려는 모델을 구성하고 연관시키는 표준화된 방법을 제공함
- 본질: 추상에서 구체에 이르기까지 다양하며 뷰를 사용하여 각 모델의 세부 정보를 상세화 한다.

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled.png)

- 뷰를 사용하면 모델에서 세부 정보의 하위 집합만 선택할 수 있다. 그리고 다이어그램을 정준 모델 구조에 연결할 수 있고, 정준 모델 구조로 구성하면 분류 및 단순화에 도움이 된다.
- 정준 모델 구조는 다양한 사실을 여러 모델로 분류한다. 그래서 각 문제의 크기를 줄이고 더 쉽게 추론할 수 있다.

### 7.2 도메인 모델, 디자인 모델, 코드 모델

- 도메인 모델: 도메인에 관한 지속적인 진실 설명 (그냥 사실)
    - 타입 정의
    - 타입간의 관계
    - 타입과 관계가 시간이 지나면서 어떻게 변하는지 설명하는 행위
    - 사용자가 제어하지 않음
- 디자인 모델: 구축할 시스템을 설명 (설계 결정 또는 메커니즘)
    - 대부분 사용자가 제어함
    - 구축할 시스템은 도메인 모델에는 나타나지 않지만 디자인 모델에는 나타난다.
    - 설계 작동 방식의 일부 세부 정보를 결정하지 않고 남겨두고 코드모델에서 결정하도록 한다.
    - 재귀적으로 중첩된 경계모델과 내부모델로 구성 됨
        - 경계 모델: 공개적으로 표시되는 인터페이스만 언급
        - 내부 모델: 내부 설계도 설명한다.
- 코드모델: 시스템 소스 코드를 설명 (프로그래밍 언어로 작성하거나 이와 동일한 추상화 수준의 모델)
    - 시스템의 소스 코드 구현이거나 이와 동등한 모델
    - 디자인 모델의 디자인 커미트먼트의 집합은 불완전하지만 코드 모델에는 완전한 집합 혹은 머신에서 실행하기에 충분할 만큼의 집합이 있다.

### 7.3 지정 및 구체화 관계

- 지정 (designation)
    - 지정 관계를 사용해 서로 다른 모델의 유사한 항목이 대응해야 한다.
        
        ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%201.png)
        
    - 설계를 자유롭게 해도 되지만 도메인 진실을 위반하면 안된다.
    - 지정하지 않는 부분에는 제약조건이 없다.
    - 지정관계: 도메인 요소와 설계 요소 간의 대응 관계를 정의하는 매핑을 의미
- 구체화 (refinement)
    - 동일한 사물의 낮은 세부모델과 높은 세부모델 간의 관계임
    - 경계 모델과 내부 모델의 연결을 설명하는데 사용됨
        - 경계 모델과 내부 모델이 모드 같은 사물에 관한 동일한 모델이지만 노출하는 세부사항이 다르기 때문
    - 설계를 더 작은 조각으로 분해할 수 있어서 유용함
    - 디자인 모델과 코드 모델을 연결하는 데도 구체화가 적용되지만 간단하지는 않다.
        - 디자인 모델의 구조적 요소는 코드 모델의 구조적 요소에 깔끔하게 매핑됨
    - 디자인 모델의 ‘불변사항, 제약조건, 아키텍처 스타일’은 코드 모델에 없다.
    - 어떤 주류 프로그래밍 언어도 디자인 모델의 제약 조건을 직접 표현할 수 없다.

### 7.4 마스터 모델의 여러 가지 뷰

- 도메인 모델, 디자인 모델, 코드 모델은 포괄적인 모델임
    - 최소한 개념적으로 해당 주제에 관한 세부사항으로 가득 차 있다. 하지만 모든 세부사항을 기록하기란 어렵거나 불가능 함
    - 모델을 사용하여 보안, 확장성의 이유를 추론하려면 관련 요소를 명확하게 볼 수 있도록 세부 적보를 파악해야 함.
    - → 여러가지 뷰(view)로 수행 가능
- 정의
    - 투영(projection)이라고도 불림
    - 모델 세부 정보의 정의된 하위 집합을 표시하며 변형이 있을 수 있음
    - 도메인 모델, 디자인 모델, 코드 모델에서는 각각 많은 표준 뷰가 있음
    - 각 뷰는 적절한 표기법을 사용하고 단일 관심사에 초점을 맞출 수 있으므로 이해하기 쉽다.
    - 뷰를 모아보면 전체 아키텍처 모델을 구성하고 각 뷰는 전체 모델의 세부 정보 하위 집합을 제공한다.
- 뷰 일관성 (View Consistency)
    - 각 뷰(또는 다이어그램)는 해당 모델에 관한 단일 관점을 표현하여 일부 세부정보를 노출하고 나머지는 숨긴다.
    - 모델이 변경되면 뷰도 변경된다.
- 마스터 모델
    - 도메인 모델, 디자인 모델, 코드 모델은 개념적으로 각각 하나의 마스터 모델임
    - 뷰와 각 모델이 일치하지 않으면(일관되지 않으면) 버그이다.
- 마스터 모델의 예
    - 마스터 모델은 뷰가 참조하는 내용을 설명함
    - 마스터 모델이 나타내는 것에 대한 옵션이 있음
    - 이미 존재하는 시스템이 마스터 모델의 간단한 예이다.
- 크기 제한 및 주의 집중
    - 모델링에서 뷰를 사용해 다이어그램의 크기를 제한하고 주의를 집중 시켜야 한다.

### 7.5 모델을 구성하는 다른 방법

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%202.png)

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%203.png)

### 7.6 비즈니스 모델링

- 정준 모델에는 없는 모델이 비즈니스 모델
- 비즈니스 또는 조직이 하는 일과 그 일을 하는 이유를 설명한다.
- 비즈니스 모델링은 도메인 모델링과 관련이 있다.

### 7.7 UML 사용

- 통합 모델링 언어(UML) 표기법을 사용한다.

## Chapter 8 도메인 모델

- 도메인 모델은 개념 모델 또는 추상 모델이라고도 말한다.
- 도메인 모델에는 진실인 프로젝트에 관한 지식이 포함된다.
- 도메인 모델링은 설계 프로세스에 필수인 통찰력을 얻는 방법을 제공한다.

### 8.1 도메인과 아키텍처의 관계

- 도메인 모델링 반대 의견 목록과 반론
    - 이미 도메인을 알고 있다.
        - Gray 영역의 비즈니스 도메인은 잘 모르는 경우가 많다.
    - 도메인이 너무 단순하여 모델링을 방해한다.
        - 도메인은 실제 문제보다 훨씬 복잡하다.
    - 도메인은 아키텍처 선택과 관련이 없다.
        - 도메인 차이 때문에 시스템이 호환되지 않을 수 있다.
        - 도메인이 아키텍처에 영향을 주지만 아키텍처가 도메인이 숨어있는 것은 아니다.
    - 요구사항 분석은 다른 사람의 일이다.
        - 하지만 요구사항 분석하는 사람은 도메인이 어떻게 아키텍처 문제를 일으킬 수 있는지 모를 수 있다.
    - 도메인을 배우는 가장 좋은 방법은 코드를 작성하면서 점진적으로 학습하는 것이다.
        - 그것도 좋지만 어려울 수 있다.
        - 개념 증명(PoC)를 하는데도 몇주가 걸리는 경우가 있다.
    - 도메인 모델링은 끝이 정해지지 않은 분석 마비 활동이다.
        - 큰 리스크이다. 과도하지 않고 적정하게 도메인을 모델링해야 한다.
- 분석 마비 방지
    - 분석 마비를 방지하려면 수행할 도메인 모델링의 양을 제한해야 한다.
        - 모델을 만들기 전에 모델이 답할 질문을 결정해보자
        - 모델이 질문에 대한 답을 할 수 있게 되면 모델링을 중단한다
    - 실패 리스크에 관해 질문해보자
        - 사용성과 상호 운용성
    - 도메인 모델의 깊이와 폭을 결정해보자
        - 리스크를 인식하는 위치에 따라 깊거나 넓게 선택할 수 있다.
    - 분석 마비를 피하기 위해서는 도메인 모델링을 더 하더라도 추가 가치를 얻기 어려운 상황을 인식해야 한다.
    - 도메인 모델은 상태와 동작을 모두 다루므로 정보 모델, 스냅샷, 탐색, 불변 사항, 시나리오를 사용해야 한다.

### 8.2 정보 모델

- 정보 모델은 그래픽이나 표로 나타낼 수 있다.
    - 텍스트 정보 모델
        
        ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%204.png)
        
    - UML 정보모델
        
        ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%205.png)
        
- 정보 모델의 의도는 설계가 아닌 현실 세계의 일부를 설명하는 것임
- 도메인 모델링에서는 UML 모델 중 클래스, 객체, 연관, 링크, 다중성, 역할 이름만 사용해서 표현해야 한다.

### 8.3 탐색 및 불변 사항

- 정보 모델은 도메인 모델의 다른 부분에서 사용할 어휘를 제공한다.
- 불변 사항 또는 제약 조건은 항상 참이어야 하는 술부로 표현된다.
- 일부 불변사항은 이미 그래픽 모델의 다중성을 통해 표현된다.
- 정보 모델이 포함된 일반적인 문장을 사용하여 UML의 노트나 별도의 문서에 이 불변 사항을 작성할 수 있다.
- 탐색: 모델에서 연관을 가로질러 이동하는 것
- 역할: UML 정보모델의 ‘Network’ 부분. 참조하는 편리한 방법을 제공함
- 객체 제약 언어 (OCL)을 사용해 탐색을 정확하게 표현 가능하다.
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%206.png)
    

### 8.4 스냅샷

- 특정한 사례를 예로 들어야할때는 타입이 아닌 인스턴스를 보여주는 스냅샷(또는 인스턴스 다이어그램)을 그릴 수 있다.
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%207.png)
    
- 각 링크가 연관에 해당하듯이 스냅샷의 각 인스턴스는 정보 모델의 타입에 해당한다.
- 스냅샷 표기법: 텍스트에 밑줄이 쳐지고 콜론이 인스턴스 이름과 타입 이름을 구분한다.
- 스냅샷에서 허용하거나 허용하지 않을 것을 정해두면 정보 모델에서 실수를 방지할 수 있다.

### 8.5 기능 시나리오

- 시나리오: 한 스냅샷에서 다른 스냅샷으로 변경되는 방법(이벤트)을 표현
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%208.png)
    
- 시나리오의 각 단계에서 발생하는 모델 변경에 초점을 맞춰야 한다.
- 시나리오 각 단계의 전후 스냅샷을 고려하면 타입과 동작 간의 긴밀한 일치가 보장된다.

## Chapter 9 디자인 모델

### 9.1 디자인 모델

- 디자인 모델: 설계에 관한 모든 세부 사항을 포함하는 마스터 모델
- 뷰(View)
    - 선택한 세부 정보를 표시하는 모델의 투영
- 캡슐화(Encapsulation)
    - 요소의 인터페이스를 구현에서 분리함
    - 인터페이스는 경계 모델임
    - 내부 구현은 내부 모델임
    - 경계 모델과 내부 모델은 모두 동일한 내용을 설명하지만 경계 모델은 내부가 어떻게 보이는지 숨긴다.
- 중첩(Nesting)
    - 모델의 요소에는 하위 구조가 있다.
    - 결과적으로 하나의 요소는 중첩된 경계 모델과 내부 모델의 트리로 분해할 수 있다.
- 디자인 모델은 지정 관계에 의해 도메인 모델과 대응된다.

### 9.2 경계 모델

- 경계모델: 외부인이 시스템에 관해 볼 수 있는 것
    - 행위, 교환데이터, 품질 속성을 포함한다.
- 최상위 경계 모델: 디자인 모델과 시스템 및 도메인과 상호작용하는 방법을 설명하는 단일 경계 모델

### 9.3 내부 모델

- 내부 모델: 경계 모델에서 생략된 세부 사항을 보여주는 디자인 모델의 또 다른 뷰
- 경계 모델과 내부 모델을 은 구체화를 통해 서로 관련된다.
- 경계 모델에서 참인 것은 내부 모델에서 참이어야 한다.
- 경계모델과 내부 모델 모두 시나리오, 컴포넌트, 커넥터, 포트, 책임, 모듈, 클래스, 인터페이스, 환경 요소, 장단점 등과 같은 요소들로 사용되어 설명된다.

### 9.4 품질 속성

- 품질속성(QA): 시스템의 관찰 가능한 속성을 설명

### 9.5 인저 시스템 설계 살펴보기

1. 유스 케이스 및 기능 시나리오
    - 유스케이스
        
        ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%209.png)
        
        - 유스케이스 다이어그램은 기능을 잘 보여주는 시스템 개요를 설명하는데 특화됨
        - 액터와 시스템으로 표현한다.
        - 특정 예가 아니라 일반적인 기능을 설명한다.
        - 수행할 수 있는 작업을 보여주지만, 순서대로 진행하는 제약 조건을 부과하지는 않는다.
    - 시나리오
        
        ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%2010.png)
        
        - 시나리오의 각 단계는 유스케이스의 호출에 해당한다.
        - 호출 순서 등의 제약 조건을 부과 가능하다.
2. 시스템 콘텍스트
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%2011.png)
    
    - 시스템 콘텍스트 다이어그램은 다른 시스템과 상호작용하는 것에 특화됨
    - 기능이 더 잘보이고 외부시스템과 연결된 커넥터를 더 명확하게 보여준다.
    - 컴포넌트 인스턴스로 표현하는 다른 시스템에 연결된 시스템의 런타임 모습을 보여준다.
3. 컴포넌트
    - 시스템 콘텍스트 각 상자는 컴포넌트 인스턴스이다.
    - 컴포넌트: 시스템에서 실행되는 주요 계산 요소 및 데이터 저장소
    - 컴포넌트는 포트와 커넥터를 사용해 직접 또는 간접적으로 통신 가능하다.
    - 모든 포트와 커넥터를 표시해야 한다.
    - 컴포넌트 타입과 컴포넌트 인스턴스 간의 관계는 클래스와 객체간의 관계와 동일하다.
4. 포트 및 커넥터
    - 대부분 제공 포트와 필요 포트로 구분된다.
    - 포트는 둘 이상의 컴포넌트 간의 런타임 상호작용 경로인 커넥터로 연결 된다.
    - 커넥터에 프로퍼티를 부여해서 커넥터의 처리량이나 신뢰성을 결정할 수 있다.
5. 설계 결정
    - 뷰 접근 방식을 따라 중요한 설계 결정을 문서화 해라.
6. 모듈
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%2012.png)
    
    - 모듈이나 패키지로 구성할 수 있는 소스코드로 구성된다.
    - 종속성으로 대응된다.
7. 배포
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%2013.png)
    
    - 노드에 배포해야 한다.
8. 품질 속성 시나리오 및 아키텍처 드라이버
    - 품질 속성에 대한 우선순위를 정해라.
    - 품질 속성 시나리오를 작성해라.
        
        ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%2014.png)
        
    - 품질 속성 시나리오는 명백히 측정할 수 있는 품질에 적합하다.
9. 트레이드 오프
    - 하나의 품질 속성을 얻으면 어떤 품질 속성은 낮아진다.
10. 컴포넌트 조립도
    
    ![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2059c65269997f40d7bbc147a9bd971971/Untitled%2015.png)
    
    - 컴포넌트 인스턴스의 특정 구성을 보여준다.
11. 2단계 기능 시나리오
12. 책임
    - 책임을 나열하면 놓치기 쉬운 가정을 찾아준다.
13. 가이드 레일로서의 제약 조건
    - 제약조건이 없다는 말은 분석이 없다는 의미이다.
14. 아키텍처 스타일
    - 일련의 패턴으로 제약조건을 만드는 것

### 9.6 뷰타입

- 목차
    1. 뷰타입 정의
    2. 표준 아키텍처 뷰타입
    3. 서로 다른 뷰타입에서의 타입 인스턴스
    4. 뷰타입을 가르지르며 추론하기
    5. 뷰타입 결합
    6. 완전성에 관한 조언

### 9.7 동적 아키텍처 모델

### 9.8 아키텍처 기술 언어

### 9.9 마치며