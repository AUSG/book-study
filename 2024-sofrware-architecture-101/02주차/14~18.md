# 14. 이벤트 기반 아키텍처 스타일

> 특정 이벤트가 발생하면 알맞은 액션을 취함

## 토폴리지

### 1. 브로커 토폴리지

- 중재자가 없음
- 이벤트 프로세서가 디커플링
- 확장성, 응답성, 성능, 내고장성 👍
- 워크플로 제어, 에러 처리, 복구성, 재시작 능력, 데이터 일관성 👎
- 에러 처리가 힘들어 그냥 순서대로 이벤트를 생성해야함.(이벤트명 = 이미 완료된 작업)

<aside>
💡 프로듀서는 이벤트를 브로드캐스팅하고 컨슈머가 브로드캐스팅된 이벤트 채널 중 골라서 구독함으로써 신규 컨슈머가 추가될 때 기존 로직을 변경하지 않고 추가할 수 있음

</aside>

### 2. 중재자 토폴리지

- 이벤트 프로세서가 커플링됨
- 워크플로 제어, 에러 처리, 복구성, 재시작 능력, 데이터 일관성 👍
- 확장성, 성능, 내고장성, 모델 복잡 👎
- 중재할 수 있으므로 동시에 여러 작업을 수행해도 됨. (이벤트명 = 수행할 작업)

## 비동기 통신

응답성 ≠ 성능

비동기로 통신하면 에러 핸들링이 어려움 ⇒ 리액티브 아키텍처의 워크플로 이벤트 패턴으로 해결 가능

### 워크플로 이벤트 패턴

이벤트 컨슈머가 에러를 발생시키면 워크플로 프로세서가 이 에러를 받아서 핸들링하고 다시 큐에 넣어줌

이 때 순서를 보장하기 위해서 에러가 난 id와 같은 id에 접근해야하는 경우는 바로 처리하지 않고 대기 큐에 넣어두고 에러가 해결되면 큐에서 순서대로 꺼내서 작업할 수 있음

### 데이터 소실 방지

메시지를 보내는 주체가 바로 메시지를 삭제하지 않고 메시지를 가지고 있다가 컨슈머쪽에서 잘 받았습니다~ 하면 그 때 지우면 됨. EZ

## 동기 처리

### 1. 메시지 헤더의 correlation ID 사용 (권장)

프로듀서가 동기로 처리해야하는 이벤트를 큐로 보내고 대기함.

컨슈머에서 해당 이벤트의 ID를 CID 값으로 설정하여 응답 큐에 넣어줌.

프로듀서는 응답 큐에 자신이 기다리던 CID가 오면 그 때 대기를 불고 나머지 작업들 처리

### 2. 임시 큐 사용 (비권장)

프로듀서가 동기로 처리해야하는 이벤트를 보내면서 새로운 큐를 생성함.

해당 큐는 이 작업만을 위한 큐기 때문에 셀렉터는 필요 없음

근데 이러면 리소스가 많이 쓰일 수도

# 15. 공간 기반 아키텍처 스타일

> 튜플 공간에서 유래됨. 튜플 공간은 공유 메모리를 통해 통신하는 다중 병렬 프로세서를 사용하는 기술

복제된 인메모리 데이터 그리드를 활용

## 구성 요소

- 처리장치
  - 클래스
  - 인메모리 그리드
  - 데이터 복제 엔진
- 가상 미들웨어
  - 메시징 그리드 : 요청을 전달
  - 데이터 그리드 : 데이터/캐시 관리, 캐시의 일관성은 코레오그리피 혹은 처리그리드를 활용한 오케스트레이션
  - 처리 그리드 : 데이터 오케스트레이션
  - 배포 관리자 : 모니터링하며 인스턴스를 시작/종료
- 데이터 펌프 : 데이터 전달, 주로 큐
- 데이터 라이터 : 데이터를 작성
- 데이터 리더 : 데이터를 읽음. 자주 작동하지는 않음.

## 클라우드 vs 온프레미스 구현

공간 기반 아키텍처는 하이브리드로 구현할 수 있음

Q. 데이터를 온프레미스에 둠..? 그럼 DR이 너무 귀찮은 거 아님? 보통 클라우드 DB는 멀티 리전까지 해주지 않나

## 복제캐시 vs 분산캐시

- 복제 캐시 : 각각의 처리장치에 같은 캐시가 존재
- 분산 캐시 : 외부에 따로 캐시가 존재
- 니어 캐시 : 풀 백킹 캐시(분산 캐시) + 프런트 캐시(복제 캐시)
  - 프런트 캐시는 MRU(최근에 사용한 항목이 포함되는 정책) 혹은 MFU(자주 사용한 항목이 포함되는 정책) 중 하나를 보통 채용
  - 프런트 캐시에 공간이 모자라면 방출도 해야 함. 이건 랜덤일 수도 오래된 거일 수도 안 쓰는 거일 수도
  - 공간 기반 아키텍처에선 별로 추천하지 않음. 일관성이 빡셈

# 16. 오케스트레이션 기반 서비스 지향 아키텍처

## 역사와 철학

서비스 지향 아키텍처는 1990년 후반에 등장

컴퓨팅 리소스가 넉넉하지 못했고, 분산 컴퓨팅이 막 궤도에 올라 수요가 늠

많은 기업들은 가변적인 확장성 등 유용한 특성을 요구

## 택소노미

> 이 아키텍처의 핵심은 엔터프라이즈 레벨의 재사용

### 구성 요소

- 비즈니스 서비스 : 코드가 없고 스키마 정보만 가지고 있음. 진입점 역할
- 엔터프라이즈 서비스 : 재사용 가능한 구현체
- 애플리케이션 서비스 : 써드 파티 서비스..? 등 재사용을 고려하지 않은 구현체
- 인프라 서비스 : 모니터링, 로깅, 인증/인가 등
- 오케스트레이션 엔진 : 선언적으로 전체 서비스를 엮어줌

## 커플링

실제로는 재사용을 위해 추가적으로 해줘야 할 일이 너무 많았음

# 17. 마이크로 서비스 아키텍처

## 역사

마틴 파울러와 제임스 루이스의 Microservices

## 핵심

- 재사용을 할 바에는 중복이 낫다.
- 도메인을 단위로 서비스를 분리하자.
  - API 서비스는 진짜 API 요청만 받아야 한다.
  - 오케스트레이션 등은 처리하면 안된다.
  - 서비스 두 개 이상에 트랜잭션을 걸어야하는 상황이 오면 잘못됐을 확률이 높음
    - 그래도 걸어야한다면 **사가패턴**

## 운영 재사용 (사이드카)

각 서비스마다 별도의 모니터링을 붙이면 팀별로 잘 할 수 있을까?

⇒ 사이드카 패턴으로 해결

<aside>
💡 강화된 이종성
일부러 마이크로 서비스끼리 다른 언어를 쓰게 해서 중복 클래스를 사용하는 걸 방지

</aside>

<aside>
💡 소규모 팀이 무리하게 대규모 팀이 사용하던 표준을 따르면 생산성이 저하됨
⇒ 소규모팀은 너희끼리 알아서 개발해라 빠르게~
= 마이크로 서비스 아키텍처

</aside>

# 18. 최적의 아키텍처 스타일 선정

## 결정 기준

- 도메인
- 아키텍처 특성
- 데이터 아키텍처
- 조직 문제
- 팀 운영에 관한 지식
- 도메인/아키텍처 동형성
- 모놀리스 vs 분산
- 데이터를 어디에
- 서비스간 통신은 동기, 비동기

## 기타

- BFF : API 레이어를 마이크로커널 어댑터로 사용
  - 장치 확장 용이(iOS, android 등)
