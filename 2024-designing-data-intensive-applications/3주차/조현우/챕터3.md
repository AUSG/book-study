# 저장소와 검색

로그 : (append-only) 연속된 추가 전용 레코드

색인은 읽기 성능을 높여주는 대신, 쓰기 성능에 대해 트레이드오프를 지닌다.

#### 해시 색인
키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략
- ? 그림 3-1에서 바이트오프셋은 결국 키에 해당하는 부분이 시작하는 오프셋을 저장하는건데, 어떻게 키와 밸류를 구분할까?
- $ 아하! 콤마를 통해 키 밸류를 구분한다고 치자. 그러면 특정 키의 시작부분에 대해서 알고 있으면, 다른 바이트오프셋이 없는 영역까지 읽어들이거나 해서 밸류를 파악할 수 있지!

각 키의 값이 자주 갱신되는 상황에 적합

하지만 추가만 한다면 결국 디스크 공간은 부족해지기 마련
- ! 그래서 특정 크기의 세그먼트로 로그를 나누는 방식이 좋은 해결책
- ! 또한 세그먼트 파일들에 대해 컴팩션(중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것)을 시도하는 것도 가능

**추가만 하는 로그 방식 vs 새로운 값으로 덮어쓰는 방식**
- 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 무작위 쓰기보다 훨씬 빠르다
- 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구는 훨씬 간단하다.
- 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.

- @ 내가 생각했을 때, 이벤트 소싱과 같은 것을 적용한다고 했을 때 항상 추가하는 방식은 그 용량?에 대한 걱정을 했었던 것 같다. 그거에 대해서 컴팩션을 활용해보는 것도 방법일 듯하다.

##### 해시 색인의 제약사항
- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다.
- 해시 테이블은 범위 질의에 효율적이지 않다.

### SS테이블과 LSM 트리
해시테이블에서 한가지 요구사항을 추가하기
- 키 값 쌍을 키로 정렬해보기
- 이렇게 키로 정렬된 형식을 **정렬된 문자열 테이블(Sorted String Table) = SS테이블**이라고 함

##### 장점
- SS 테이블은 병합정렬 알고리즘과 유사한 방식으로 컴팩션을 수행하여, 컴팩션할때도 정렬된 형식의 병합 세그먼트 파일을 만들어낸다.
- 특정 키를 찾기 위해 코든 키의 색인을 유지할 필요가 없다. 키 간의 오프셋을 비교하여 그 사이에 있음을 유추할 수 있을테니까.

LSM(Log-Structured Merge-Tree) 트리의 기본 개념
- SS테이블에서 세그먼트를 병합하고 정렬하는 알고리즘 수행 방법
- 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것
- 블룸필터를 활용해 해당 키가 데이터베이스에 존재하지 않는 지 파악하도록 하기도 함


### B 트리
B트리는 4KB 크기의 고정 크기 **블록** 또는 **페이지**로 나누고, 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다.

한 페이지는 여러 키위 하위 페이지의 참조를 포함한다.

[B 트리를 잘 설명해주는 사이트](https://planetscale.com/blog/btrees-and-database-indexes)


### LSM 트리의 장단점

p.86 ~ 87 참고


