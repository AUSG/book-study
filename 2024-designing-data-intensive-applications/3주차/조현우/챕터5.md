# 복제

- ! 복제의 모든 어려움은 복제된 데이터의 **변경** 처리에 있으며...

복제에 있어 가장 인기있는 알고리즘 세 가지
- 단일 리더
- 다중 리더
- 리더없는

#### 리더와 팔로워

리더, 팔로워라는 개념이 존재함 (master - slave)

동기식 복제
- 팔로워의 복제가 리더의 쓰기와 하나의 트랜잭션으로 묶여있어서, 최신 데이터 복사본을 지니고 있는 게 보장됨.
- 하지만 팔로워가 장애가 난 경우, 모든 쓰기 작업이 실패

반동기식 복제
- 두 개의 팔로워가 존재하는데, 하나는 동기식, 하나는 비동기식으로 처리함.
- 동기식 팔로워가 죽을 경우, 비동기식 팔로워를 동기식으로 변경시킴
    - ? 어떻게 처리할까?
- 두 노드(리더와 하나의 동기 팔로워) 중 하나에는 최신 복사본이 있는 것을 보장함.
    - ? 이거 당연한거 아닌가? 그리고 리더에는 복사본이 아니라 원본 데이터가 있는 거 아니야?

비동기식 복제
- 리더 기반 복제는 완전 비동기식으로 구성함
- 리더가 잘못되면, 팔로워에 아직 복제되지 않은 쓰기들도 유실될 수 있음
    - ? 이렇게 됐을 때 리더가 괜찮아지면 복제되지 않은 데이터들은 어떻게 처리할까?
- 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점

#### 새로운 팔로워 설정
복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워 설정이 필요함
- ! 새로운 팔로워가 리더의 복제본을 정확히 가지고 있는 지 보장이 필요

복제 과정
1. 리더의 스냅숏을 가져옴
2. 새로운 팔로워 노드에 스냅숏을 복사함
3. 리더에 연결해 스냅숏 이후에 발생한 로그들에 대해 요청함. 이 때 스냅숏이 정확한 위치를 알고있어야 하는데, postgresql에서는 로그 일련번호, mysql에서는 이진로그 좌표라 함
4. 팔로워가 스냅숏 이후의 데이터(백로그)를 모두 처리했을 때, 따라잡았다고 표현

#### 노드 중단 처리
장애로 인해 중단될 수도 있지만, 유지보수를 위해 중단될 수도 있음. 리더 기반 복제에서 고가용성 달성을 위해서 중단된 노드에 대한 대처가 필요함.

##### 팔로워 장애: 따라잡기 복구


##### 복제로그 구현
- 구문 기반 복제
    - 간단하게 구현가능
        - insert, update, delete 문을 그대로 복제
    - 실상은 복제가 깨질 수 있는 다양한 사례가 있음
        - now() rand() 같은 비결정적 함수를 호출하는 경우
        - where 절이 있는 경우, 정확히 같은 순서로 실행되어야 하는데, 동시에 여러 트랜잭션이 수행되는 것을 제한함
        - 부수효과를 가진 구문(트리거, 스토어드 프로시저, 사용자 정의함수)이 결정적이지 않은 경우
- 쓰기 전 로그 배송
    - 실제 DB에 쓰여지기 전 별도의 로그파일로 기록하는 것
    - 로그가 저수준으로 쓰여있어서, 데이터베이스의 물리적구조에 강하게 의존함
        - `페이지 1234의 오프셋 5678에 바이트 시퀀스 추가` 와 같이 작성됨.
    - 데이터의 논리적 의미 파악이 어렵고, 유연성이 떨어짐.
    - ! 복제프로토콜 허용의 문제점
        - 복제 로직의 복잡성이 증가함. 서로 다른 버전에서 고려되어야 하는 게 당연히 생김
        - 장애 발생 시 롤백이 어려워질 수 있음
- 논리적(로우 기반) 로그 복제
    - Mysql에서 사용하는 방식으로, WAL 방식보다 고수준으로 작성되었고, 저장소 엔진 내부를 알 필요가 없기 때문에 하위호환성을 쉽게 유지할 수 있음
    - 애플리케이션에서 파싱하기가 더 쉽고, 이 덕분에 CDC를 활용하기에 좋음
- 트리거 기반 복제
    - 이전엔 데이터베이스 자체적으로 구현되었다면, 이건 애플리케이션 코드를 사용함.
    - 오버헤드가 크지만, 유연성을 잡기 위해 사용함.

##### 복제 지연 문제
- @ **쓰기 후 읽기 일관성** 보장이 필요함.
- @ 사용자가 시간이 거꾸로 흐르는 현상을 발견할 수 있다.
    - 어떤 팔로워에서는 싱크가 돼서 코멘트가 보이다가, 두번째 질의는 싱크가 덜 된 팔로워로 요청이 가서 갑자기 코멘트가 사라짐 같은 케이스
- @ 인과성의 위반 우려
    - 추후 파티셔닝에서 자세하게 설명함

**해결책**
- 자신이 쓴 내용 읽기
    - usecase를 분석해서 리더에서 읽는 경우를 따로 빼기
    - 마지막 갱신 시각을 찾아서 마지막 갱신후 1분 동안은 리더에서 모든 읽기를 수행하도록 하기
        - 이 방식은 따로 마지막 갱신 시각을 어딘가에 기록할 필요가 있음
        - 로컬 캐시를 달아서, 어떤 엔티티의 id에 대해서는 마지막 갱신이 언제인지 판단할 수도 있긴 하겠다.
        - 클라에서 질의를 대기시키게 하기
- 단조 읽기
    - 강한 일관성보다는 덜한 보장, 최종적 일관성보다는 더 강한 보장 방식
    - 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것
        - 이게 단순히 데이터베이스만 따질 게 아니라 경우에 따라 애플리케이션 서버까지 고려해야할 수도 있을 듯


#### 다중 리더복제
- ! 협업 편집 문제
- 쓰기 충돌 문제

#### 리더없는 복제
- Cassandra(카산드라) 가 이렇다고 함. 추후에 사용하게 되면 이 점을 잘알고 사용해야 할 듯
