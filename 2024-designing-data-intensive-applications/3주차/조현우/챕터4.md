# 부호화와 발전


### 형식
JSON, XML, 이진부호화

부호화에 있어 조직 내에서만 사용하는 지 조직 바깥까지 사용하는 지에 대해 설명하는 게 흥미로웠음.
조직 외부에선 그래도 사람이 읽기 쉬운 형태를 쓰게 되는 편이고, 조직 내부에선 좀 더 파싱이 빠른 형식을 사용하게 되는(=성능이 뛰어난) 경향이 있는 듯함. 그 이유는 설득이 쉬워서.

이진부호화 라이브러리
- Apache Thrift
- Protocol Bufferes

##### 필드 태그와 스키마 발전

이진부호화에서는 필드를 이름으로 구별하는 게 아닌 숫자(=필드 태그)를 사용하고 있어서, 부호화할 때 데이터 해석에 중요하다. 필드 이름을 전혀 참조하고 있지 않아서, 스키마에서 이름 변경은 가능하다.

필드를 추가하기 위해선 상위 호환성과 하위 호환성을 고려하는 게 중요하다.
상위 호환성(예전 코드가 새로운 데이터를 읽는 능력)은 예전 코드가 인식할 수 없는 태그에 대해선 무시하도록 처리하고 있어서 해결 가능하다.
하위 호환성(새로운 코드가 예전 데이터를 읽는 능력)은 새로운 필드를 optional로 추가하거나, 기본 값을 갖도록 한다.

필드 삭제 방식은 역으로 접근하면 된다.

##### 데이터 타입과 스키마 발전
데이터 타입을 변경하는 건 위험하다.

#### 쓰기 스키마와 읽기 스키마
아브로는 필드 태그가 존재하지 않으며, 읽기 스키마와 쓰기 스키마가 동일하지 않더라도 호환 가능하면 된다는 아이디어에서 출발한다. 데이터를 읽을 때 아브로 라이브러리는 쓰기 스키마와 읽기 스키마를 함께 살펴본 다음 쓰기 스키마에서 읽기 스키마로 데이터를 변환해 그 차이를 해소한다.

그러면 쓰기 스키마를 어떻게 알 수 있을까? 쓰기 스키마를 매번 데이터에 같이 쓰는건 데이터 절약의 의미가 사라진다.
- 많은 레코드가 있는 대용량 파일
    - 쓰기 스키마를 포함시켜서 데이터를 쓴다. 많은 레코드가 동일한 스키마로 작성된 것일테니, 쓰기 스키마를 같이 보내는 게 이득이다.
- 개별적으로 기록된 레코드를 가진 데이터베이스
    - 데이터베이스에는 다양한 쓰기 스키마를 가졌을 수 있다. 이 경우 버전번호를 포함하고 데이터베이스에 스키마 버전 목록을 유지하도록 하는 것이다.
- 네트워크 연결을 통해 레코드 보내기
    - 두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전 합의를 할 수 있다. 이후 연결을 유지하는 동안 합의된 스키마를 사용한다.

#### 동적 생성 스키마
아브로는 관계형 스키마로부터 아브로 스키마를 상당히 쉽게 생성할 수 잇다. 각 데이터베이스 테이블에 맞게 레코드 스키마를 생성하고 각 칼럼은 해당 레코드의 필드가 된다. 데이터베이스의 칼럼 이름은 아브로의 필드 이름에 매핑된다.

데이터베이스 스키마가 변경되면, 갱신된 데이터베이스 스키마로부터 새로운 아브로 스키마를 생성하고 새로운 아브로 스키마로 데이터를 내보내도록 한다.

- @ 지금 brand_branch 테이블에 직접 접근해서 읽고 있는데, 그러면 lp팀에선 해당 테이블의 컬럼에 대해 쉽게 변경할 수 없게되고, poi 입장에서도 강결합되는구나. 좀 더 공부해봐야겠지만, 이런 상황을 해결할 수 있는 실마리를 얻음


#### 스키마의 장점
- 스키마 언어는 JSON 보다 더 간단하며 더 자세한 유효성 검사 규칙을 지원한다.
- 스키마 발전에 있어 스키마리스 또는 읽기 스키마 JSON 데이터베이스가 제공하는 것과 동일한 종류의 유연성을 제공하며, 도구 지원도 더 잘 보장한다.

#### 데이터플로 모드
발전성은 한 번에 모든 것을 변경할 필요 없이 시스템의 다양한 부분을 독립적으로 업그레이드해 변경 사항을 쉽게 반영하는 능력이다. 호환성은 데이터를 부호화하는 하나의 프로세스와 그것을 복호화하는 다른 프로세스 간의 관계다.

호환성을 지키면서 데이터를 전달하는 방법에 대해 알아보자.

##### 데이터베이스를 통한 데이터 플로
데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 데이터베이스에서 읽는 프로세스는 데이터를 복호화한다.

데이터베이스에 데이터를 쓰는 읽은 `미래의 자신에게 메시지를 보내는 일`처럼 생각할 수도 있다.

- ! 새로운 버전의 애플리케이션이 기록한 데이터를 예전 버전의 애플리케이션이 갱신하는 경우 주의하지 않으면 데이터가 유실될 수 있다. (p.133 그림 참고 - 하나의 row 전체를 업데이트하는 경우 발생할 수 있음)



#### 서비스를 통한 데이터플로: REST와 RPC

클라이언트와 서버간의 데이터 부호화는 서비스 AAPI의 버전 간 호환이 가능해야 한다.

##### RPC의 문제

RPC모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 ㅔ서드를 호출하는 것과 동일하게 사용가능하게 해준다(이런 추상화를 `위치 투명성` 이라고 한다.)

이러한 아이디어는 좋아보이지만, 근본적으로 로컬 함수호출과 네트워크 호출은 다르기 때문에, 이러한 접근법은 좋지 못하다. (네트워크 호출의 불안정성을 가정하고 설계되어 있지 않다는 이야기)

하지만 차세대 RPC 프레임워크는 이러한 사실을 분명히하고 있따. 실패할지도 모르는 작업을 위한 대비책이 설계에 녹아있다.

#### 메시지전달 데이터플로

비동기 메시지 전달 시스템, 메시지 브로커

#### 분산 액터 프레임워크

- ? 액터 모델이 무엇인지 감이 잘 안옴...

액터 모델은 단일 프로세스 안에서도 메시지가 유실될 수 있다고 이미 가정하기 때문에 위치 투명성은 RPC보다 액터 모델에서 더 잘 동작한다.

[액터 모델에 대한 설명](https://pegasuskim.wordpress.com/2015/12/23/actor-model-%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC/)