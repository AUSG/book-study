# 4. 맛있는 테스트

-   수동 테스트, 자동 테스트 => 평소에 하는 것
-   프로덕션 환경에서의 테스트를 통해 위험을 감수하라
    -   빨리 움직이고 무언가 깨뜨려라
-   테스트 프레임워크와 매개변수화된 테스트를 하라

-   자신의 이득을 위해 테스트를 작성하기



# 5. 보람 있는 리팩터링

-   리팩터링을 통해 코드 재사용성 증가, 유지보수, 아키텍쳐 변경등을 이루어 낼 수 있다.
-   아키텍처 변경시에는, 구성 요소를 식별하고 작업량과 위험도를 추정해야한다. ( 로드맵 갖기 )
-   DI등을 활용하여 경직도를 줄이자
-   리팩터링 전에는 테스트 코드를 작성
-   득보다 실이 클 때는 리팩터링 x



# 6. 조사를 통한 보안

-   보안을 염두에 두고 설계
-   입력 값 믿지 않기
-   암호를 별도의 암호 저장소에 저장
-   이미 나와있는 솔루션등은 그것을 사용하라 ( 암호화, 캐시 등 )



# 7. 자기 주장이 뚜렷한 최적화

-   섣부른 최적화는 모든 학습의 근원이다
    -   하지만, 코드에 경직성을 가져야 유지보수가 어려워질 수 있다는 것을 항상 생각하라
-   올바른 문제를 해결하라
    -   벤치마킹 하기
    -   성능과 응답성은 항상 비례하지 않는다
-   중첩루프, 문자열이 많은 코드, 비효율적인 불리언 평가식을 피하라
-   데이터 구조시 메모리 정렬 고민
-   I/O 성능을 늘리거나 비동기 혹은 캐시를 도입하라



# 8. 기분 좋은 확장성

-   확장성을 방해하는 잘못된 코드를 제거하는 것이 확장할 수 있는 코드를 만드는 첫번째 시작이다

-   lock이 필요한지 고민하기
-   불일치를 수용하기 
    -   결과적 일관성을 고려하라
-   I/O를 비동기 I/O로 변경하는 것을 고려하여 스레드를 보존하고 CPU 사용량을 최적화하라
-   비동기 프로그래밍과 멀티스레드를 같이 사용할 때 비동기 I/O를 통한 확장성의 이점을 기대하지 마라
-   MSA가 섣부른 판단인지 고민. 모놀리스가 나을 수도 있음



# 9. 버그와의 동거

-   버그의 우선순위를 고민하라
    -   적용 가능성, 영향, 심각성과 같은 지표로 주장을 입증하라
-   우선순위와 심각성에 대한 임계값을 설정하여 그 임계값에 따라 고치지 않도록 해야 한다
    -   우선순위 => 비즈니스에 끼치는 영향
    -   심각성 => 사용자에게 끼치는 영향
-   오류에 대한 두려움
    -   예외 처리에 대한 첫번째 규칙은 예외를 잡아내지 않는 것이다.
    -   잡아야하는 예외만 처리하고 나머지는 냅두자. => 추후 고치기
-   예외 복원성
    -   충돌을 사후에 방지하는 대신 먼저 충돌을 견딜 수 있는 예외를 작성하라
    -   예외 복원성은 멱등성이 가장 중요. 트랜잭션도 같은 맥락에서 도움이됨.
-   프레임워크에서 제공하는 추적기능이나 충돌 덤프를 사용하라
-   고무 오리 디버깅을 해보자
