## 6장 - 조사를 통한 보안

- 사후공개 : 보안 사고가 터진 후 공개하는 것
- 책임공개 : 보안 문제를 해결할 시간을 충분히 제공한 뒤 취약점을 공개하는 방식
- 해커가 아니여도 보안 취약점을 통해 악의적으로 사용이 가능하다
- 위협 모델링해라
- 웹 앱을 안전하게 작성하라
    - 보안을 염두해두고, 권한, 암호화을 면밀이 설계해서 조직에 전체적으로 적용해라
    - 자신만의 보안 (알고리즘)을 구현하지 말라
    - SQL Injection // 백업도 중요하게 여기자
        - 매개변수화된 쿼리를 이용하면 쿼리 플랜 캐시도 잘 이용할 수 있고, 안전하다.
        - 단 상수는 불필요하게 매개변수화 할 필요는 없다.
        - 패턴 매칭의 경우 매개변수화가 불가능하다.
- flooding attack을 어떻게 막을까?
    - 캡차를 쓰지 말고 cloudflare의 bot detection solution을 이용하는게 훨씬 낫다 - UX적으로 캡차가 훨씬 구리기 때문
    - 하지만 특정 IP를 차단하면 해당 IP 내의 모든 사용자가 차단되므로 캡차를 대안으로 사용할 수도 있다. 요건 적절한 수준의 rate limit을 이용하면 괜찮지 않을까?
    - 캐시를 쓰지 말라! 해시 충돌을 이용하는 방식으로 사용자가 공격할 수도 있다.  (??)
        - 오래된 항목을 (LRU, LFU등) 제거할 수 있는 방법이 있어야한다.
        - 캐시 인프라가 있으면 그것을 써라
- 암호를 어떻게 저장할까?
    - 서비스를 운용하는데 필요한 사용자 비빌번호가 아닌 개인용키, API키들은 어떻게 관리하는게 좋을까?
        - KeyVault와 같은 키 관리 솔루션을 쓰는 것이 좋다.
        - 소스코드에는 저장하지 말라
    - 사용자 비밀번호는 어떻게 저장할까?
        - 단 1회만 돌린 해쉬 알고리즘은 절대 사용하지 말라
        - PBKDF2는 GPU나 ASIC에 의해 크랙될 수 있다
        - 위에 내성이 있는 ARGON2를 이용해라!
    - 문자열비교?
        - 항상 일정한 시간이 걸리도록 비교해라
        - 순차적으로 비교해서 결과를 반환하면 해커가 브루트 포싱을 더 효율적으로 할 수 있게 하는 힌트가 된다.
        - N개의 ASCII 문자가 2^n8 이 아니라 N * 2^8이 될 수도 있다.
    - 고정될 솔트를 이용하지 마라
    - 안전한 랜덤을 사용해라
    - UUID는 랜덤이 아니다
        - mac / timestamp 등을 이용해서 생성되어 충분히 무작위적으로 볼 수 있으나, 완전하지는 않다. CSPRNG를 통해 생성된 것이 아니기 때문에
        - 인덱스 분포 측면에서도 좋지않다. 관련 없는 위치에 삽입되기 때문 - ULID, UUIDv6(over)등과 같이 timestamp가 포함되어있는 녀석을 이용해라
        -