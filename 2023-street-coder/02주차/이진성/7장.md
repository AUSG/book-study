## 7장 - 자기 주장이 뚜렷한 최적화

> 섣부른 최적화는 모든 악의 근원이다 - 도널스 커누스
> 
- 원인은 나쁜 객체 지향 프로그래밍 설계에 의해 발생한다
- 실제로는 “우리는 작은 효율성을 잊어야 한다. 97%의 경우에 말이다. 섣부른 최적화는 모든 악의 근원이다. 그러나 중요한 3%의 기회를 놓쳐서는 안 된다”에 가깝다

섣부른 최적화는 모든 학습의 근원이다. 다만 동시에 최적화된 코드는 기능의 변경하게 어렵게 해 유지보수를 어렵게 한다.

### 1. 올바른 문제를 해결하라

- 단순한 벤치마킹 - 벤치마크 도구 등을 이용해서 테스트 하는 방법’
- 성능 vs 응답성 - 성능은 상대적이지만 응답성에 대해서 유저가 느끼는 감상은 일반적으로 절대적이다.

### 2. 완만함의 분석

- ???

### 3. 최고부터 시작하라

- 필요없는 코드를 완전히 삭제하자
- 회상의 방법으로 문제를 해결하고 더 깊이 조사하는 것 만큼 좋은 것은 없다.
    - 하향식 접근법으로 문제의 원인이 되는 지점을 파악하라
- 중첩 루프를 제거하자
- 문자열 지향 프로그래밍을 지양하자
- 논리 검사는 우선순위에 따라 호출하자
    - 변수 → 필드 → 속성 → 메서드 호출 순서로 호출 비용이 비싸다

### 4. 병목현상 깨트리기

- 최적화를 위해 데이터를 패킹하면 패킹하지 못한 것보다 접근 속도가 느려 오히려 read operation이 많은 작업에서는 비효율적일 수 있다.
- 근접성(지역성)을 활용하라
- 예측 될 수 있도록 분기 코드를 작성하라
- SIMD = Single Instruction Multiple Data : 여러데이터를 하나로 담아서 연산하기

### 5. 1초와 0초의 I/O

- I/O 속도를 향상시키기 위해서 버퍼를 사용해라
- non blocking으로 만들자
    - callback → async/await 로 변화했다.

### 6. 다른 모든 것이 실패하면 캐시를 이용해라

- 무효화 걱정이 없는 데이터가 있다면 인메모리 캐시를 이용해라
- 만료가 없는 캐시는 사용하면 안된다