# 4. 테스트

## TDD

코드를 쓰기 전에 테스트에 집중하면 테스트를 잘 작성하기 위한 방법을 생각하게 됨.

프로덕션 코드 자체가 아니라 테스트 프레임워크의 구문요소, 테스트 구성에 더 많은 시간 할애.

⇒ 매몰 비용의 오류가 발생

> 테스트는 작성하기 쉬운 코드여야 한다. 그렇지 않다면 문제가 있는 것이다.

## 테스트는 나를 위함이다.

버그를 쉽게 잡을 수 있고 코드의 변화로 인한 버그도 줄일 수 있다.

## 테스트 코드를 작성할 때 주의할 점

### 경계를 주의하라

매개변수 테스트를 사용하여 테스트코드의 반복작성을 줄이고 테스트할 대상에 집중

### 코드 커버리지

> **테스트 코드가 프로덕션 코드를 얼마나 실행했는지를 백분율로 나타내는 지표**

코드커버리지 100%…? 기준이 뭔가요

코드커버리지 100%가 100% 테스트 적용 범위를 의미하는 것은 아니다.

## 파레토 법칙

> **80:20 법칙** : 결과의 80%가 20%의 원인에서 나온다.

핫 패스(자주 사용되거나 자주 변경되어 버그가 발생할 확률이 높은 부분)에 대한 테스트 위주로 작성하자.

## 컴파일러가 테스트하도록 하라

### 널 검사 제거

### 범위 점검 제거

### 유효값을 확인하는 로직에서 중복을 제거

# 5. 리팩터링

<aside>
🔍 리팩토링을 하는 이유
- 반복을 줄이고 코드 재사용 증진
- 내 사고와 코드를 더 가깝게
- 가독성과 유지보수가 쉽게
- 버그가 발생하지 않도록
- 중요한 아키텍쳐 변화를 준비
- 경직된 부분 제거

</aside>

## 종속성 주입

인터페이스를 통해 공통코드를 사용할 수 있다.

## 마지막 코스

여러 개발자가 서로 다른 파트를 작업하다가 마지막 코스에서는 결국 어느정도 충돌 위험을 감수하고 코드를 합쳐야 한다. 리팩토링은 이 과정을 쉽게 해준다.

## 주의할 점

리팩토링을 하는 이유가 ‘코드를 우아하게 만드려고’라면 위험함. 우아하다는 주관적이고 모호하고 의미없음. `코드를 사용하기 쉽게 만드려고`, `코드의 라이브러리 이동`, `구성요소 X에 대한 의존성 제거` 등 합리적인 이유가 있어야 함.

테스트가 부족하고 구성 요소에 너무 많은 종속성이 있는 경우, 리팩토링을 피하자. **테스트가 부족하다는 것은 자신이 하고 있는 일을 모른다는 의미**일 수 있다.

팀원과 함께 사용하는 파트라면 리팩토링을 미루는 것을 고려하자.

# 6. 보안

### 위협 모델링

> `위협 모델링 = 리스크 인식` 이라고 생각하면 이해가 빠를 듯 하다.

위협 모델링은 시스템의 취약점을 파악하고, 위협에 대응하는 방법을 계획하는 프로세스

위협 모델링을 통해 보안 리스크를 더 잘 이해하고, 우선 순위를 정할 수 있음

## 📌은둔 보안은 안돼

은둔 보안은 숨기는 것이다.

숨기는 것만으로 충분하다고 생각하면 안된다. HTTP가 대표적인 예시다. HTTP는 단순히 비밀번호를 base64 인코딩을 통해 해쉬화하여 전달했다. 이는 읽기 어렵기만 하지 암호화가 아니다.

오늘날은 TLS, OAuth2같은 안전한 인증 프로토콜이 나오고 있다.

## 📌트레이드오프

### 사용자 경험과 보안 사이의 트레이드오프

사용자경험이 좋은 텔레그램, 보안이 좋은 왓츠앱. ⇒ 난 텔레그램밖에 모른다. 그만큼 사용자 경험도 무시해선 안됨.

### 비용과 보안 사이의 트레이드오프

오늘날 보안을 위한 비용이 저렴해지고 있다. 또 숨기는 것이 문제를 해결할 시간 정도는 벌어줄 수 있다.

## 📌SQL 문제

### 삽입에 취약한 부분에 대한 문제 해결

이스케이핑(특수한 문자들도 무조건 문자로만 취급되게 하기)

매개변수화된 쿼리를 사용

## 📌XSS 방지

> XSS는 SQL삽입과 비슷하다. SQL문이 아니라 HTML문을 조작

이스케이핑을 통해 해결

CSP(content security policy) : 서드파티 서버가 요청할 수 있는 리소스를 데한하는 HTTP 헤더. ⇒ 허나 오늘날 수많은 외부 리소스가 포함되기때문에 사용하기 쉽지 않음

## 📌CSRF, XSRF

> CSRF, XSRF란 크로스 사이트 요청 위조이다.

모든 폼을 위해 랜덤한 번호를 생성하고 폼 자체와 웹 사이트 응답 헤더 양쪽에 번호를 복제. 수상한 웹 사이트는 번호를 알 수 없고 웹 서버 응답 헤더를 조작할 수 없기 때문에 공격이 힘들다.

## 📌캡차를 사용하지 마라

> 클라우드플레어의 “공격자인지 아닌지 결정할 때까지 5초 동안 기다려 주십시오” 라는 페이지에서 방문자의 53%가 페이지를 떠난다고 한다.

캡차를 쓰면 UX가 심히 불편해진다.

### 해결법

스로틀링?

PoW

회원가입-로그인

## 📌캐시를 구현하지 마라

제공하는 캐시를 쓰자. 내가 만든 임의의 자료구조 캐싱은 타임아웃이 없고 무한히 커질 수 있다.

## 📌 암호 저장하기

### 올바른 스토리지에 보관하자.

### 데이터는 언젠가 유출된다.

- 필요 없는 데이터는 수집하지 말자 최대한 수집하지 말자 그냥

### 올바른 비밀번호 해싱 방법

암호화 함수를 한 번만 돌리는 방법은 절대 안됨.

루프로 돌려야함. 예를 들면 `PBKDF2` ⇒ 근데 이것도 GPU에서 병렬로 돼서 별로라네.

### 문자열을 안전하게 비교하라

문자열을 비교할 때 불일치하는 값을 발견해도 미리 반환하지마라 ⇒ 해커한테 도움만 됨

⇒ 항상 일정한 시간이 걸리는 비교함수가 필요함.

🚨 for문으로 배열을 반복하여 비교중이라면 break나 return으로 끝내는 게 아니라 `success = success && (비교 함수)` 등으로 계속 문자열을 둘러보게 해라. 🚨

### 고정된 솔트를 사용하지 마라

정규 의사 난수 값이 아닌 **암호학적으로 안전안 의사난수 생성기에서 사용된 값을 사용**해라

### 랜덤

- 간단한 랜덤 알고리즘은 빠르지만 안전하지 않음
- 예측하기 어려운 안전한 의사 난수가 필요함. ⇒ 느리므로 보안에서만 사용하도록 하자

### UUID

- UUID는 완전랜덤은 아니지만 단조 증가 정수보다는 안전
- 균일한 인덱스 분포를 위해 타임스탬프를 포함하는 UUID들이 있음.

# 7. 자기주장이 뚜렷한 최적화

## 📌병목 현상 탐지

- 하향식 접근법 : 전체 프로그램의 성능을 분석하고 가장 오래 걸리는 부분부터 최적화해야 함

## 📌코드 최적화

- 불필요한 코드 제거 : 불필요한 로직이나 반복문을 제거하여 성능을 향상
- 중첩 루프 최적화 : 중첩 루프는 O(n^2)의 복잡도를 가질 수 있으므로, 가능한 제거하거나 최적화
- 자료형 활용 : 특정 연산에 가장 적합한 자료형을 사용(예: 정수 연산은 실수 연산보다 빠름)
- 문자열 최적화 : 문자열 연산은 비용이 많이 들 수 있으므로, 불필요한 문자열 연산을 최적화
- 조건문 최적화 : 가장 많이 계산되는 조건문을 앞으로 배치하여 불필요한 조건은 제거

## 📌메모리 최적화

- 데이터 패킹 피하기 : CPU는 정렬된 메모리 주소에서 데이터를 더 빠르게 읽음 ⇒ 데이터를 정렬된 형태로 저장하도록 노력하기
- 근접성 활용 : 메모리 캐시는 근접한 메모리 주소의 데이터를 빠르게 읽음 ⇒ 가능한 한 연속된 메모리 주소에 데이터를 저장하려고 노력하기

## 📌병렬 처리 및 예측 최적화

- SIMD : 일부 CPU는 동시에 여러 데이터 연산을 지원 ⇒ 이러한 연산을 활용하여 성능 향상
- 분기 예측 최적화 : CPU는 분기 예측을 사용하여 더 빠르게 코드를 실행. 코드를 작성할 때 이를 고려하면 성능이 향상

## 📌I/O 최적화

- 적절한 버퍼 크기 선택 : I/O 작업의 성능을 향상시키기 위해 적절한 크기의 버퍼를 선택
- 비동기 I/O 사용 : I/O 작업을 비동기로 처리하여 성능을 향상

## 📌캐싱 활용

- 데이터 캐싱 : 자주 사용되는 데이터는 캐시에 저장하여 빠르게 액세스
- 적절한 캐싱 도구 선택 잘 하기.

# 8. 기분좋은 확장성

성능만으로는 시스템 확장 불가능

초창기 기술 결정은 장기적 성능에 큰 영향X

확장성을 방해하는 잘못된 코드 제거하는 것은 중요

## 잠금의 문제

- 잠금은 데이터 일관성ㅇ르 보장하지만 확장성에 문제가 될 수도
- 필요한 곳에서만 잠금을 사용하고 가능한 경우 잠금이 필요없는 알고리즘이나 데이터 구조를 찾아야 함.
  (`Concurrent`, `Immutable`등)

## 불일치의 수용

- 성능과 확장성 향상을 위해 일정 수준의 데이터 불일치는 허용될 수 있음
- NoSQL의 철학 : 일관성 < 성능,확장성

## 데이터 베이스 연결 관리

- **데이터베이스 연결을 무분별하게 캐시하지 말 것**
- 각 쿼리의 수명 동안만 데이터베이스 연결 활성화

## 스레드 사용의 주의

- 스레드 사용이 확장성을 항상 향상시키는 것은 아님
- 필요 이상의 스레드 사용은 오히려 성능 저하를 가져옴
- 비동기 I/O 사용을 통해 효율적으로 리소스 활용

## 모놀리식 존중하기

- MSA는 복잡성이 증가
- 초기 단계에서는 모놀리식 아키텍처를 선호하고 후에 MSA를 도입하자

# 9. 버그와의 동거

## 모든 버그를 수정하지 마라

> 완벽한 프로그램을 만드는 것은 불가능하다. 프로그래밍 초기 단계에서 이 사실을 인식하고 받아들이자.

### 버그 우선순위

- 버그는 중요도에 따라 처리해야 함. 모든 버그를 수정하려는 시도는 리소스 낭비
- 버그의 우선순위를 평가하는 가장 중요한 것은 “영향력”과 “심각성”

## 예외 처리

- 모든 오류가 버그는 아님. 모든 버그도 오류는 아님.
- 예외를 캐치할 때 예외를 무시하거나 숨기면 안됨
- 예외 복원성 : 코드는 예외가 발생하더라도 계속해서 안정적으로 실행되도록 설계되어야 함
- 일반적이거나 예상되는 오류는 반환코드는 enum을 사용하여 처리하자

## 디버깅

- 디버거는 유용한 도구지만 항상 최선은 아님. 때로는 print가 나을 수도
- 고무오리 디버깅…..? 문제를 다른 사람이나 물체에게 설명하면서 해결책을 찾아내는 방법이란다.
