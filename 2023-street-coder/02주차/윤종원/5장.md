- [5장. 보람 있는 리팩터링](#5---)
    - [5.1 우리는 왜 리팩터링을 하는가?](#51----)
    - [5.2 아키텍처 변경](#52--)
        - [5.2.1 구성 요소를 식별하라](#521---)
        - [5.2.2 작업량과 위험도를 추정하라](#522---)
        - [5.2.3 평판](#523-)
        - [5.2.4 더 쉽게 리팩터링되도록 리팩터링하라](#524----)
            - [종속성 주입](#-)
        - [5.2.5 마지막 코스](#525--)
    - [5.3 신뢰할 만한 리팩터링](#53---)
    - [5.4 리팩터링을 하지 않는 경우](#54----)
    - [5.5 요약](#55-)

# 5장. 보람 있는 리팩터링

- 훌륭한 코드를 작성하는 것은 보통 효율적인 개발자가 되기 위한 조건의 절반 정도에 불과하다.
- 나머지 절반은 코드 변화에 기민하게 대응하는 것이다.

## 5.1 우리는 왜 리팩터링을 하는가?

- 변화는 피할 수 없다.
- 리팩터링으로 다음을 할 수 있다
    - 반복을 줄이고 코드 재사용을 증가시킨다
    - 정신 모델과 코드를 더 가깝게 한다
    - 코드를 더 이해하기 쉽고 유지관리하기 쉽도록 만든다
    - 특정 클래스에 버그가 발생하지 않도록 한다
    - 중요한 아키텍처 변화를 준비할 수 있다
    - 코드의 경직된 부분을 없앨 수 있다


- 리팩터링은 코드를 작성하지 않더라도 별도의 외부 작업으로 생각해야 한다
    - 리팩터링이 반드시 프로그래밍 작업의 일부는 아니며, 리팩터링을 통해 코드를 파악하는 것도 가능하다

## 5.2 아키텍처 변경

- 한 번에 큰 아키텍처 변경을 수행하는 것은 결코 좋은 생각이 아니다
- 큰 변화는 수많은 버그와 통합 문제를 발생시키기 때문이다
    - 팀원과의 코드 충돌도 많아진다
- 리팩터링은 점진적으로 하는 것이 더 낫다


- 로드맵을 만들려면 목적지가 있어야 하며, 우리의 현재 위치를 알아야 한다.
- 목적지로 향하는 동안, 현재 우리가 어디에 있는지 알아야 한다.

### 5.2.1 구성 요소를 식별하라

- 대규모 리팩터링을 하는 가장 좋은 방법은 코드를 의미론적으로 다른 구성 요소로 나누는 것이다.
- 그 뒤에 구성 요소 몇 개를 최종 목적지로 보낼 수 있는지에 대한 평가를 시작한다

### 5.2.2 작업량과 위험도를 추정하라

- 최종 목적지를 향한 걸음을 떼기 전에 목적지를 아는 것이 중요하다
- 가능한 한 오랜 시간 동안 어떤 것도 깨뜨리지 않고 업무량을 줄이기 위한 작업의 우선순위를 지정하기 위함이다.
- 다른 사람의 작업 흐름을 중단하지 않고 최대한 빨리 작업을 워크플로에 통합할 수 있는 방법을 찾아야 한다


- 리팩터링할 때는 변경할 필요가 없다

### 5.2.3 평판

- 동료를 방해하지 않고 리팩터링을 하는 것은 고속도로에서 운전하면서 동시에 자동차 타이어를 교체하는 것과 거의 비슷하다.


- 새로운 프로젝트를 만들고, 그에 대한 참조를 추가시키는 방법으로 작업하면 메인 브랜치를 최대한 최신 상태로 유지하면서 리팩터링을 진행할 수 있다
- 또한 리팩터링 작업을 수행하면서 동시에 다른 더 긴급한 작업을 일정에 끼워 넣을 수 있다.

### 5.2.4 더 쉽게 리팩터링되도록 리팩터링하라

- 합성을 사용하면 인터페이스를 실제 종속성 대신 구현체에 전달할 수 있다.
- 즉, 리팩터링 중 큰 종속성이 있는 경우엔 합성을 사용하라

#### 종속성 주입

- 다루고 싶지 않은 종속성을 추상화해 버릴 수 있다.

### 5.2.5 마지막 코스

- 언젠간 기존 프로젝트와 새로운 프로젝트 사이에서 공유할 수 없는 코드를 만나게 된다
- 이에 대한 이론적인 해결책은 있지만 이를 구현하기에는 일이 너무 많다
- 문제에 대한 우아한 해결책을 생각해냈다면, 그럴 가치가 있는지 항상 따져봐야 한다.


- 즉, 어떤 시점이 되면 다른 개발자와의 충돌 위험을 감수하고 그 코드를 새로운 코드 베이스로 보내야만 한다.

## 5.3 신뢰할 만한 리팩터링

- IDE를 사용하면 쉽게 리팩터링 할 수 잇지만 안정성이 항상 보장되는 것은 아니다.
- 컴파일러도 모르게 특정한 이름을 참조할 수 있는 여러 가지 방법이 있다.


- 신뢰할 수 있는 리팩터링의 비결은 테스트다.
- 장기 리팩터링 프로젝트를 시작하기 전에 코드에 대해 누락된 테스트가 있다면 이를 먼저 만드는 것이 좋다.

## 5.4 리팩터링을 하지 않는 경우

- 리팩터링의 좋은 점은 코드를 개선할 방법을 생각하게 한다는 것이다.
- 단, 리팩터링은 수단이 되어야지 목적이 되어서는 안 된다.


- 리팩터링에 중독되면 변경을 위한 변경을 할 뿐 이를 통해 얻는 이득은 고려하지 않는다.
- 이는 결국 시간 낭비일 뿐만 아니라 리팩터링에 의한 변화에 적응해야 하는 팀원의 시간까지 낭비하는 것이다.


- 따라서 리팩터링을 할 때 다음을 고려하자
    - 리팩터링하는 이유가 "우아함"이라면 커다란 위험 신호다
        - 이는 주관적이고 모호하고 의미가 없다
        - 확실한 리팩터링 이유가 있을 때만 리팩터링을 하자
    - 대상의 구성 요소가 최소한의 구성 요소 집합에 의존한다면 나중에 쉽게 이동하거나 리팩터링 할 수 있으므로 확실한 개선 방안이 떠오르기 전까지 미루는 것이 좋다
    - 테스트 범위가 부족하거나, 너무 많은 종속성이 있다면 자신이 하고 있는 일을 잘 모른다는 신호이므로 리팩터링을 멈추는 것이 좋다
    - 공통적인 의존 관계의 코드라면 이를 리팩터링 했을 때 팀원의 작업 흐름을 방해할 수 있으므로 이러한 비용보다 이득이 커질 때까지 미루는 것을 고려해야 한다.

## 5.5 요약

- 생각보다 리팩터링에는 장점이 많으므로 적극적으로 사용하라
- 대규모 리팩터링 작업에서 발생할 수 있는 잠재적인 문제를 줄이기 위해 테스트를 사용하ㅏㄹ
- 비용뿐만 아니라 위험도 추정하라
- 대규모 아키텍처 수정을 할 때는 로드맵이 있어야 한다
- 득보다 실이 더 클 때는 리팩터링하지 않거나 뒤로 미루는 것을 고려하라

