- [6장. 조사를 통한 보안](#6---)
    - [6.1 해커를 넘어서](#61--)
    - [6.2 위협 모델링](#62--)
        - [6.2.1 주머니에 들어갈 만큼 작은 위협 모델](#621------)
    - [6.3 웹 앱을 안전하게 작성하라](#63----)
        - [6.3.1 보안을 염두에 두고 설계하라](#631----)
        - [6.3.2 은둔 보안 방식의 유용성](#632----)
        - [6.3.3 자신만의 보안을 구현하지 마라](#633----)
        - [6.3.4 SQL 삽입 공격](#634-sql--)
            - [SQL 삽입에 대한 잘못된 해결 방안](#sql-----)
            - [SQL 삽입에 대한 이상적인 해결 방안](#sql-----)
            - [매개변수화된 쿼리를 사용할 수 없는 경우](#-----)
            - [요약](#)
        - [6.3.5. XSS](#635-xss)
            - [미안하지만, 난 그걸 삽입할 수 없어](#-----)
            - [XSS 방지](#xss-)
            - [잘 알려진 XSS 함정](#--xss-)
            - [CSP](#csp)
            - [요약](#)
        - [6.3.6 크로스 사이트 요청 위조(CSRF, XSRF)](#636----csrf-xsrf)
    - [6.4 첫 번째 플러드 그릭](#64----)
        - [6.4.1 캡차를 사용하지 마라](#641---)
        - [6.4.2 캡차의 대체 방안](#642---)
        - [6.4.3 캐시를 구현하지 마라](#643---)
    - [6.5 암호 저장하기](#65--)
        - [6.5.1 소스 코드에 암호를 유지하는 것](#651-----)
            - [올바른 스토리지](#-)
            - [데이터는 언젠간 유출될 것이다.](#---)
            - [필요 없는 데이터는 수집하지 않는다](#----)
            - [올바른 비밀번호 해싱 방법](#---)
            - [문자열을 안전하게 비교하라](#--)
            - [고정된 솔트를 사용하지 마라](#---)
            - [오 랜덤, 오 찬스!](#---)
            - [UUID는 랜덤이 아니다](#uuid--)
    - [6.6 요약](#66-)

# 6장. 조사를 통한 보안

- 보안은 인간의 심리에 대한 넓고 깊은 용어이다
- 보안은 소프트웨어나 정보에 국한된 것이 아니라 사람과 환경에 대한 것이다

## 6.1 해커를 넘어서

- 보안은 겉보기에는 관련이 없는 다른 요인 때문에 침해될 수 있다
    - 정상적인 기능을 악용하거나, 액세스 로그와 같은 내용


- 보안을 신뢰성 관점에서 보면 보안과 관련된 결정을 내리기가 더 쉬워진다
- 개발 중인 제품의 보안에 대해 전혀 책임이 없더라도 코드의 신뢰성을 고려하는 것은 나중에 문제가 발생하지 않도록 의사결정을 내리는 데 도움이 된다.


- 보안과 관련된 결정을 신뢰성에 대한 기술 부채로 보는 것은 전반적으로 우리의 삶을 최적화하는 데 도움이 된다.
- 잠재적으로 보안에 미치는 영향과 관계없이 모든 제품에 대해 코드의 신뢰성을 고려하는 것이 좋다.

## 6.2 위협 모델링

- 위협 모델이란 보안 측면에서 무엇이 잘못될 수 있는지를 명확히 이해하는 것이다
- 위협 모델의 목표는 수행해야 하는 보안 조치의 우선순위를 정하고, 비용을 최적화하며, 효율성을 높이는 것이다.


- 위협 모델은 보안 위헙이 아닌 것이나 보호할 가치가 없는 것을 효과적으로 보여준다.


- 우리는 데이터가 유출되어 어떤 목적으로 사용되는지에 대해서는 크게 신경쓰지 않는다
- 유출된 데이터가 어떻게 활용될 수 있는지에 대한 상상력이 부족하기 때문이다.


- 언젠간 앱이나 플랫폼에 보안 문제가 발생할 것이다. 이것을 피할 수는 없다.


- 보안 문제에서 필연성 역시 상대적이다.
- 우리의 시스템 혹은 웹 페이지는 공격할만한 가치가 없을 수 있지만 우리의 웹사이트가 정교한 공격을 위한 수단으로 사용될 수도 있다.

### 6.2.1 주머니에 들어갈 만큼 작은 위협 모델

- 모든 애플리케이션에 대해 위협 모델링을 해야 하는 것은 안디ㅏ.
- 하지만 최소한의 보안 코드를 작성해야 하며, 이는 그렇게 어렵지 않다.


- 기본적으로 애플리케이션에 대한 소형 위협 모델이 필요하다.
    - 애플리케이션의 자산
    - 자산을 저장하는 서버
    - 정보 민감성
    - 리소스에 대한 액세스 경로


- 외부에 노출되기 쉬운 웹 서버가 가장 위험한 자산이다.


- 웹 서버를 공격하는 대신, 많은 권한을 가진 사용자를 노리는 것도 하나의 방법이다.
- 웹 서버에서 실행되는 코드도 공격 후보 중 하나다


- 가장 쉬운 엔트리 포인트 중 하나는 웹 애플리케이션이나 API다

## 6.3 웹 앱을 안전하게 작성하라

- 적용하기 쉬운 몇 가지 모범 사례를 사용하여 보안 문제에 대한 앱의 복원력을 높일 수 있다.

### 6.3.1 보안을 염두에 두고 설계하라

- 보안은 나중에 개선하기가 어렵다
- 따라서 애플리케이션을 설계할 때 다음 정도는 고려해보면 좋다
    - 위협 모델을 검토하라
    - 앱에 필요한 보안 암호를 저장할 위치를 결정하라
    - 최소한의 권한을 주도록 설계하라
    - 이 원칙을 조직 전체에 적용하라

### 6.3.2 은둔 보안 방식의 유용성

- 소프트웨어 보안은 사람이 얼마나 안전한지, 그리고 소프트웨어를 둘러싼 모든 것이 얼마나 안전한지에 달려 있다.
- 모든 보안 조치는 결국 깨질 수 있다.


- 은둔 보안을 통해선 시간을 벌 수 없고, 시간을 벌더라도 미미한 수준이다.
- 가장 위험한 것은 숨기는 것으로 충분하다고 믿는 것이다.
- 이는 충분하지 않으며, 그 자체로는 결코 효과적이지도 않다.


- 무의미한 수준의 보안은 보안이 아니다.
- 프로젝트가 일정 수준까지 성장하는 동안 프로젝트를 유지할 수 있도록 감아두는 임시 붕대일 뿐이다.


- 위협 모델에 기초하여 보안의 우선순위를 정하라.
- 보안은 완벽할 수 없으며 항상 사용자 경험과 보안 사이의 트레이드오프를 맞닥뜨리게 될 것이다.


- 보안 비용은 점점 더 저렴해지고 있다.


- 노력에 비해 성과가 미미하고 위험이 상당히 클 때는 은둔 보안보다 실제 보안을 선호해야 한다.
- 숨기는 것만으로 진정한 보안을 얻을 수는 없지만, 때때로 이 문제를 해결할 때까지 시간을 벌 수는 있다.

### 6.3.3 자신만의 보안을 구현하지 마라

- 프로덕션에서 자신만의 보안 코드를 사용하면 안 된다.
- 일반 개발자의 경우 중요한 세부 사항을 놓쳐 보안이 전혀 이루어지지 않을 수 있다.

### 6.3.4 SQL 삽입 공격

- SQL 인젝션 공격은 아직도 남아있다.

#### SQL 삽입에 대한 잘못된 해결 방안

- 이스케이핑 방법을 떠올릴 수 있지만, 이를 정확히 수행하는 것은 불가능하다.

#### SQL 삽입에 대한 이상적인 해결 방안

- 가장 안전한 방법은 매개변수화된 쿼리를 사용하는 것이다.
- 이 방법의 또 다른 장점은 쿼리 계획 캐시가 오염되는 것을 줄일 수 있다.


- 상수의 경우 불필요하게 매개변수화해서는 안 된다

#### 매개변수화된 쿼리를 사용할 수 없는 경우

- 패턴 매칭 등을 사용해 매개변수화된 쿼리를 사용할 수 없거나, 쿼리 계획 캐시의 오염 방지를 원하지 않을 수도 있다
- 이 경우 SQL 쿼리에 악성 문자가 몰래 들어오는 것을 방지해야 한다.

#### 요약

- 사용자 입력을 위해 매개변수화된 쿼리를 너무 많이 사용하지는 마라
- 잘못된 쿼리 최적화는 단점을 가진다
- 즉, 상수 값에 매개변수화된 쿼리를 사용하지 마라

### 6.3.5. XSS

- XSS(Cross-site Scripting)는 크로스 사이트 스크립팅 또는 사이트 간 스크립팅이라고 한다.
- 이는 2단계 공격이다
- 첫 번째는 페이지에 자바스크립트 코드를 삽입하는 기능이고, 두 번째는 네트워크를 통해 더 큰 자바스크립트 코드를 로드하여 웹 페이지에서 실행하는 것이다.


- 이를 통해 세션을 가로채서 여러 가지 일을 몰래 해버릴 수 있다.

#### 미안하지만, 난 그걸 삽입할 수 없어

- XSS는 주로 잘못 인코딩된 HTML에서 발생하며, 그런 점에서 SQL 삽입과 비슷하다.


- 자바스크립트 코드가 서드 파티 웹사이트에 웹 요청을 보내도록 허용하는 것이 크로스 사이트 요청으로 간주된다.

#### XSS 방지

- 이를 방지하는 가장 쉬운 방법은 특수 HTML 문자를 이스케이프하도록 텍스트를 인코딩하는 것이다.

#### 잘 알려진 XSS 함정

- 모델에 HTML을 그대로 사용 하는 경우 XSS 문제가 발생할 수도 있다.
- 이를 피할 수 없다면 잘 인코딩된 HTML 문자열을 정의할 수 있는 특정 기능이나 타입을 사용하는 것을 고려해 보자.

#### CSP

- 콘텐츠 보안 정책(Content Security Policy, CSP)는 SXX 공격에 대항하기 위한 또 다른 무기가 되어준다.
- 서드파티 서버가 요청할 수 있는 리소스를 제한하는 HTTP 헤더를 의미한다.


- 하지만 CSP는 사용하기가 어렵다
- 신뢰할 수 있는 도메인의 목록을 만들고, 이것을 최신 상태로 유지하는 것은 쉽지 않다.


- CSP 사용 여부와는 관계 없이 HTML 출력을 올바르게 인코딩해야 한다.

#### 요약

- HTML을 삽입하거나 인코딩을 완전히 우회하는 등의 편법을 사용하지 않는 것만으로도 XSS를 쉽게 피할 수 있다.

### 6.3.6 크로스 사이트 요청 위조(CSRF, XSRF)

- POST 주소는 클릭할 수 있는 링크로 만들 수 없으며 한 번만 게시할 수 있다


- POST의 약점은 원래 폼이 POST 요청이 만들어진 도메인과 동일한 도메인에 상주할 필요가 없기 때문에 발생한다.


- 이러한 문제를 방지하는 방법은 모든 폼을 위해 랜덤하게 생성된 번호를 사용하고, 폼 자체와 웹 사이트 응답 헤더 양쪽에 번호를 복제하는 것이다.
- 보통은 프레임워크가 이 문제를 해결해준다.

## 6.4 첫 번째 플러드 그릭

- 서비스 거부(Denial of service, DoS) 공격은 서비스가 멈추도록 만드는 가장 대표적인 이름이다.
- CPU 사용량이 급증하거나 사용 가능한 대역폭이 포화 상태가 되도록 만드는 공격을 플러드(flood) 공격이라고 한다.


- 많은 사용자가 접속했을 때도 이와 비슷한 현상이 발생하므로 완벽한 해결책은 없다.
- 사용자와 공격자를 구별하는 것은 어려운 일이다.
- 이를 완화하는 가장 유명한 방법 중 하나는 캡차를 활용하는 것이다.

### 6.4.1 캡차를 사용하지 마라

- 캡차의 문제점은 사람이 답변하기에도 어렵다는 것이다
- 캡차는 유용하지만 동시에 서비스 거부 공격만큼이나 유해하다.


- 충분한 인기를 얻을 때까지 사용자를 힘들게 하지 마라


- 기술적인 문제를 위해 UX 마찰을 감수해야 하는 모든 종류의 해결책에 동일하게 적용된다.

### 6.4.2 캡차의 대체 방안

- 성능을 고려하여 코드를 작성하고 캐시를 공격적으로 사용하여 필요에 따라 스로틀링을 사용하라.


- 스로틀링에 대한 대안으로는 작업 증명(PoW, Proof of Work)가 있다.
- 요청을 하려면 컴퓨터나 장치가 일정 시간이 걸리는 정말 어려운 문제를 풀어야 한다.
- 하지만 이는 클라이언트에게 부담을 준다.


- 로그인과 같은 기능도 하나의 대안이지만 이 또한 사용자가 견뎌야 하는 불편함이다.
- 공격 가능성을 줄이기로 결정했을 때 이러한 장단점을 고려해야 한다.

### 6.4.3 캐시를 구현하지 마라

- 일단 딕셔너리의 경우 사용자가 어떤 런타임을 사용하는지를 알면 해시 충돌 공격을 일으킬 수 있다.
- 웹을 위해 개발된 딕셔너리의 경우 일반적으로 더 나은 분산 속성을 가진 해시 코드 알고리즘을 사용하므로 충돌 확률이 낮다.


- 이상적인 캐시 데이터 구조라면 메모리 사용량을 견제하기 위해 오래된 항목을 제거할 수 있어야 한다.
- 가능한 프레임워크에서 제공하는 기존의 캐시 인프라를 활용할 것을 추천한다.

## 6.5 암호 저장하기

보안 위협에 대한 최상의 완화 조치 중 하나는 구획화다.

### 6.5.1 소스 코드에 암호를 유지하는 것

- 소스 코드에 암호를 저장하는 것은 문제가 되지않을 수 있다
- 문제는 시간적인 요소를 고려하지 않았다는 것이다.
- 당장은 문제가 되지 않지만 이후에 실수로 인해 데이터가 유출될 수 있다.

#### 올바른 스토리지

- 암호 관리자를 콜드 슽뢰지로 사용하거나 Azure Key Vault, AWS KMS 등의 클라우드 키 볼트와 같이 해당 목적으로 설계된 별도의 스토리지에 암호를 저장하는 것이 좋다.

#### 데이터는 언젠간 유출될 것이다.

- 항상 데이터가 유출될 수 있는 위험을 가정하고 이에 대비하여 설계해야 한다.

#### 필요 없는 데이터는 수집하지 않는다

- 처음부터 데이터가 없다면 유출될 일도 없다.

#### 올바른 비밀번호 해싱 방법

- 비밀번호 유출을 막는 가장 일반적인 방법은 해싱 알고리즘을 사용하는 것이다.
- 암호적으로 안전한 해시 알고리즘은 의도적으로 느리고 다양한 형태의 공격에 내성을 가지고 있다.


- 암호 해싱의 경우 동일한 알고리즘을 여러 번 반복하여 실행 속도를 늦추는 알고리즘을 사용하는 것이 좋다.
- 암호적으로 안전하더라도 반복 없이 해시 함수를 한 번만 돌린 결과는 절대 사용하지 마라


- PBKDF2는 GPU에서 병렬 처리가 가능하고, 크랙에 특화된 ASIC이나 FPGA 설계가 있어 빠르게 크랙할 수 있다
- 이에 안전한 bcrypt, scrypt, Argon2와 같은 최신 해시 알고리즘이 있다.


- 해시 알고리즘에 대한 난이도 설정이 너무 높아서 웹 사이트에 로그인을 시도하는 것이 DoS 공격이 되지 않도록 해야 한다.
- 프로덕션 서버에서 100밀리초 이상 걸리는 난이도를 목표로 삼아서는 안 된다.
- 서비스 운영 중에 해시 알고리즘을 변경하는 것은 어렵기 때문에 암호 해싱의 난이도가 서비스에 방해가 되지 않도록 미치 벤치마킹하기를 강력히 추천한다.


- 알고리즘을 선택할 때는 사용 중인 프레임워크에서 지원하는 알고리즘을 선호하는 것이 좋다

#### 문자열을 안전하게 비교하라

- 해시 값을 비교할 때 불일치하는 값을 발견해도 미리 반환하지 마라
- 이를 통해 공격자가 정보를 유추할 수 있다


- 따라서 항상 일정한 시간이 걸리는 비교 함수가 필요하다

#### 고정된 솔트를 사용하지 마라

- 솔트(salt)는 원래 동일한 해시 값을 갖는 비밀번호지만 값에 차이를 주기 위해 암호 해싱 알고리즘에 도입된 추가적인 값을 말한다.
- 고정된 솔트는 보안을 약화시키므로 항상 랜덤 값을 사용하라
    - 이는 규칙적인 정규 의사 난수 값이 아니라 암호학적으로 안전한 의사난수 생성기를 사용해야 한다

#### 오 랜덤, 오 찬스!

- 간단한 랜덤 알고리즘은 빠르지만 안전하지는 않다
- 예측 가능하며, 상대적으로 짧은 주기로 반복된다.


- 예측하기가 매우 어려운 암호화된 안전한 의사 난수가 필요하다.
- 이런 알고리즘은 더 느리므로 보안 맥락에서만 사용해야 한다.


- 암호학적으로 안전한 해시 라이브러리 중 많은 것이 솔트의 길이만 입력받기도 한다.

#### UUID는 랜덤이 아니다

- UUID는 완전한 랜덤은 아니지만 단조 증가 정수보다는 안전하다
- 완전히 랜덤한 UUID는 인덱스 분포 측면에서 좋지 않다.
- 따라서 임의성이 있지만 더 균일한 인덱스 분포를 만드는 UUIDv6, UUIDv7, UUIDv7이 등장하기도 했다.

## 6.6 요약

- 중간에 보안을 다시 손보는 것은 어려우니 보안을 처음부터 염두에 두고 설계하라
- 숨기는 것에 의존하는 은둔 보안은 진짜 보안이 아니며, 심각한 손해의 원인이 될 수 있다
- 사용자 입력은 나쁘다
- 암호를 소스 코드가 아닌 별도의 암호 저장소에 저장하라
- 보안 관련 컨텍스트에서 GUID가 아닌 암호학적으로 안전한 의사 난수를 사용하라

