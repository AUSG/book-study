- [7장. 자기 주장이 뚜렷한 최적화](#7----)
    - [7.1 올바른 문제를 해결하라](#71---)
        - [7.1.1 단순한 벤치마킹](#711--)
        - [7.1.2 성능 대 응답성](#712---)
    - [7.2 완만함의 분석](#72--)
    - [7.3 최고부터 시작하라](#73--)
        - [7.3.1 중첩 루프](#731--)
        - [7.3.2 문자열 지향 프로그래밍](#732---)
        - [7.3.3 2b || !2b 평가하기](#733-2b--2b-)
    - [7.4 병목 현상 깨뜨리기](#74---)
        - [7.4.1 데이터를 패킹하지 마라](#741---)
        - [7.4.2 근접성을 활용하라](#742--)
        - [7.4.3 종속 작업을 세분화하라](#743---)
        - [7.4.4 예측할 수 있도록 하라](#744----)
        - [7.4.5 SIMD](#745-simd)
    - [7.5 1초와 0초의 I/O(입출력)](#75-1-0-io)
        - [7.5.1 I/O 속도 향상](#751-io--)
        - [7.5.2 I/O를 논-블로킹(non-blocking)으로 만들라](#752-io--non-blocking-)
        - [7.5.3 오래된 방법](#753--)
        - [7.5.4 최신 비동기/대기](#754--)
        - [7.5.5 비동기 I/O의 잠재적 문제](#755--io--)
    - [7.6 다른 모든 것이 실패할 경우, 캐시를 이용하라](#76-------)
    - [7.7 요약](#77-)

# 7장. 자기 주장이 뚜렷한 최적화

- "섣부른 최적화는 모든 악의 근원이다"라는 말은 잘못 알려졌으며, 잘못 인용되고 있다.
- 실제로 커누스가 한 말은 다음과 같다.

> 우리는 작은 효율성을 잊어야 한다. 97%의 경우에 말이다. 섣부른 최적화는 모든 악의 근원이다. 그러나 중요한 3%의 기회를 놓쳐서는 안 된다.

- 오히려 섣부른 최적화가 모든 학습의 근원이 될 수 있다.
- 섣부른 최적화는 존재하지 않는 가상의 문제를 만들어 푸는 것과 같으며 좋은 연습이 되어준다.
- 배움의 기회를 놓치지 마라


- 물론 섣부른 최적화는 코드에 경직성을 가져와 유지 관리를 더 어렵게 만들 수 있다.
- 또한 애초에 존재하지 않는 문제를 위해 최적화하려고 했을 수 있으며, 이는 코드의 신뢰성을 떨어뜨릴 수 있다는 점이다.


- 즉, 최적화의 트레이드오프를 이해해야 하며 해결해야 할 문제가 무엇인지를 올바르게 파악하는 것이 중요하다.

## 7.1 올바른 문제를 해결하라

- 느린 성능은 여러 가지 방법으로 수정할 수 있다.
- 문제의 정확한 특성에 따라 솔루션의 효과와 구현에 소요되는 시간이 크게 달라질 수 있다
- 따라서 먼저 성능 문제가 있는지를 판단해야 한다.

### 7.1.1 단순한 벤치마킹

- 벤치마킹은 성능 문제의 근본적인 원인을 파악하는 데는 도움이 안 될 수 있지만, 성능 문제가 존재한다는 것을 식별하는 데는 도움이 될 수 있다.
- 벤치마킹 라이브러리를 사용하지 않더라도 타이머를 사용하여 코드 조각의 실행 시간을 파악할 수 있다.


- 벤치마킹 라이브러리는 변동이나 함수 호출의 오버헤드와 관련된 측정 오차를 제거해준다.

### 7.1.2 성능 대 응답성

- 벤치마크는 다른 코드보다 상대적으로 빠른지 혹은 느린지를 알려준다.
- 보통 100밀리초 이상 걸리는 동작은 지연된 것으로 느껴지며, 300밀리초 이상 걸리는 동작은 느린 것으로 간주된다.


- 성능이 항상 응답과 관련된 것은 아니다
- 실제로 응답성이 높은 앱이 되려면 작업을 더 느리게 수행해야 할 수도 있다.


- 대기 시간은 사용자 경험뿐만 아니라 성능에도 영향을 미친다

## 7.2 완만함의 분석

- 성능을 향상시키는 방법을 이해하려면 먼저 성능 장애의 원인부터 이해해야 한다.
- 속도 부분은 컴퓨터의 작동 방식을 이해하면 도움이 된다.


- 기본적으로 코드 속도와 관련된 성능 문제는 명령어 몇 개가 몇 번 실행되는지에 따라 달라진다.
- 코드를 최적화할 때 실행하는 명령어 수를 줄이거나 더 빠른 버전의 명령어를 사용하려고 시도하라

## 7.3 최고부터 시작하라

- 실행하는 명령어 수를 줄이는 두 번째로 줄이는 방법은 더 빠른 알고리즘을 선택하는 것이다.
- 더 빠른 알고리즘은 비록 최적화된 구현이 아니더라도 엄청난 차이를 만들 수 있다.


- 성능 문제는 클라이언트나 서버에서 발생할 수 있다
- 하향식 접근 방식을 따를 경우 막연히 추측하는 대신 효율적인 방법으로 문제의 근본 원인을 찾을 수 있다.
    - 이는 이진 검색 방법과 비슷하다.


- 문제가 발생하는 부분을 찾으면 코드 복잡도에 명백한 위험 신호가 있는지 확인한다.

### 7.3.1 중첩 루프

- 중첩 루프로 코드를 작성할 때 곱셈의 효과를 과소평가하곤 한다.
- 중첩 루프가 항상 보이는 것도 아니다.
    - 내부에 루프가 숨겨져있는 경우도 종종 있다.

### 7.3.2 문자열 지향 프로그래밍

- 컬렉션 등을 매번 문자열 값으로 사용하지 말고 특정 타입을 사용하면 좋다

### 7.3.3 2b || !2b 평가하기

- if문에 있는 불리언 표현식은 작성된 순서대로 평가된다.
- 따라서 연산이 많이 필요한 속성 전에 간단한 값을 먼저 검사하면 좋다.


- 피연산자의 타입에 따라 표현식을 정렬하는 것을 추천한다.


- 불리언 평가를 최적화하는 동안 if 문의 로직이 실수로 깨지지 않도록 해야 한다.

## 7.4 병목 현상 깨뜨리기

- 작업에 적합한 알고리즘이나 메서드를 사용하고 있다고 확신한다면 코드 자체를 최적화할 수 있는 방법으로 넘어갈 수 있다.

### 7.4.1 데이터를 패킹하지 마라

- CPU가 정렬되지 않은 메모리 주소에서 데이터를 읽는 경우 패널티가 발생할 수 있다.
- 메모리 정렬은 최소 CPU의 워드 크기인 4, 8, 16 등의 배수에 메모리 위치가 오도록 하는 것을 의미한다.
    - 워드 크기는 일반적으로 CPU가 한 번에 처리할 수 있는 데이터의 양으로 정의된다.


- 보통은 컴파일러가 이런 정렬 작업을 처리한다.


- 메모리 공간을 최적화하면 메모리 사용량은 줄어들 수 있지만 정렬되지 않은 경계에 대한 메모리 액세스 속도가 느려진다.
- 불필요하게 메모리 공간을 최적화하는 것은 피하는 것이 좋다.

### 7.4.2 근접성을 활용하라

- 배열은 캐시의 지역성이 좋으므로 연결 리스트보다 더 우수한 성능을 보일 수 있다.

### 7.4.3 종속 작업을 세분화하라

- CPU는 경우에 따라 병렬로 명령을 실행할 수 있다.
- 코드 순서를 변경하고 코드의 종속성을 제거하는 것만으로도 코드 속도를 향상시킬 수 있다.

### 7.4.4 예측할 수 있도록 하라

- 실행 시간을 최적화하기 위해 CPU는 실행 코드보다 선제적으로 움직여 필요하기 전에 미리 준비하낟.
- 이를 분기 예측(branch prediction)이라고 한다.


- CPU가 예측하지 못하는 일이 줄어들수록 성능은 향상될 것이다.

### 7.4.5 SIMD

- SIMD를 이용하면 단일 명령어로 여러 데이터의 연산을 한번에 처리할 수 있다.
- CPU에 따라서 SIMD를 지원하지 않기도 하고 동시에 지원하는 타입의 수도 달라진다.

## 7.5 1초와 0초의 I/O(입출력)

- I/O는 보통 성능 체인에서 가장 느린 링크다.
- 대부분의 경우 I/O 자체를 빠르게 만들 수는 없다.
- CPU와 I/O 작업을 겹치면 더 짧은 시간 내에 전체 작업을 완료할 수 있다.

### 7.5.1 I/O 속도 향상

- 하드웨어의 고유한 한계로 인해 I/O 속도는 느리지만 이를 더 빠르게 만들 수 있다.
- I/O 요청 수 자체를 줄이거나 블록 디바이스의 특성을 잘 활용하면 I/O 성능을 올릴 수 있다.

### 7.5.2 I/O를 논-블로킹(non-blocking)으로 만들라

- 비동기 I/O는 I/O 부하가 높은 작업만을 위한 병렬화 모델이며 단일 코어에서 작동할 수 있다.
- 멀티스레딩과 비동기 I/O는 서로 다른 목적을 위해 활용되며 함께 사용할 수도 있다.


- 비동기 I/O의 성능 이점은 추가적인 작업 없이 코드에 자연스러운 병렬화를 제공하는 데 있다
- 또한 사용자 인터페이스에서의 응답성을 개선할 수 있다.

### 7.5.3 오래된 방법

- 이전에는 콜백 함수로 비동기 I/O를 관리했다
- 하지만 콜백이 많아지면 관리가 어렵다.

### 7.5.4 최신 비동기/대기

- C#에서 소개된 async/await 메커니즘은 동기 코드처럼 코드를 작성할 수 있어서 좋다.

### 7.5.5 비동기 I/O의 잠재적 문제

- I/O 관련 작업 호출 없어도 async 함수를 선언하고 CPU 작업만 수행할 수 있다.
- 하지만 이는 이점도 없이 불필요하고 복잡하게 만든다.

## 7.6 다른 모든 것이 실패할 경우, 캐시를 이용하라

- 캐시 무효화는 어려운 문제일 수 있지만 무효화에 대해 걱정하지 않아도 되는 것만 캐싱하면 문제가 되지 않는다.


- 캐싱을 위해 설계되지 않은 데이터 구조는 사용하지 마라

## 7.7 요약

- 이른 최적화를 연습하고 그것을 통해 학습하라
- 항상 벤치마킹으로 최적화를 검증하라
- 최적화와 대응성 사이의 균형을 유지하라


- 데이터 구조를 구축할 때는 더 나은 성능을 얻기 위해 메모리 정렬의 장점을 생각하라

