- [9장. 버그와의 동거](#9--)
    - [9.1 버그를 수정하지 마라](#91---)
    - [9.2 오류에 대한 두려움](#92---)
        - [9.2.1 예외에 대한 진실](#921---)
        - [9.2.2 에외를 잡아내지 마라](#922---)
        - [9.2.3 예외 복원성](#923--)
        - [9.2.4 트랜잭션이 없는 복원력](#924---)
        - [9.2.5 예외가 오류](#925--)
    - [9.3 디버깅하지 마라](#93--)
        - [9.3.1 printf() 디버깅](#931-printf-)
        - [9.3.2 덤프 다이빙](#932--)
        - [9.3.3 고무 오리 디버깅](#933---)
    - [9.4 요약](#94-)

# 9장. 버그와의 동거

- 버그는 소프트웨어의 품질을 결정하는 측정 기준의 기본 단위다.


- 튜링 기계는 소프트웨어의 무한한 수준의 창의성을 허용하지만, 실행하지 않고는 정확성을 검증하는 것이 불가능하다.
- 튜링 완전이 아닌 언어에 의존하는 언어도 있지만 튜링 완전 언어에 비해 할 수 있는 것이 훨씬 적다.
- 튜링 기계의 특성상 버그는 피할 수 없다.

## 9.1 버그를 수정하지 마라

- 제법 큰 프로젝트를 맡고 있는 개발 팀이라면, 어떤 버그를 수정할 것인지를 결정하기 위한 트리아지 프로세스를 가지고 있어야 한다.


- 이는 제한된 자원을 효과적으로 활용할 수 있는 유일한 방법이었다.
- 트리아지는 여러분이 무엇을 먼저 고쳐야 하며, 혹은 그것을 정말 고쳐야 하는지 결정하는 것을 도와준다.


- 팀에는 버그의 우선순위를 정하기 위한 기준을 공유하고 있어야 한다.


- 대부분의 소프트웨어 프로젝트에는 버그의 우선순위를 결정하기 위한 큰 회의가 필요하지 않을 수 있다


- 우선순위를 평가하는 더 간단한 방법은 심각성이라는 관점을 사용하는 것이다
- 우선순위는 어떤 버그가 비즈니스에 끼치는 영향을 의미하고, 반면에 심각성은 고객에게 미치는 영향을 의미한다.


- 우선순위와 심각성에 대한 임계 값을 설정하여 순위가 그 아래인 버그들은 고치지 않도록 해야 한다.


- 버그를 추적하는 것은 비용이 발생한다
- 팀에서는 수정하지 않아도 되는 버그를 재검토하는 일을 피해야 한다
- 이러한 과정은 개발 초기에 결정하려고 노력해야 한다
- 그래야 시간을 아끼면서도 제품의 적절한 품질을 유지할 수 있다.

## 9.2 오류에 대한 두려움

- 모든 버그가 코드의 오류로 발생하는 것은 아니며, 또한 모든 오류가 코드에 버그가 있음을 의미하지도 않는다.


- 개발자는 본능적으로 모든 오류를 버그로 간주하고 지속적이고 끈질기게 제거하려고 노력한다
- 개발자는 모든 종류의 오류를 동일한 방식을 다룬다
- 이는 오류를 볼 필요가 있는지의 여부와는 관계없이 모든 오류를 보고하거나 모든 오류를 숨기고 아무도 읽지 않는 서버의 로그 파일에 저장하는 방식이다.


- 이를 해결하는 방법은 오류를 '상태의 일부'로 간주하는 것이다

### 9.2.1 예외에 대한 진실

- 예외는 정의되지 않은 상태 문제를 해결하는 새로운 방법이다
- 알려지지 않은 상태의 문제점은 그 상태가 미치는 영향이 무엇인지 그리고 이것이 얼마나 심각한지 알 수 없다는 것이다.
- 처리되지 않은 예외를 다루는 일반적인 방법은 주어진 상태가 어떻게 될지 예상할 수 없기 때문에 해당 애플리케이션을 종료하는 것이다.


- 예외가 발생하더라도 앱을 손상된 상태로 놔두어서는 안 된다.

### 9.2.2 에외를 잡아내지 마라

- 예외를 무시하고 넘어가면 충돌은 사라지겠지만, 근본적인 원인은 사라지지 않는다.


- 예외가 있다는 것만으로도 어딘가 충돌이 발생한다는 것을 알 수 있다.
- 충돌 원인을 깔끔하게 파악하기 힘든 버그를 두려워하라. 빈 catch 문에 가려진 문제를 두려워하라
- 예외는 어떤 문제가 파악하기 어려운 상태가 되기 전에 해당 문제를 잡아낼 수 있도록 해주기 때문에 훌룡하다


- 예외는 충돌의 원인이 되므로 잡아내지 마라
- 예외가 잘못된 동작 때문에 발생한 것이라면 원인이 되는 버그를 수정하라
- 이미 알고있는 이유 때문에 발생한다면 명시적으로 예외 처리를 하라


- 즉, 예외를 위해 계획된 특정 수단이 있는가, 아니면 충돌을 피하기만 해도 될까를 질문하라


- 많은 개발자가 어떤 유형의 예외를 잡아야 하는지에 대해서는 별로 신경쓰지 않기 때문에 유형화되지 않은 catch 블록을 사용한다


- 프로그래머의 오류가 아닌 특정한 예외를 잡아야 한다


- 모든 예외를 잡기 위한 catch 블록은 로깅과 같은 일반적인 목적으로 세상에 존재하는 모든 예외를 정말로 잡아낼 목적이 있는 경우에만 사용해야 한다

### 9.2.3 예외 복원성

- 예외가 계속 발생하더라도 작 작동하는 흐름을 설계해야 하며, 오염된 상태에 빠지지 않도록 만들어야 하낟
- 설계상 코드는 예외를 견딜 수 있어야 한다.


- 예외 복원성이 뛰어난 설계는 멱등성에서 시작한다
- 일반적으로 HTTP GET 요청은 멱등성이 있으며 POST 요청은 멱등성이 없다고 생각한다
- 하지만 GET 요청도 멱등성이 없을 수도 있고 POST 요청이 멱등성이 있을 수도 있다.


- 이를 이용하면 예기치 않게 중단되었을 때 일관성이라는 이점을 얻는다
- 덕분에 문제없이 우리 코드를 여러 번 안전하게 호출할 수 있게 된다.

### 9.2.4 트랜잭션이 없는 복원력

- 멱등성은 예외 복원력에는 충분하지 않을 수 있지만, 우리가 만든 함수가 다른 상태에서 어떻게 동작할지 생각하게 만들기 때문에 훌륭한 기반이 된다.

### 9.2.5 예외가 오류

- 모든 오류가 예외라고 할 수는 없다.
- 호출자가 예외를 처리할 것으로 예상되는 경우에는 예외를 사용하지 마라. 그것은 예외적인 상황이 아니다.
    - 전자는 예외를 던지고, 후자는 결과를 반환한다.


- 항상 성공할 것으로 예상하는 경우에는 결과 값을 반환하짐 ㅏ라
- 함수의 반환 자체가 성공을 의미한다.


- 호출자가 어떤 정보를 얼마나 필요로 하는지에 따라 다양한 유형의 오류 결과를 가져올 수 있다.


- 다른 경우를 위한 계획이 없다면 다른 가능성까지 추가로 고려해서 모든 경우의 수를 고려하지 않아도 도니다.

## 9.3 디버깅하지 마라

- 디버깅은 대부분 디버거에서 프로그램을 실행하고, 중단점을 두고, 코드를 단계별로 추적하며 프로그램의 상태를 조사하는 것을 의미한다.
- 디버거는 매우 편리하지만 항상 최고의 도구는 아니다
- 문제의 근본적인 원인을 파악하는 데 시간이 더 많이 걸릴 수 있다
- 또한 모든 상황에서 프로그램을 디버깅할 수 있는 것도 아니다.

### 9.3.1 printf() 디버깅

- 때로는 원시적인 접근법이 문제를 식별하는 데 더 효과적일 수 있다


- 오히려 간단하게 상황을 확인하고 싶다면 출력이 간단하고 더 빠를 수도 있다.

### 9.3.2 덤프 다이빙

- 단계별 디버깅을 위한 또 다른 대안은 충돌 덤프를 검사하는 것이다
- 충볼 덤프는 프로그램의 메모리 공간의 스냅샷 내용을 담고 있는 파일을 말한다


- 충돌 덤프 디버깅은 어려운 주제이며, 메모리 누수나 경쟁 상태를 확인하는 것과 같이 다른 여러 상황을 다룬다.

### 9.3.3 고무 오리 디버깅

- 스택 오버플로에 질문을 올리는 대신 질문을 작성만 하고 게시하지 않는다
- 이는 다음에 대해 다시 생각해볼 수 있다. "여러분은 무슨 시도를 했는가?"
- 스스로에게 이 질문을 하는 것은 여러 가지 이점이 있지만, 가장 중요한 것은 여러분이 아직 가능한 모든 해결책을 시도하지 않았다는 것을 깨닫게 해준다는 것이다
- 질문에 대해 생각하다 보면 내가 고려하지 못한 수많은 다른 가능성을 함께 떠올리게 된다.

## 9.4 요약

- 버그에 우선순위를 정해 중요하지 않은 버그를 수정하기 위해 리소스를 낭비하지 않도록 하라
- 해당 사례에 대해 계획적이고 의도적인 대응 방안이 있는 경우에만 예외를 포착하라.
- 오류가 일반적이거나 예상되는 경우에는 예외 대신 결과 반환 코드나 enum을 사용하라


