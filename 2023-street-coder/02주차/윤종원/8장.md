- [8장. 기분 좋은 확장성](#8---)
    - [8.1 잠금을 사용하지 마라](#81---)
        - [8.1.1 이중 점검된 잠금](#811---)
    - [8.2 불일치를 수용하라](#82--)
        - [8.2.1 무서운 NOLOCK](#821--nolock)
    - [8.3 데이터베이스 연결을 캐시하지 마라](#83----)
        - [8.3.1 ORM의 형태로](#831-orm-)
    - [8.4 스레드를 사용하지 마라](#84---)
        - [8.4.1 비동기 코드의 주의사항](#841---)
            - [I/O 작업이 없다면 비동기도 필요 없음을 의미한다](#io------)
            - [동기화와 비동기화를 섞지 마라](#---)
        - [8.4.2 비동기를 이용한 멀티스레딩](#842---)
    - [8.5 모놀리스를 존중하라](#85--)
    - [8.6 요약](#86-)

# 8장. 기분 좋은 확장성

- 성능만으로는 시스템을 확장할 수 없다
- 점점 더 많은 사용자를 만족시키기 위해서는 모든 측면의 설계가 필요하다


- 초창기 기술적인 결정은 장기적으로 중요하지 않다.


- 시스템 관점에서 확장성은 더 많은 하드웨어를 투입하여 시스템을 더 빠르게 만들 수 있는 능력을 의미한다.


- 코드가 부하를 따라가는 방법에는 분명한 상한선이 있으며, 확장성이 있는 코드를 작성하는 이유는 상한선을 가능한 한 멀리 밀어내기 위한 것이다.


- 시스템을 처음부터 완벽하게 확장하도록 설계할 수도 있지만, 이를 달성하는 데 필요한 노력과 시간, 그리고 이를 통해 얻을 수 있는 보상은 최대한 빨리 제품을 출시해야 하는 중요성으로 가려진다.


- 이미 늦어진 프로젝트에 더 많은 사람을 할당하는 것은 지연을 더 가중시킬 뿐이라고 말헀다.


- 단일 CPU 코어에서 달성할 수 있는 성능에는 여전히 상한선이 있다.


- 확장할 수 있는 코드를 만들기 위한 첫 번째 단계는 확장성을 방해하는 잘못된 코드를 제거하는 것이다.

## 8.1 잠금을 사용하지 마라

- 모든 스레드가 다른 스레드를 고려하지 않고 데이터를 자체적으로 조작하는 방식을 레이스 조건(또는 경쟁 조건)이라고 한다.


- 이를 해결하는 가장 최적화된 방법은 아주 증가 작업(원자 연산)을 사용하는 것이다.
- 단순한 원자 증가 연산만으로 코드를 스레드 안전하게 만들기에 충분하지 않은 경우가 많다.


- 잠금은 일관성을 제공하기는 하지만 동시에 확장성에서는 매우 큰 문제가 될 수 있다.
- 따라서 잠금이 정말 필요한지 확인해야 한다.
- 잠금이 필요하지 않을 때에도 불필요하게 특정 조건이 충족되기를 기다리고 있을 수도 있다.
- 하지만 잠금이 필요없는지 판단하는 것은 쉽지 않다. 코드의 부작용을 평가하기 어렵기 때문이다.
- 따라서 잠금의 원리를 이해하고 무슨 작업을 하는지를 분명히 해야 한다.


- 사용하는 공유 데이터 구조에 따라서 잠금이 없어도 되는 경우도 있다
- 잠금 없는 구조를 구현하는 것은 복잡할 수 있다
- 잠금이 필요한 구조보다 더 느릴 수 있지만 확장성은 더 크다.


- 스레드 안전은 여러 스레드가 주어진 데이터 구조를 수정하려고 할 때만 문제가 된다.
- 부작용 없는 모든 읽기 전용 구조는 스레드 안전하기 때문에 다른 식으로 데이터 구조를 잠그거나 스레드 안전할 필요가 없다.


- 혹은 `Concurrent` 류의 데이터 구조를 사용하는 것도 방법이다.
- 이는 수명이 짧은 잠금을 사용한다.
- 짧은 시간 동안에만 잠금이 유지되도록 최적화되어 잠금이 없는 방법보다 훨씬 빠르고 간단하다.


- 혹은 `Immutable` 류의 데이터 구조가 있는데 이는 원본 데이터는 절대 바뀌지 않고 수정할 때마다 수정된 데이터의 새로운 복사본을 만든다.
- 속도는 느리지만 `Councurrent`보다 선호되는 경우가 많다.

### 8.1.1 이중 점검된 잠금

- 이중 점검된 잠금을 이용해 싱글톤 패턴을 구현할 수 있다
- 그러나 `Lazy` 등의 기능을 사용하면 훨씬 쉽고 안전하게 싱글톤 인스턴스를 초기화할 수 있다.

## 8.2 불일치를 수용하라

- 신뢰성을 어느 정도 희생해서 성능과 확장성을 향상시킬 수 있다.
- NoSQL이 대표적인 예시다.
- 그러나 MySQL이나 SQL Server와 같은 기존 데이터베이스에서도 비슷한 이점을 얻을 수 있다.

### 8.2.1 무서운 NOLOCK

- 쿼리 힌트로 `NOLOCK`을 제공하면 일관성 없는 읽기를 지시할 수 있다.
- 데이터베이스의 잠금은 성능 저하를 유발하므로 결과적 일관성을 통해 이를 해결할 수 있다..


- 이는 일시적으로 일관성이 맞지 않을 수 있지만 잠금을 없애 성능을 향상시킬 수 있다.
    - 많은 경우에 이러한 불일치는 앱이 견딜 수 있는 정도의 수준이다
    - 확장성을 위해서라면 플랫폼이 어느 정도의 불일치를 겪어도 감수할 수 있다.


- 잠금을 사용하는 쿼리 또한 잠금의 범위를 줄이면 성능을 향상시킬 수 있다.


- `NOLOCK` 쿼리 힌트를 사용하면 불완전한 데이터를 읽을 순 있지만 잠금에 대한 영향 없이 쿼리를 수행할 수 있다.


- 결과를 제대로 알고 있다면 이러한 불일치를 두려워하지 않아도 된다.

## 8.3 데이터베이스 연결을 캐시하지 마라

- 커넥션 풀을 사용하라
- 빠르게 여러 쿼리를 실행하는 경우 매번 커넥션을 닫고 열지 말고 한번에 쿼리 날린 후에 닫아라

### 8.3.1 ORM의 형태로

- ORM은 데이터베이스의 복잡성을 숨겨준다.
- 커넥션과 관련된 것들도 처리해준다.

## 8.4 스레드를 사용하지 마라

- 확장성은 병렬화뿐만 아니라 리소스를 절약하는 것이기도 하다.
- 미리 초기화된 스레드를 사용하는 스레드 풀을 사용하기도 한다.
- 이러한 스레드 풀을 활용하면 I/O 작업에 대한 효율성을 높일 수 있지만 컨텍스트 스위칭에 대한 오버헤드로 오히려 성능이 떨어질 수 있다.


- 비동기 함수를 기다리지 않으면 결과를 즉시 받을 수 있지만 이는 실행이 완료된 것이 아니다.
- 이러한 특성을 잘 활용하면 병렬 작업을 수행할 수 있지만 버그가 발생하기가 쉽다.

### 8.4.1 비동기 코드의 주의사항

- 모든 것을 비동기 방식으로 만들자고 생각하면 모든 것을 악화시킬 수도 있다.

#### I/O 작업이 없다면 비동기도 필요 없음을 의미한다

- 어떤 함수가 비동기 함수를 호출하지 않는다면 그 함수도 비동기일 필요는 없다.
- CPU 바운드 작업에서 비도익를 사용하면 I/O 작업과 달리 별도의 스레드가 필요하기 때문에 확장성에 도움이 되지 않는다.
- 오히려 비동기 관련 스캐폴딩으로 함수가 불필요하게 커지고 코드가 느려질 수 있다.


- 함수를 비동기로 만드는 이유는 항상 분명하고 명확해야 한다.

#### 동기화와 비동기화를 섞지 마라

- 동기화 코드에서 비동기 함수를 기다리다 보면 호출자 코드에 의존하는 비동기 함수에 있는 다른 함수로 데드락이 발생할 수 있다.


- 모든 함수가 비동기에 적합한 것은 아니기 때문에 비동기 함수에 동기화 코드가 있는 것은 괜찮다.

### 8.4.2 비동기를 이용한 멀티스레딩

- 비동기 I/O는 리소스를 덜 소모하기 때문에 I/O가 많이 필요한 코드에서 멀티스레딩보다 더 나은 확장성을 제공한다
- 그러나 멀티스레딩과 비동기 I/O는 배타적인 것이 아니며 멀티스레드 코드 작성을 위해 비동기 프로그래밍 구문을 사용할 수도 있다.


- 비동기 프로그래밍은 일부 멀티스레드 작업을 더 쉽게 할 수 있도록 한다.
- 하지만 그렇다고 멀티스레드를 완전히 대체하는 것은 아니며 확장성에도 도움이 되지 않는다.

## 8.5 모놀리스를 존중하라

- 마이크로서비스의 문제점은 복잡성이 증가한다는 것이다.


- 모놀리스는 확장이 가능하다.


- 제품 개발의 초기 단계에서 인증, 조정, 동기화 등이 문제가 될 수 있는 경우 마이크로서비스로 새로운 프로젝트를 복잡하게 만들지 마라


- 모놀리스는 로컬 프로토타입에서 자연스럽게 다음 단계로 넘어가는 것이기도 하다.
- 마이크로서비스 아키텍처의 단점보다 장점이 클 때만 사용하는 것을 고려하라

## 8.6 요약

- 점진적으로 확장성에 접근하라
- 확장성의 가장 큰 블록 중 하나는 잠금이다.
- 잠금이 없는 데이터구조나 동시성 데이터 구조를 선호하라.


- 더 나은 확장성을 위해 불일치를 활용하는 법을 배워라


- CPU 바운드 작업의 병렬화를 위해 멀티스레딩을 사용하라

