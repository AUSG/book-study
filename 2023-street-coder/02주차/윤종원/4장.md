- [4장. 맛있는 테스트](#4--)
    - [4.1 테스트의 유형](#41--)
        - [4.1.1 수동 테스트](#411--)
        - [4.1.2 자동 테스트](#412--)
        - [4.1.3 위험을 감수하라: 프로덕션 환경에서의 테스트](#413-----)
        - [4.1.4 적합한 테스트 방법 선택하기](#414----)
    - [4.2 걱정을 멈추고 테스트를 사랑하는 법](#42-----)
    - [4.3 TDD와 같이 약어로 된 용어를 사용하지 마라](#43-tdd------)
    - [4.4 자신의 이득을 위해 테스트를 작성하라](#44-----)
    - [4.5 테스트 대상 결정하기](#45---)
        - [4.5.1 경계를 존중하라](#451--)
        - [4.5.2 코드 커버리지](#452--)
    - [4.6 테스트를 작성하지 마라](#46---)
        - [4.6.1 테스트를 작성하지 마라](#461---)
        - [4.6.2 모든 테스트를 작성하려고 하지 마라](#462-----)
    - [4.7 컴파일러가 코드를 테스트하도록 하라](#47----)
        - [4.7.1 널 검사를 제거하라](#471---)
        - [4.7.2 범위 점검을 제거하라](#472---)
        - [4.7.3 유효 값을 확인하는 로직에서 중복을 제거하라](#473------)
    - [4.8 테스트 이름 정하기](#48---)
    - [4.9 요약](#49-)

# 4장. 맛있는 테스트

- 개발자들이 테스트를 싫어하는 이유는 테스트를 소프트웨어 개발과 분리된 것으로 보기 때문이다
- 하지만 테스트는 코드 자체가 줄 수 없는 확신을 줄 수 있다

## 4.1 테스트의 유형

- 테스트가 소프트웨어의 동작을 완전히 보장하는 것은 아니지만, 그 가능성을 상당히 높여 준다.

### 4.1.1 수동 테스트

- 엔드 투 엔드 테스트의 가치는 크지만 그만큼 시간이 많이 소요된다
- 코드 리뷰는 효과가 보다 약하긴 하지만 테스트 방법 중 하나로 간주된다
- 테스트는 유형에 따라 다양한 수준의 확신을 가져다 줄 수 있다


- 코드 리뷰에서 가장 중요한 부분은 직접 고칠 필요 없이 코드를 비판할 수 있는 마지막 기회하는 것이다

### 4.1.2 자동 테스트

- 단위 테스트나 통합 테스트가 있다

### 4.1.3 위험을 감수하라: 프로덕션 환경에서의 테스트

- 프로덕션 환경에서 테스트하는 것은 나쁜 관행으로 간주된다
    - 오류로 인해 사용자나 고객을 잃을 수 있기 때문이다
- 하지만 항상 나쁜 것만은 아니다
- 자주 사용하지 않는 기능에 발생한 작은 고장이라면 최대한 빨리 위험을 감수하고 고치는 편이 나을 수도 있다

### 4.1.4 적합한 테스트 방법 선택하기

- 테스트 방법을 결정하려면 위험과 비용을 파악해야 한다


- 비용
    - 테스트 구현/실행에 얼마나 많은 시간이 필요한지
    - 테스트 코드가 변경되면 테스트할 줄 아는 사람이 있는지
    - 테스트를 신뢰할 수 있게 유지하는 것이 얼마나 어려운지
- 위험
    - 이 시나리오가 깨질 가능성은 얼마나 되는지
    - 깨졌을 때 얼마나 큰 영향을 주는지
    - 이 시나리오가 깨지면 얼마나 많은 시나리오가 함께 꺠지는지
    - 코드가 얼마나 자주 변경되는지


- 비용이 가장 적게 들면서 위험도 가장 적은 최적의 방법을 찾아야 한다
- 모든 위험은 더 많은 비용을 초래한다


- "내 컴퓨터에서는 잘 돌아간다"는 식의 사고방식은 배포와 피드백 루프 사이에 시간 지연을 유발하기 때문에 매우 느리고 시간을 낭비하는 사이클에 빠지게 만든다


- 자동화된 테스트는 기능의 완료에 대해 어느 정도 신뢰할 수 있게 될 때까지 우리가 영역에 있도록 해줌으로써 이 문제를 조금이나마 해결해 준다


- 테스트를 작성하는 것은 약간 불연속적인 활동으로 볼 수 있지만, 여전히 우리가 작성한 코드를 생각하게끔 한다

## 4.2 걱정을 멈추고 테스트를 사랑하는 법

- 단위 테스트의 단위에 대한 논쟁이 많지만 기본적으로 주어진 단위를 분리하여 테스트할 수 있다면 큰 문제가 되지는 않는다
- 모든 테스트는 단일 시나리오만을 테스트한다. 따라서 단일 함수를 여러 번 검사하는 것이 일반적이다


- 단위 테스트 프레임워크를 사용하면 다음과 같은 이점이 있다
    - 일부 테스트 실패를 찾아내기 쉽다
    - 일부 테스트가 실패하더라도 모든 테스트를 실행해볼 수 있다
    - 특정 테스트를 선택적으로 실행할 수 있다
    - 코드 커버리지를 확인할 수 있다
    - 일부 테스트를 병렬로 실행할 수 있다
    - 오류에 대한 자세한 보고를 받을 수 있다


- 많은 테스트 프레임워크는 서로 유사하다

## 4.3 TDD와 같이 약어로 된 용어를 사용하지 마라

- 단위 테스트에는 여러 종파가 있다. TDD, BDD


- TDD의 핵심은 실제 코드를 작성하기 전에 테스트를 먼저 작성하는 것이 더 나은 코드 작성을 이끌어 낸다는 것이다
- BDD 또한 테스트를 우선시하는 접근법이다


- 어떤 코드를 어떻게 테스트할지 생각하면 이는 코드 설계에 영향을 줄 수 있다
- 단지 TDD의 문제는 관습적인 접근에 있다
    - 코드를 작성하기 전에 테스트를 작성했을 때 수많은 오류는 개발자에게 그리 좋은 경험이 아니다


- 또한 프로덕션 코드보다 테스트 코드에 더 집중하는 일이 생길 수도 있다
- 코드를 작성하기 전에 테스트를 작성하면 매몰 비용의 오류가 발생한다


- 테스트는 코드를 변경하기 어렵게 만들지도 모른다
- 그러나 동시에 코드가 어떻게 돌아가는지 알게 되어 자신감을 갖게 되며, 코드를 더 쉽게 변경할 수 있으므로 이러한 단점은 상쇄된다
- 테스트 작성과 코드 변경 속도가 점점 빨라질 것이다.

## 4.4 자신의 이득을 위해 테스트를 작성하라

- 테스트 코드는 우리의 코드 설계 변경을 제한한다
- 테스트 코드를 나중에 작성하면 코드를 좀 더 유연하게 만들 수 있다.
- 이는 일종의 보험처럼 작동한다.


- 하지만 프로토타입 제작처럼 빠르게 반복해서 수정해야 하는 경우 테스트 때문에 의욕을 잃어서는 안 된다


- 좋은 프로토타입을 만든 후 테스트 코드를 작성하는 것은 설계를 위한 재연습이라고 볼 수도 있다.
- 테스트를 생각하면서 코드를 전체적으로 다시 한 번 검토한다


- 코드를 작성하기 전에 워밍업을 위해 누락된 테스트를 찾아서 추가하는 것도 좋다
- 중복되지 않는 한, 테스트가 더 많은 것은 결코 나쁘지 않다


- 테스트를 분명하고, 이해하기 쉽게 작성한 경우 테스트 코드 자체가 명세서 혹은 문서로서의 역할도 할 수 있다


- 테스트는 개발자가 깰 수 없는 코드와 명세 사이의 계약을 강요한다


- 버그를 고칠 때마다 테스트를 추가하면 버그를 다시 처리하지 않아도 될 것이다


- 좀 더 효율적인 개발자가 되기 위해 테스트를 작성하라

## 4.5 테스트 대상 결정하기

- 코드가 깨지는 경우 제대로 실패하는지, 가능한 모든 시나리오를 다루고 있는지, 등등이 중요하다
- 테스트가 버그를 찾는 데 도움이 되어야 한다


- 프로덕션 코드 중 일부를 수정하고 테스트가 실패하는지 보는 것도 좋은 방법이다


- 명세서가 있다면 이를 활용해서 테스트를 작성하면 되지만, 명서세가 있는 경우는 거의 없으므로 명세서를 직접 만드는 것이 더 합리적일 수 있다.

### 4.5.1 경계를 존중하라

- 모든 값을 테스트 할 수는 없다
- 코드 안의 로직이 분기되거나 오버플로가 일어나는 입력값을 확인한 다음 이 값을 중심으로 테스트해야 한다.


- 가장 좋은 방법은 명세서에서 테스트할 대상을 찾는 것이며, 명세서가 없다면 경계 조건부터 시작하는 것이다

### 4.5.2 코드 커버리지

- 코드 커버리지 100%를 달성할 수는 있지만 아직 빠진 테스트 사례가 있을 수 있다
- 코드 커버리즈는 좋은 도구지만, 실제 테스트 커버리지를 보여주는 데 완전히 효과적이지는 않다


- 코드 커버리지에만 의존해서 값을 채우려고 하지 말고, 가능한 모든 입력을 고려하고 경계 값을 현명하게 처리하면서 테스트 범위를 의식해야 한다

## 4.6 테스트를 작성하지 마라

### 4.6.1 테스트를 작성하지 마라

- 없는 코드를 테스트하지 마라
- 삭제된 코드에는 버그가 없다


- 이미 검증된 것이 분명한 코드를 또 다시 테스트하지 마라

### 4.6.2 모든 테스트를 작성하려고 하지 마라

- 테스트를 현명하게 선택하면 20%의 테스트 커버리지로 80%의 신뢰성을 얻을 수 있다
- 모든 코드 라인이 버그가 발생할 확률을 동일하게 가지는 것이 아니다.


- 실제 코드를 실행해보는 것만으로도 꽤 괜찮은 테스트다
- 이를 스모크 테스트(smoke test)라고 부른다


- 큰 차이가 없다면 테스트로 커버되지 않는 한 줄에 대한 테스트 커버리즈를 추가하기 위해 몇 시간을 소비하지 마라

## 4.7 컴파일러가 코드를 테스트하도록 하라

### 4.7.1 널 검사를 제거하라

- 컴파일러가 널 타입을 막아준다면 이에 대한 테스트를 하지 말아라
- 목적을 위해 특정 타입을 사용하면 테스트의 필요성이 줄어들 수 있다

### 4.7.2 범위 점검을 제거하라

- 특정 범위를 갖는 타입을 사용하면 범위에 대한 테스트를 컴파일러에게 맞길 수 있다
- 물론 때로는 다른 타입을 다루는 것보다 추가로 테스트를 작성하는 것이 더 유리할 때도 있다

### 4.7.3 유효 값을 확인하는 로직에서 중복을 제거하라

- 매개변수가 없으면 이에 대한 버그도 없고, 테스트할 필요도 없다
- 매개변수 대신 별도의 함수로 분리하면 테스트도 줄이고 의도도 더 잘 전달할 수 있다

## 4.8 테스트 이름 정하기

- 테스트의 이름이 정확하면 이를 명세서처럼 사용할 수 있다
- 테스트 이름에서 다음 항목을 구분할 수 있으면 좋은 이름이다
    - 테스트할 함수의 이름
    - 입력 및 초기 상태
    - 예상 동작


- 자신에게 가장 적합한 규칙을 선택하는 것이 가장 중요하다

## 4.9 요약

- 애초에 테스트 작성을 많이 하지 않음으로써 테스트 작성에 대한 경멸을 극복할 수 있다
- 합수 입력의 경계 값을 잘 분석하면 테스트 수를 크게 줄일 수 있다