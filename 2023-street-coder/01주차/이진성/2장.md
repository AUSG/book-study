## 2장 - 실용적인 이론

### 내부 데이터 구조

- 기본적인 데이터 구조가 실제로 운영체제 상에서 어떤 방식으로 올라가는지 설명한다.
- 문자열
    - 문자열은 불변임
    - 문자열의 연산 결과는 재할당으로 이뤄지고 이는 곧 가비지 컬렉터의 대상이 됨
    - 여러 문자열을 병합하기 위해서는 string builder를 사용하는것이 나음
        - 내부 연속 메모리 블럭을 이용해서 관리하기 때문에 재할당이 없음
    - 일반적인 상수 개의 다중 문자열 연산의 경우에는 compiler가 전용 메서드로 최적화 해줌
        - 분기가 들어가면 최적화 불가능
    - 문자열은 문화권에 따라 영향 받으므로 이를 고려해서 작성하는 것이 중요하다.
- 배열
    - 배열을 수정 불가능하게 만드는 것은 어렵고, 앱의 상태의 변수가 많아진 다는 것은 혼란을 야기하므로 적절한 컬렉션 인터페이스를 사용하는 것이 좋겠다.
- 리스트
    - 리스트와 같은 컬렉션 타입은 다형성을 이용하므로, 모든 함수의 호출 시에는 가상 호출을 통해 함수를 호출한다. 이는 약간의 오버헤드가 발생할 수 있다.
    - 로컬 스코프에서 컬렉션 타입이 필요한 경우에는 배열을 이용하는 것도 좋은 선택지일 듯
    - 크기를 미리 알 수 있으면 List의 크기를 미리 지정하는 것도 괜찮다.
    - 여기서 말하는 List는 ArrayList(Vector)에 가까운 녀석인 것 같다.
        - 리스트의 크기 증가시에 메모리 카피 후 확장을 한다고 한다.
- 연결 리스트
    - 추가 시에는 O(1), 탐색 시에는 O(N) 필요한 자료구조
    - 미리 할당이 없기 때문에 공간 최적화가 가능하다.
- 큐 : 리스트에서 삽입 순서대로 항목을 읽을 수 있다.
- 딕셔너리
    - 해시맵, 키/값으로 알려짐
    - 해시 키의 대한 매핑 테이블은 적게 생성하고 해시 값의 배열 길이를 나눈 나머지 값으로 할당한다.
    - 키 중복이 일어나면 해당 값을 동적으로 증가하는(?) 배열에 보관한다.
    - 해시 값을 다룰 때에는 고유하게 만들기 위해서 여러 속성을 결합하기도 해야한다.
        - 해시비트를 적절히 조합하기 위해서 시프팅을 이용할 수도 있다.
        - 16bit = organization / 16bit = repository
        - 언어에서 제공하는 함수를 그냥 사용하는 것이 낫다
        - AND XOR 등은 충돌 가능성이 있기 때문에 고려하지 않는 것 같음
- 해시 집합(Set)
- 스택
- 호출 스택
    - call stack은 함수의 변환 주소를 저장해 호출된 함수의 실해잉 완료되면 반환할 위치를 알려주는 데이터 구조.
    - 스레드 당 하나의 호출 스택을 가짐

### 타입에 대한 과대 포장?

- 소프트웨어 개발은 기본적으로 마라톤 경주와 같기 때문에 장기적인 관점에서 바라보는 것이 중요하다
- 동적 타입 언어는 느리고, 버그가 발생할 확률이 매우 높다
- 강한 타이핑 : 서로 다른 타입으로 대체할 수 없다
- 약한 타이핑 : 서로 다른 타입으로 대체할 수 있다.
- 강한 타이핑으로 스스로에게 제약을 만드는 이유는 더 안전하고 더 빠르고, 더 쉽게 유지보수하기 쉬운 코드를 작성하기 위함이다.

유효성 증명

- 효과적인 방법은 VO를 만들어서 코드 전반적으로 사용하는 방법이다.
    - 유의 점은 기본적인 scaffolding(equals, operator, hash code)등을 잘 구현해줘야한다.
    - 사실 이게 귀찮으면 값 객체 정의 data class / value class (on kotlin)을 사용하는 방법도 있다.

프레임워크를 똑똑하게 사용해라

- 사전에 정의된 타입들을 활용하면 문자열와 같은 값만 사용하는 것보다 훨씬 효율적이고 안전하게 코드를 작성할 수 있다.

오타 이상의 타입

- 코드를 적당한 위치로 옮기고, 타입을 사용하여 이해하게 쉽게 만드는 것이 주석을 작성하는 것보다 효율적이다.

nullable이 아니라 non-nullable 했어야 한다!

- 그냥 nulltable<T>를 사용하는 토픽이였다.
- 그리고 nullable 한 상태보다는 non-nullable한 상태가 장기적으로는 더 이득이고 boilerplate코드를 줄이기 위해서는 record (data) class등을 이용을 하는 것도 하나의 방법이다.

무료 성능향상

- 적절한 타입을 이용하면 공간 효율성이 높아질 수 있다. 약간의 구문 분석을 위한 성능을 지불하면 말이다.

참조 타입 대 값 타입

- 갓갓 .NET에서는 자바와 다르게 커스텀 값 타입을 사용할 수 있다.
- 구조체는 항상 복사되기 떄문에 비교적 오버헤드가 발생할 수 있다.
- 값타입은 참조 타입보다 접근 속도가 빠르다. (당연하게도)