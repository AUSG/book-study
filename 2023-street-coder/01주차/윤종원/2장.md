- [2장. 실용적인 이론](#2--)
    - [2.1 알고리즘 특강](#21--)
        - [2.1.1 빅오를 더 잘 이해하면 좋다](#211-----)
    - [2.2 내부 데이터 구조](#22---)
        - [2.2.1 문자열](#221-)
        - [2.2.2 배열](#222-)
        - [2.2.3 리스트](#223-)
        - [2.2.4 연결 리스트](#224--)
        - [2.2.5 큐](#225-)
        - [2.2.6 딕셔너리](#226-)
        - [2.2.7 해시 집합](#227--)
        - [2.2.8 스택](#228-)
        - [2.2.9 호출 스택](#229--)
    - [2.3 타입에 대한 과대 포장은 무엇인가?](#23-----)
        - [2.3.1 타입에 강해지기](#231--)
        - [2.3.2 유효성 증명](#232--)
        - [2.3.3 무조건 프레임워크를 사용하지 말고 똑똑하게 활용하라](#233------)
        - [2.3.4 오타 이상의 타입](#234---)
        - [2.3.5 nullable이 아니라 non-nullable이라 했어야 한다](#235-nullable--non-nullable--)
        - [2.3.6 무료 성능 향상](#236---)
        - [2.3.7 참조 타입 대 값 타입](#237-----)
    - [2.4 요약](#24-)

# 2장. 실용적인 이론

- 컴퓨터 과학 이론은 압도적이고 연관성이 없다고 느낄 수 있다
    - 그런데 왜 이론에 신경을 써야 할까?
    - 알고리즘, 데이터 구조를 언제 사용해야 할지를 정확하게 알려준다
    - 결정하기 어려운 트레이드 오프 상황에 비용을 고려할 때 도움이 되며, 작성 중인 코드의 확장성을 이해하는 데도 도움이 된다
- 알고리즘은 처음부터 구현하지 않는 것이 좋다

## 2.1 알고리즘 특강

- 알고리즘은 우리의 필요에 맞게 작동하면 그만이다
    - 어떤 기적을 행할 필요는 없다
- 물론 더 똑똑한 알고리즘이 있을 수 있다

### 2.1.1 빅오를 더 잘 이해하면 좋다

- 확장성을 이해하는 것은 개발자가 갖춰야 할 중요한 기술이다
- 알고리즘의 실행 속도와 메모리 사용량이 증가하는 것을 빅오 표기법으로 제대로 설명할 줄 알아야 데이터 구조와 알고리즘을 잘 선택할 수 있다

## 2.2 내부 데이터 구조

- 데이터 구조는 데이터를 어떻게 배치하는지에 대한 것이다
- 데이터를 어떤 방식으로 배치하는가에 따라서 데이터가 더 유용해질 수 있다


- 대체로 데이터를 어떻게 배치하냐에 따라 작업을 더 빠르고 효율적으로, 혹은 그 반대로 만들 수 있다

### 2.2.1 문자열

- StringBuilder를 사용하면 문자열 연산을 효율적으로 처리할 수 있다
    - Java의 경우 자동으로 `a + b + c` 정도의 연산은 컴파일러가 바꿔주지만 더 복잡한 경우는 사람이 손으로 해야한다
- 문자열을 늘릴 때마다 메모리를 재할당하고 복사하는 대신, 내부적으로 연속 메모리 블록을 사용해 효율적이다


- 일반적으로 불변 구조를 수정하는 것은 권장하지 않는다
- 내부적인 구현은 불변성의 특징에 크게 의존한다


- 모든 언어가 동일한 소문자를 가지고 있는 것은 아니다

### 2.2.2 배열

- 배열은 배열 크기를 초과하지 않는 개수만큼의 여러 항목을 저장하는데 유ㅛㅇ하다
- 배열을 불변으로 만드는 것은 어렵

- 절대적으로 필요한 경우가 아니라면 스스로 상태를 바꾸도록 놔둬서는 안 된다


- 목적에 맞는 가장 작은 기능을 가진 타입을 고수하도록 노력하라
- 배열은 함수의 로컬 스코프 안에서 사용하기에 가장 적합하다

### 2.2.3 리스트

- 거의 모든 곳에서 배열 대신 리스트를 사용할 수 있지만 불필요한 성능 저하가 발생할 것이다


- 가상 호출은 가상 메서드 테이블에서 추가로 조회해야 하므로 일반 함수 호출보다 약간 느리다
    - 이런 호출이 알고리즘 내부에 포함되어 있으면 오버헤드가 꽤나 증가할 수 있다


- 특정 작업에 적합한 클래스르 사용하는 것이 일반적인 클래스보다 효율적이다


- 전체 용량을 잘 설정하면 리스트로도 좋은 성능을 얻을 수 있다
- 하지만 아무 이유 없이 지정하지는 말자
- 정확히 알고 나서 결정을 내리자

### 2.2.4 연결 리스트

- 연결 리스트가 항상 일반 리스트보다 빠른 것은 아니다
- 전체 메모리 블록을 한 번에 할당하는 것이 아니라, 개별적으로 할당한다면 성능이 저하될 수 있다


- 현재는 자주 사용할 일이 많지는 않지만 `O(1)` 복잡도를 가져 운영체제 커널에서는 자주 사용된다

### 2.2.5 큐

- PC 키보드 버퍼에 큐 사용했었다

### 2.2.6 딕셔너리

- 딕셔너리의 내부 구조를 잘 알고 있어야 성능이 저하되는 일을 피할 수 있다


- 키-값 쌍을 단순히 순차적으로 검사해야 한다면 딕셔너리는 아무런 이점도 없다
- 차라리 `List<KeyValuePair<K, V>>`가 더 좋다

### 2.2.7 해시 집합

- 고유한 값을 저장할 수 있다는 점 제외하고 배열이나 리스트와 같다
- 단지 항목 검사를 할 때 더 빠를 수 있다

### 2.2.8 스택

- 스택이다

### 2.2.9 호출 스택

- 호출 스택(call stack)은 함수의 반환 주소를 저장해 호출된 함수의 실행이 완료되면 반환할 위치를 알려주는 데이터 구조다


- 이전의 유닉스 시스템에서는 프로세스가 애플리케이션 리소스를 위한 컨테이너이자 실행 단위였다
- 이런 방식은 단순하면서도 훌륭했지만 좀비 프로세스와 같은 문제를 야기했다
- 스레드는 실행 수명과 바로 연결되기 때문에 좀 더 가벼우며 이러한 문제가 없다


- 스택은 크기가 고정되었지만 빠르고 매우 효율적이다
    - 할당 및 할당 해제와 같은 추가적인 메모리 관리 단계가 필요하지 않다


- 값 타입은 복사로 전달되지만 로컬로 선언된 경우에만 스택에 존재한다

## 2.3 타입에 대한 과대 포장은 무엇인가?

- 동적 타이핑 언어는 코드 작성 속도 자체는 빨라지지만 우리는 코드를 유지하는 관점도 고려해야 한다
- 소프트웨어 개발은 단거리 경주가 아닌 마라톤과 같다


- 데이터 타입은 코딩 과정에서 발생할 수 있는 어려움을 초기에 방어할 수 있는 수단 중 하나다
- 타입은 더 큰 부담이 되기 전에 일찍 실패를 경험하고 그 실수를 고칠 수 있게 해준다

### 2.3.1 타입에 강해지기

- 타입은 코드의 정확도를 무료로 검사해주므로 생산적인 프로그래밍에 도움이 된다
- 파이썬, JS와 같은 인터프리터 방식은 변수가 유연한 타입을 갖는다
    - 타입을 따로 선언하지 않아도 되므로 코드를 훨씬 빨리 작성할 수 있다
- 컴파일 방식의 경우 더욱 엄격하다
    - 하지만 언어에 땨라서 엄격한 정도가 다르다


- 강한 타이핑(strong typed)와 약한 타이핑(weakly typed)는 프로그래밍 언어가 얼마나 관대한지를 의미한다


- 타입을 통해 더 안전하고 빠르게, 쉽게 유지보수할 수 있는 코드를 작성할 수 있다
- 변수 타입을 선언하고, 클래스에 주석을 달아서 시간을 손해보더라도, 디버깅할 버그가 줄어들고 성능 문제가 덜 발생하기 때문에 잃어버린 시간은 금방 만화할 수 있다

### 2.3.2 유효성 증명

- 데이터의 유효성 검사는 코드 전반에 걸쳐 유효성을 증명하는 것이 아니다
    - 어떤 곳에선 유효성 검사를 하고, 어떤 곳에선 하지 않을 수도 있다
- 결국 코드 여러 부분에서 입력에 대한 전반적인 유효성 검사를 할 수밖에 없다
- 또한 유효성 검사가 얼마나 일관성이 있는지 확인해야 한다


- 타입은 유효성 검사를 넘겨줄 수 있다
    - 생성 단계에 입력을 검증하는 클래스나 구조체를 전달할 수 있으므로 유효하지 않은 값이 포함되는 것은 불가능하다


- 물론 이러한 타입을 만들면 부가적인 코드를 추가해야 한다
    - 몇몇 함수를 오버라이드하고, 연산자 오버로딩을 해야할 수도 있다
    - 정렬이 필요하다면 또 추가적인 함수를 구현해야 한다


- 유효성 컨텍스트를 활용하기 위해 항상 새로운 타입을 생성할 필요는 없다
- 상속을 활용하면 공통적인 규칙을 갖는 원시 타입을 포함하는 기본 타입을 생성할 수 있다
- 또한 코드 상에서 타입 간의 차이를 쉽게 구분할 수 있고, 잘못된 타입을 전달하는 것을 막을 수 있다


- 물론 이러한 방법이 항상 옳은 것은 아니며 사용하지 않아야 할 때가 언제인지도 알아야 한다


- 사용자 정의 데이터 타입은 원시 타입보다 설계를 더 잘 설명할 수 있고, 반복적인 유효성 검사를 피할 수 있으므로 버그 예방에도 도움이 된다
- 번거롭더라도 구현할 가치가 있다

### 2.3.3 무조건 프레임워크를 사용하지 말고 똑똑하게 활용하라

- 문자열로 일을 처리하기 시작하면 그럴 필요가 없는 경우에도 문자열 처리 함수로 모든 것을 처리하려 하는 경향이 생긴다
- 문자열 대신 특정 타입을 잘 활용하면 성능도 챙기면서 더욱 쓰기 좋은 코드를 만들 수 있다


- 시간 혹은 기간 처리는 매우 복잡하기 때문에 제공되는 타입을 활용하는 것이 좋다

### 2.3.4 오타 이상의 타입

- 열거형은 클래스의 상수 값과 달리 전달될 수 있는 값을 제한하고 고유한 타입의 이름을 사용하므로 의도를 설명하기에 더 좋다
- 타입을 잘 활용하면 코드를 더욱 서술적이게 만들 수 있다

### 2.3.5 nullable이 아니라 non-nullable이라 했어야 한다

- 컴파일러가 제공하는 nullable 타입을 잘 활용하면 도움이 된다
    - 또한 컴파일러의 경고나 오류를 통해 설계의 결함을 수정할 수도 있다


- 인간은 예측에 형펀없다
- 다만 코드에 어느 부분에 버그가 얼마나 많이 발생할지 예상하는 일종의 직관이 필요하다
- 무슨 제안이든 맹목적으로 따라서는 안 된다
- 나중에 코드가 얼마나 변화할지에 대한 감각을 가져야 한다
    - 코드가 많이 바뀔수록 버그는 더 쉽게 생길 것이다

### 2.3.6 무료 성능 향상

- 프로토타입 작성할 때는 성능을 우선으로 고려할 필요는 없지만 데이터 타입, 데이터 구조, 알고리즘의 성능 특성을 기본으로 이해하고 있다면 성능을 더 높이는 방향으로 나아갈 수 있다


- 적절한 데이터 구조를 잘 활용하면 유효성 검사에 대한 부담, 타입으로 인한 가독성 향상 등에 도움이 될 수 있다


- 성능과 확장성은 단일 차원의 개념이 아니다
- 어떤 작업에 특정 유형을 사용하고 데이터에 특화된 유형을 사용하는 것은 대부분 아주 쉬운 일이다

### 2.3.7 참조 타입 대 값 타입

- 참조 타입과 값 타입의 차이는 타입이 메모리에 저장되는 방식과 꽤 관련이 있다
- 값 타입의 실제 변수는 호출 스택에 저장되는 반면, 참조 타입은 힙에 저장되고 실제 값에 대한 참조만 호출 스택에 저장된다


- 참조 타입과 값 타입의 차이를 안다면 올바른 작업에 올바른 타입을 사용할 수 있으므로 좀 더 효율적인 프로그래머가 될 수 있다


- 실제 데이터 대신 포인터를 사용할 때의 장점은 불필요한 중복을 방지한다는 것
    - 하지만 포인터로 값을 참조하는 행위는 값 타입에 바로 접근하는 것보단 느리다


- 구조체는 클래스와 비슷하지만 항상 값으로 전달된다
- 값타입은 스토리지와 성능에서 참조 타입보다 효율적이기 때문에 존재한다

## 2.4 요약

- 타입은 코드를 덜 작성하기 위해 사용될 수 있다
- 타입을 사용하면 코드를 더 쉽게 설명할 수 있고, 따라서 주석을 덜 작성해도 된다
- 배열은 빠르고 편리하지만 공개적으로 노출된 API에 가장 적합한 후보는 아닐 수 있다

