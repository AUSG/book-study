- [3장 유용한 안티패턴](#3--)
    - [3.1 깨지 않았다면 깨버려라](#31---)
        - [3.1.1 코드 경직성에 맞서라](#311---)
        - [3.1.2 빠르게 옮기고 깨버리자](#312---)
        - [3.1.3 경계를 존중하라](#313--)
        - [3.1.4 공통적인 기능을 분리하라](#314---)
        - [3.1.5 예제 웹 페이지](#315---)
        - [3.1.6 빚을 지지 마라](#316---)
    - [3.2 처음부터 다시 작성하라](#32---)
        - [3.2.1 지우고 다시 써라](#321---)
    - [3.3 코드가 멈추지 않았어도 개선하자](#33----)
        - [3.3.1 미래를 향한 경주](#331---)
        - [3.3.2 코드를 깔끔하게 만드는 것은 작성하는 것만큼 중요하다](#332-------)
    - [3.4 스스로 반복하라](#34--)
        - [3.4.1 재사용 대 복사](#341---)
    - [3.5 지금 새로운 것을 시도하라](#35----)
    - [3.6 상속을 사용하지 마라](#36---)
    - [3.7 클래스를 사용하지 마라](#37---)
        - [3.7.1 열거형은 맛있다!](#371--)
        - [3.7.2 구조체는 아주 좋다!](#372---)
    - [3.8 불량 코드를 작성하라](#38---)
        - [3.8.1 If/Else를 사용하지 마라](#381-ifelse--)
        - [3.8.2 goto를 사용하라](#382-goto-)
    - [3.9 코드 주석을 작성하지 마라](#39----)
        - [3.9.1 이름을 잘 선택하라](#391---)
        - [3.9.2 함수를 활용하라](#392--)
        - [3.10 요약](#310-)

# 3장 유용한 안티패턴

- 프로그래밍 책을 보다 보면 모범 사례나 디자인 패턴이 많다
- 이것은 시간이 흐르면서 신념처럼 변해버려 사람들이 내용을 의심 없이 받아들이게 한다


- 정설로 여기는 불변의 법칙은 우리에게 사가지대를 가져오고, 우리가 이 신념을 오래 고수할수록 사각지대의 크기는 더 커진다
- 이러한 사각지대는 우리가 특정 사용 사례에 더 유용할 수 있는 기술을 찾지 못하게 만들 수 있다


- 모법 사례와 우수한 디자인 패턴을 사용했을 때 도움이 되는 경우와 도움이 되지 않는 경우를 잘 이해해야 한다

## 3.1 깨지 않았다면 깨버려라

- 회귀는 많은 시간을 잃게 만든다. 회귀를 피하고 코드를 지키는 것이 합리적이다
- 하지만 코드를 변경하지 않고 그대로 두면 더 많은 코드가 필요할 수 있으며, 결국 유지보수해야 하는 코드의 양만 증가시킬 뿐이다


- 변화에 대한 기존 코드의 저항을 코드 경직성(code rigidity)라고 한다
- 코드가 더 경직될수록 이 코드를 조작하기 위해 더 많은 코드를 깨버려야 한다는 것을 의미한다

### 3.1.1 코드 경직성에 맞서라

- 너무 많은 종속성은 코드 경직성의 요인 중 하나다


- 이상적으로는 가능한 한 종속성을 작게 유지해야 한다. 이는 구성 요소 또는 전체 계층을 최대한 단순하게 유지하기 위한 중요한 요소다
- 하지만 우리는 종속성을 피할 수 없으며, 코드를 재사용하려면 종속성은 필수적이다


- 종속성 체인을 잘 구분하여 관리한다면 코드 재사용으로 인한 종속성은 문제가 없다

### 3.1.2 빠르게 옮기고 깨버리자

- 서로 엵혀 있는 의존성이 코드의 경직성을 유발하여 변화에 저항성을 갖게 한다
- 초반에 종속성을 끊는 것이 더 쉽기 때문에 당장 코드가 잘 동작하더라도 이러한 문제를 인식하고 코드를 깨야 한다


- 종속성이 없는 구성 요소를 수정하는 것이 가장 쉽다
- 종속성은 일종의 계약을 의미하기 때문에 약간의 경직성이 발생한다


- 코드를 더 많이 재사용할수록 시간을 더 많이 절약할 수 있다고 생각하지만 이에 대한 대가도 고민해봐야 한다

### 3.1.3 경계를 존중하라

- 의존성에 대한 추상화 경계를 넘어서는 안 된다
- 추상화 경계를 넘으면 추상화의 장점이 사라진다
- 결국 불필요한 책임과 부담만 늘어난다


- 경계 문제를 만나면 코드를 깨버려 위반 요소를 제거하고, 코드를 리팩토링 해 처리해야 한다
- 코드를 깰 위험이 있더라도 방심하지 말고 즉시 차단해야 한다
- 코드가 깨지는 것을 두려워한다면 그것은 잘못 설계된 코드다
- 좋은 코드는 깨지지 않는다는 뜻이 아니다
- 깨졌을 때 조각을 다시 붙이는 것이 훨씬 더 쉽다

### 3.1.4 공통적인 기능을 분리하라

- 코드를 리팩터링하면 더 많은 버그가 생길 수도 있다
- 하지만 이는 코드가 작동을 멈춘 것이 아니라 이미 그곳에 있던 버그가 이제서야 발견된 것이다


- 계층을 잘 분리하면 각 계층을 더욱 쉽게 테스트할 수 있다

### 3.1.5 예제 웹 페이지

### 3.1.6 빚을 지지 마라

- 기술 부채란 마감일을 맞추기 위해 불리한 결정을 내렸던 과거의 순간에 발생한 혼란 때문에 다음 마감일을 맞추기가 더욱 어려워지는 것이다


- 기술 부채는 우리가 의식하고 있는 결정이다
- 무의식적인 것은 기술적인 미숙함(technical ineptitude)라고 부른다


- 다양한 이유로 기술 부채가 쌓일 수 있다
- 모든 사소한 잘못된 결정이 팀의 발목을 잡을 것이다
- 이는 게으름을 잘못 피워서 실패를 자초하는 것이다
- 제대로 된 게으름을 피우자


- 기술 부채를 다루는 가장 좋은 방법은 당분간 미루는 것이다
- 코드의 경직된 부분을 확인하고, 세분화된 유연성을 확보하는 기회로 삼자
- 문제를 해결하고 코드를 수정한 다음에 아직 충분히 제대로 동작하지 않는다고 생각되면 모든 변경 내용을 취소하자

## 3.2 처음부터 다시 작성하라

- 코드를 변경하는 것이 위험하면 처음부터 작성하는 것은 훨씬 더 위험하다
    - 결국 모든 상황을 처음부터 다시 만나면서, 하나하나 수정해나가야 한다
- 따라서 설계 결함을 해결하는 데 있어 비용적은 측면이 매우 떨어지는 방법이다


- 하지만 이도 이미 코드가 잘 돌아가는 경우에 해당되는 이야기다
- 이미 작업하는 코드를 처음부터 새로 시작하는 것은 큰 문제가 되지 않는다
    - 오히려 이미 작성한 코드를 아까워 하는 매몰 비용의 오류에 빠질 수 있다
- 결국 설계는 프랑켄슈타인처럼 아이디어와 코드가 함게 뒤섞인 괴물이 된다

### 3.2.1 지우고 다시 써라

- 처음부터 다시 작성하는 것은 생각보다 빠르다
- 처음부터 다시 시작할 때는 이전보다 훨씬 더 이른 시점에 잘못된 곳으로 가고 있음을 깨달을 수 있다
- 프로그래밍도 반복할수록 더 잘하게 된다

## 3.3 코드가 멈추지 않았어도 개선하자

- 코드의 경직성을 해결하는 방법 중 하나는 코드가 굳지 않도록 계속 휘젓는 것이다
- 좋은 코드는 변경하기 쉬워야 하며, 필요한 부분을 변경하기 위해 수천 곳을 변경하지 않아도 되는 코드다
- 당장 변경할 필요가 없는 코드라고 해도 장기적으로 도움이 될 수 있다면 변경해야 한다
- 변경하기 어려운 가장 경직된 부분을 정기적으로 확인하는 습관이 있으면 좋다

### 3.3.1 미래를 향한 경주

- 패키지를 점진적으로 업그레이드 해 최신 상태를 유지하는 것이 정말 필요할 때 업그레이드하는 것보다 나을 수도 있다


- 정기적으로 패키지를 최신 상태를 유지하면 유지보수 하는 동안 버전 업그레이드에 대한 수고를 분산시킬 수 있으며, 사소한 업그레이드가 우리의 코드에 영향을 주면서 이를 고치게 되고, 이 과정 속에서 우리의 설계와
  코드가 개선될 수 있다


- 작은 문제를 미리 발생시켜 처리하면 나중에 커다란 문제가 생기는 것을 방지할 수 있다

### 3.3.2 코드를 깔끔하게 만드는 것은 작성하는 것만큼 중요하다

- 모든 것은 변한다. 코드는 계속 바뀐다
- 어차피 일어날 일이므로 변화를 두려워해서는 안 된다
- 작업중인 코드를 개선하는 것을 주저하지 말아야 한다


- 코드가 살아있도록 하라
- 코드에 변화를 많이 줄수록 코드 변경에 대한 저항력이 줄어들 것이다
- 코드를 수정하면 고장이 발생하고, 고장으로 취약한 부분을 인지하고 관리하기 쉽게 만들 수 있다
- 어떠한 변화가 가장 덜 위험할지에 대해 판단할 수 있는 선천적인 감각이 생길 것이다


- 코드를 수정할 때는 살짝이라도 나아지는 부분이 있어야 한다


- 코드를 개선하려고 했지만 오히려 더 나쁜 설계가 될 수도 있다
- 코드를 능숙하게 다루기 위한 유일한 방법은 코드를 많이 바꿔보는 것이다


- 다른 사람에게 영향을 줄 수 있는 변경 사항을 다루면서 동료와 소통하는 법도 배울 수 있다
- 좋은 의사 소통은 소프트웨어 개발을 향상시킬 수 있는 가장 큰 기술이다


- 변경한 내용에 대해 팀에서 문제가 없다면 이를 공유해라
- 아무리 작은 변화라도 개선에 대한 만족감은 더 큰 변화를 만드는 동기 부여가 되어줄 것이다

## 3.4 스스로 반복하라

- 복붙 대신 공유 클래스를 사용할 수도 있다
- 하지만 이것이 항상 옳은 방법은 아니다
- 이는 새로운 종속성을 생성하며, 종속성이 설계에 영향을 미친다


- 공유 코드를 사용하는 부부남다 요구 사항에 차이가 있다
- 공유 코드가 여러 요구 사항을 충족시키도록 선택적 매개변수나 조건부 논리를 추가한다
- 어느 시점부터는 복붙 코드보다 더 복잡해진다


- 함수 이름은 호출하는 쪽이 아니라 상황에 따라 설명할 수 있어야 한다


- 모든 로직을 동일한 코드에 병합하는 대신, 약간의 반복이 있는 코드로 별도의 함수를 만들면 사용 사례마다 별도의 함수를 가지게 된다

### 3.4.1 재사용 대 복사

- 어떻게 결정할까?
- 호출자의 요청을 어떻게 프레임화할 것인지, 요구 사항이 무엇인지 살펴봐야 한다
- 요구 사항에 차이는 위험 신호로 봐야 한다


- 이름은 가능한 한 짧으면서 동시에 모호하지 않아야 한다


- 함수는 여러 일을 처리하지만, 결국 작업 하나만 수행해야 한다


- 함수 이름에 `and`나 `or`를 사용해야 한다고 느낀다면 함수 이름을 잘못 정했거나 함수에 너무 많은 책임을 부여한 것이다

## 3.5 지금 새로운 것을 시도하라

- 모든 것을 직접 만드려고 하는 것은 엄청난 시간 낭비다
- 하지만 모든 것을 재사용하는 것이 표준이 되어 더이상 무언가를 만드는 것이 불가능해지는 것도 문제다
- 이는 아무것도 발명하지 마라는 신념으로 바뀐다
- 무언가를 발명하는 것을 두려워해서는 안 된다


- 질문하는 사고방식을 갖지 못한 사람은 자신의 일을 최적화하는 것은 불가능하다


- 자신이 만든 추상화 역시 일종의 발명품이다


- 특정 라이브러리를 사용하면 해당 라이브러리의 API에 얽매이게 된다
- 이러한 문제를 다루는 방법은 새로운 것을 발명하는 것이다
- 인터페이스를 생각하고, 이를 라이브러리 앞에 추상화로 놓는다


- API는 요구사항에 맞게 최대한 단순해야 한다
- 스스로 자신이 고객이라 생각해보자


- 직접 API를 만들면 자신이 고객이 되므로 요구에 맞게 설계하는 특권을 누릴 수 있다


- 모든 것을 처음부터 재작성하지는 마라. 하지만 발명가의 사고방식에서 벗어나지도 마라

## 3.6 상속을 사용하지 마라

- OOP에서 가장 강조된 특징은 상속이었다
- 장기적으로 볼 때 상속은 해결한 것보다 더 많은 문제를 야기했다


- 다중 상속보다 더 큰 문제는 강한 결합(tight coupling)이라고 알려진 강한 종속성이다
- 상속의 고유한 특성 때문에 어떤 구체적인 구현에 얽매이게 되는데, 이는 DIP를 어긴다


- 구체적인 구현에 얽매이면 코드가 경직된다


- 따라서 상속 대신 합성을 사용하면 된다
- 합성은 종속성을 외부에서 주입받을 수 있으므로 관계가 조금 더 유연해진다


- 상속 대신 합성을 사용하면 훨씬 더 많은 코드를 작성해야 하지만 종속성에서 벗어나 코드를 자유롭게 만들 수 있다

## 3.7 클래스를 사용하지 마라

- 클래스는 참조를 통해 접근되므로 작은 간접적인 오버헤드를 발생시킨다
- 따라서 이러한 타입의 장단점을 잘 파악하고 있어야 한다

### 3.7.1 열거형은 맛있다!

- 하드 코딩된 값은 사람이 기억하지 못하며, 값이 바뀌었을 때 문제가 생길 수 있으며, 의도를 파악하기 어렵다


- 상수 대신 열거형을 사용하면 타입 구별을 통해 타입 안정성이 보장된다
- 또한 값타임만큼 빠르다

### 3.7.2 구조체는 아주 좋다!

- 클래스는 약간의 스토리지 오버헤드가 있다
- 하지만 구조체는 스택에 값으로 저장되며, 가비지 컬렉션의 대상이 아니다


- 스택은 정리가 빠르고 자동이므로 매우 효율적이다
- 또한 후입선출 특성 덕분에 메모리가 단편화될 가능성도 없다


- 하지만 스택 크기는 제한적이다
- 또한 값이 복사되는 오버헤드도 고려해야 한다


- 구조체는 항상 불변으로 만드는 것이 좋다


- 대신 클래스는 구조체보다 훨씬 더 유연하므로 상황에 맞는 적절한 타입을 사용해야 한다

## 3.8 불량 코드를 작성하라

- 모법 사례를 맹목적으로 적용하다 보면 코드를 망칠 수도 있다

### 3.8.1 If/Else를 사용하지 마라

- 최대한 빠르게 함수를 종료하면 불필요한 들여쓰기를 방지할 수 있다
- 이를 행복한 경로 따라가기(following the happy path)라고 부른다
    - 코드에서 행복한 경로는 다른 문제가 없을 때 실행되는 코드를 의미한다


- 초반에 유효성을 확인하고 최대한 빨리 반환하라
- 예외적인 경우를 if 안에 넣고, 우리가 원하는 행복한 경로를 블록 밖에 놓도록 노력하라

### 3.8.2 goto를 사용하라

- goto를 잘 활용하면 함수에서 중복되는 종료 지점을 잘 제거할 수 있다
- 즉, 이해하기 쉬운 방식으로 goto 구문을 사용하면 시간을 아끼면서 동시에 버그가 덜 발생하도록 하는 것이 가능하다


- C#에는 이를 위해 로컬 함수를 도입했다
    - 다른 언어에는 `defer`가 있는 경우도 있다

## 3.9 코드 주석을 작성하지 마라

- 불필요한 주석은 오히려 코드의 가독성을 해칠 수 있다

### 3.9.1 이름을 잘 선택하라

- 가끔은 평소보다 긴 이름을 사용해야 할 수도 있지만, 보통은 간결하면서도 괜찮은 이름을 만들 수 있다


- 잘 알려진 약어는 괜찮지만 인반적인 단어를 줄여서는 안 된다

### 3.9.2 함수를 활용하라

- 함수가 작을수록 더 이해하기 쉽다
- 함수에 빈 줄을 사용하여 관련 구문을 함께 묵을 수도 있다


- 함수의 로직이 있는 부분을 구분하면 해당하는 부분을 의미 있는 함수로 리팩터링할 수 있다
- 이는 작은 함수와 설명적인 코드를 만들어준다


- 함수 추출은 주석 쓰는 것보다 일이 쉽다


- 불필요한 주석을 줄이는 것은 주석을 유용하게 만드는 유일한 방법이다


- 공용 API처럼 사용자가 코드에 접근할 수 없는 경우 주석이 유용한지 여부에 관계없이 주석을 작성해야 하는 경우가 있다
- 그렇다고 주석이 코드를 이해하기 쉽게 만드는 것은 아니다
- 작고 이해하기 쉬운 깨끗한 코드를 작성해야 한다

### 3.10 요약

- 처음부터 다시 작성하는 것을 두려워하지 마라. 다음엔 더 빨리 작성할 수 있다
- 위에서 아래로 읽기 쉬운 코드 스타일을 유지하도록 노력하라
- 시시하고 중복적인 코드 주석을 피하라

