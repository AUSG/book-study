- [1장. 거리로](#1-)
    - [1.1 길거리에서 중요한 것](#11---)
    - [1.2 누가 스트리트 코더인가?](#12---)
    - [1.3 훌륭한 스트리트 코더](#13---)
        - [1.3.1 질문하기](#131-)
        - [1.3.2 결과 중심적](#132--)
        - [1.3.3 높은 처리량](#133--)
        - [1.3.4 복잡성과 모호성 수용](#134---)
    - [1.4 최근 소프트웨어 개발의 문제점](#14----)
        - [1.4.1 너무 많은 기술](#141---)
        - [1.4.2 패러다임의 패러글라이딩](#142--)
        - [1.4.3 기술의 블랙박스](#143--)
        - [1.4.4 오버헤드 과소평가](#144--)
        - [1.4.5 내 일이 아니다](#145---)
        - [1.4.6 시시해 보이는 일도 도움이 될 수 있다](#146-------)
    - [1.5 이 책에서 다루지 않는 것](#15-----)
    - [1.6 주제](#16-)
    - [1.7 요약](#17-)

# 1장. 거리로

## 1.1 길거리에서 중요한 것

- 일을 얼마나 빨리하는 지도 중요하다
- 직관과는 다르게 좋은 설계, 좋은 알고리즘, 좋은 품질의 코드는 속도에 상당한 영향을 준다
    - 팀에서는 각 사람의 처리량보다 팀의 처리량이 더 중요하다
    - 나쁜 코드는 동료들의 속도를 늦춘다


- 좋은 디자인 패턴이나 좋은 알고리즘은 속도를 빠르게 만들 수 있다
    - 이에 도움이 되지 않는다면 사용할 필요가 없다

## 1.2 누가 스트리트 코더인가?

- 학교는 정해진 교육 과정을 따르므로 이 분야에서 어떤 과목이 얼마나 유용한지 알 수 없다
- 완벽하게 설계한 추상화라도 끊임없이 요구 사항을 변경하는 고객의 압박에 무너질 수 있다
- 이론이 항상 실용적인 것은 아니다


- 스트리트 코더는 개발 경험을 가진 업계의 모든 사람을 의미한다
    - 이들은 불합리한 현실 속에서 그들의 신념과 이론을 쌓아왔다

## 1.3 훌륭한 스트리트 코더

- 훌륭한 소프트웨어 개발자는 단순히 훌륭한 코더가 아니다
- 코드를 짜는 것 외에도 수많은 기술을 보유해야 한다
    - 의사소통을 잘하고, 건설적인 피드백을 제공하고, 비판도 받아들일 줄 알아야 한다

### 1.3.1 질문하기

- 질문하는 사람이 되어 스스로에게 질문하고, 당연시되는 것에도 질문하다보면 각자의 비전이 명화해질 것이다
- 기술에 대한 비평이 그 기술이 쓸모없다는 것을 의미하지는 않는다
    - 단지 다른 기술이 실제로 더 나을 수 있다는 사용 사례를 판별할 수 있을 정도로 시야를 넓힐 수 있다

### 1.3.2 결과 중심적

- 최종 제품을 만들려면 마감일과 그 사이의 이정표도 달성해야 한다


- 결고를 얻는 것은 코드 품질이나 우아함, 기술적 우수성의 희생을 의미할 수도 있다
- 중요한 것은 이런 관점을 가지는 동시에 자신이 무엇을 하고 있으며 이는 누구를 위한 것인지 계속해서 점검하는 것이다
- 코드 품질을 희생한다고 해서 꼭 제품 품질까지 희생하는 것은 아니다
    - 하지만 품질 낮은 코드는 결국 문제가 될 것이고 이로 인해 나중에는 약간의 고통을 감수해야 할 것이다

### 1.3.3 높은 처리량

- 어떤 전문 지식은 다른 사람의 실수와 절망을 통해 습득할 수 있다

### 1.3.4 복잡성과 모호성 수용

- 복잡성은 무섭고 모호성은 더 무섭다
- 모호한 문제를 해결하는 요령은 문제에 대해 알고 있는 것을 모두 명확히 수치화하고, 이러한 사실을 바탕으로 근사치에 도달하는 것이다


- 어떤 기능을 개바랗는데 걸리는 시간을 추정하는 등의 알 수 없는 매개변수가 속한 문제라면 이미 알고 있는 정보를 기준으로 근사 범위를 좁힐 수 있다
- 자신이 알고 있는 것을 자신에게 유리하게 사용하고 최대한 활용할수록 애매한 부분을 최소로 줄일 수 있다


- 아무리 복잡해 보이는 것도 쉬운 문제로 나눌 수 있고, 더 구체화할수록 더 많은 미지의 것을 다룰 수 있다

## 1.4 최근 소프트웨어 개발의 문제점

- 기술이 너무 많다
- 패러다임 중심적이며 따라서 보수적이다
- 기술은 자동차처럼 점점 불투명해지고 있다
- 사람들은 코드의 오버헤드를 신경 쓰지 않는다
- 프로그래머는 자신이 작업 중인 스택에 집중할 뿐 나머지 부분이 어떻게 동작하는지에는 관심이 없으며, 이것을 당연하게 생각한다
    - 프로그래머는 바빠서 무언가를 배울 시간이 없다 -> 식탁 개발자 문제
    - 미지의 영역을 당연하게 여기고, 이를 받아들인다
- 그동안 배운 패러다임에 감사하자

### 1.4.1 너무 많은 기술

- 대부분의 기술은 생산성 향상에 따른 트레이드 오프를 가진다
- 생산성을 높이는 것은 어떤 기술을 사용하는지보다 해당 기술을 얼마나 능숙하게 다루느냐에 달려 있다

### 1.4.2 패러다임의 패러글라이딩

- 오랜 시간 동안 다양한 패러다임이 나왔고, 매번 새로운 패러다임이 세상을 바꿔줄 것 같았다
- 우리는 패러다임, 패턴, 프레임워크 또는 라이브러리가 모든 문제를 해결해준다고 가정한다
- 하지만 이러한 도구를 맹목적으로 사용하면 나중에 더 많은 문제가 발생할 수 있다
- 따라서 새롭게 배워야 할 도메인 지식과 도구에 내재된 버그 때문에 속도가 더 늦어질 수 있다

### 1.4.3 기술의 블랙박스

- 불안함은 무능력보단 무지에서 비롯된다


- 두려움을 느끼기 전에 모든 범위의 복잡도를 직면할 수 있도록 먼저 열어서 확인해본다
- 대부분 두려워하는 것보다 덜 복잡하다


- 라이브러리, 프레임워크, 또는 컴퓨터가 어떻게 동작하는지에 대한 세부 사항은 그 위에 무엇이 구축되었는지 이해하는 데 엄청난 영향을 미칠 수 있다

### 1.4.4 오버헤드 과소평가

- 프레임워크와 라이브러리는 일반적으로 오버헤드를 피하도록 도와주며, 이는 유용한 추상화를 만든다
- 하지만 모든 의사 결정 과정을 프레임워크에 위임할 수는 없다
- 때로는 스스로 이런 결정을 내려야 하며, 오버헤드를 고려해야 한다


- 소프트웨어 개발자의 최우선순위는 오버헤드를 제거하는 것이 아니다
- 하지만 특정 상황에 오버헤드를 피할 수 있는 방법을 알고, 이러한 관점을 유용하게 사용할 수 있다면 도움이 될 것이다

### 1.4.5 내 일이 아니다

- 복잡성을 다루는 방법 중 하나는 우리의 책임에만 일단 집중하는 것이다
- 하지만, 모든 것은 연결되어있기에 연결된 것들에 대해서 알게 되면 우리가 더 나은 결정을 내릴 수 있도록 해준다

### 1.4.6 시시해 보이는 일도 도움이 될 수 있다

- 시시한 일이라고 모두 나쁜 것은 아니다

## 1.5 이 책에서 다루지 않는 것

## 1.6 주제

## 1.7 요약

- 새로운 개발자들은 이론에 너무 신경을 쓰거나 완전히 무시하는 경향이 있다