# 1주차 (1~3장)

# 1장 거리로

## 이 바닥 현실

- 일을 얼마나 빨리 하느냐가 실제로는 더 중요하다.
- 어디서 어떻게 일하게 될 지 아무도 모른다.
- 코드를 저장소에 올리면 모두의 코드가 되기에 항상 빚을 지면서 살게된다.
- 설계를 믿지 않는 사람도 있다.

## 누가 스트리트 코더인가?

- 모든 사람이 커리어를 시작할 때 길거리 지식(무엇이 가장 중요한지 알아차리기 위한 전문지식)을 놓친다.
- 시간이 지남에 따라서 모호성과 복잡성을 해결하는 기술을 습득하게 될 것이다.
- 스트리트 코더는 ‘소프트웨어 개발 경험을 가진 업계의 모든 사람’을 의미한다.
- 훌륭한 스트리트 코더의 자질
    - 업계의 인정
    - 명예
    - 충성심
    - 질문하기
    - 결과 중심적
    - 높은 처리량
        - 개발 속도에 영향을 미치는 가장 큰 요인은 경험, 좋고 명확한 요구 사항
    - 복잡성과 모호성 수용
        - 모호한 부분을 지식으로 범위를 좁히고 단순하게 나눌 수 있다.
- 휼륭한 소프트웨어 개발자는 단순히 훌륭한 코더가 아니다.

## 최근 소프트웨어 개발의 문제점

- 기술이 너무 많다.
    - 파이썬이 최고야? 아니.
    - 적정 환경에 따라 적정 기술을 사용해야한다.
- 패러다임 중심적이며, 따라서 보수적이다.
    - 패러다임으로 모든 문제를 해결할 수 있다고 가정하지만, 맹목적으로 쓰면 안된다.
- 기술은 자동차처럼 점점 불투명해지고 있다.
    - 라이브러리나 오픈소스를 사용하지만말고 한번 까보자.
- 사람들은 코드의 오버헤드를 신경 쓰지 않는다.
    - 오버헤드를 피하는 것이 1순위는 아니겠지만, 최대한 피해야한다.
- 프로그래머는 자신이 작업 중인 스택에 집중할 뿐 나머지 부분이 어떻게 동작하는지에는 관심이 없으며, 이것을 당연하게 생각한다.
    - 모든 코드는 상호 연결되어있기 때문에 다른 부분을 공부하면 더 나은 결정을 내리게 도와준다.
- 그동안 배운 패러다임에 감사하자.

## 길거리 지식으로 문제를 해결하는 방법

- 거리에서 살아님기에 충분한 최소한의 기초 지식
- 특정한 경우에 더 효과적일 수 있는 안티패턴
- CPU 수준의 최적화 기술같은 일부 프로그래밍 기술도 영향을 끼칠 수 있다.
- 생산성을 높히는 유용한 몇 가지 기술

# 2장 실용적인 이론

## 왜 컴퓨터 과학 이론이 우리 생존과 연관되어 있는가?

- 컴퓨터 과학의 이론은 알고리즘과 데이터 구조를 처음부터 개발할 수 있게 해줄 뿐만 아니라 이것을 언제 사용할지를 정확하게 알려준다.
- 알고리즘: 어떤 문제를 해결하기 위해 필요한 규칙과 단계를 모아 놓은 것
- 경우에 따라 규칙을 만들고, 정렬해서 더 개선할 수 있는 여지가 있다.

## 사용자에게 적합한 유형 만들기

## 알고리즘의 특성 이해하기

### 알고리즘 특강

- 빅 오를 이해하기
    - 크기 혹은 수치가 얼마나 빨리 증가할지 미리 안다면 어떤 일이 일어나는지 미리알 수 있고, 무엇이 문제인지도 파악할 수 있다.
    - 빅오 표기법은 시간 복잡도라고 불리는 계산량 증가를 측정하는데만 쓰이는 것이 아니라 공간 복잡도라고 불리는 메모리 사용의 증가를 측정하는 데도 사용된다.
    - 알고리즘이 빠르더라도 메모리가 다항식을 따라 증가할 수 있다.

## 아무도 알려주지 않은 데이터 구조와 이상한 특성

### 내부 데이터 구조

- 데이터를 어떻게 배치하는지에 따라 데이터가 더 유용해질 수 있다.
- 문자열
    - 용도나 구조적인 측면에서는 배열과 유사하지만 .NET에서 문자열은 불변이다.
    - 문자열을 if문이나 loop로 붙인다면 메모리 재할당이 계속 일어나서 느리다.
    - 그래서 템플릿 리터럴로 한번에 붙이는 것이 더 빠르다. 또는 라이브러리 사용하기
    - 문화권을 생각하며 개발하기.
- 배열
    - 배열 크기를 초과하지 않는 개수만큼의 여러 항목을 저장하는데 유용하다.
    - 배열은 문자열과 달리 변경이 가능하다.
    - 상태를 변경하도록 만들지 말자. 앱의 상태 변수가 적을수록 문제도 줄어든다.
    - 함수의 로컬 스코프 안에서만 사용하자.
- 리스트
    - 크기가 가변적인 배열처럼 동작한다.
    - 배열은 직접 액세스를 사용하지만 리스트는 인덱스된 액세스를 사용해서 성능저하가 있다. (가상함수 호출)
    - 전체 용량을 미리 설정하면 불필요한 확장 및 복사 작업을 막을 수 있다.
- 연결 리스트
    - 요소가 메모리 안에서 연속적이지 않고 각 요소가 다음 항목의 주소를 가리키는 리스트를 말한다.
    - 삽입/삭제 작업에 상수시간을 가지므로 유용하다.
    - 항상 일반 리스트보다 빠르지는 않다. 각 요소를 위해 개별적으로 메모리를 할당해야하므로 성능이 저하될 수 있다.
    - 큐 또는 스택 구조가 필요할 때 연결 리스트가 필요할 수 있다.
    - 운영체제 커널에서 자주 사용된다.
- 큐
    - 삽입한 순서대로 리스트에서 읽을 수 있다.
- 딕셔너리
    - 해시맵 또는 키/값으로 알려진다.
    - 해싱을 사용해서 상수시간에 가깝게 임의의 데이터에 접근할 수 있다.
    - 키-값 쌍을 단순히 순차적으로 검사해야하는 상황에서는 오히려 성능을 해칠 수 있다.
- 해시 집합
    - 고유값만 저장하다.
    - 주어진 배열이나 리스트에 어떤 항목이 들어있는지 확인하기 위해 많이 검사해야할 경우 집합이 더 빠를 수 있다.
    - 조회나 삽입이 빨라서 교집합이나 합집합을 구하는 작업에도 적합하다.
- 스택
    - 후입 선출법을 따르는 큐이다.
    - 어떤 단계를 역추적하는 데 유용하다.
- 호출 스택
    - 함수의 반환 주소를 저장해 호출된 함수의 실행이 완료되면 반환할 위치를 알려주는 데이터 구조
    - 스레드당 호출 스택 하나를 가진다.
    - 모든 스레드는 고정된 메모리로서 자체 호출 스택이 있다.
    - 스택은 메모리공간에서 위에서 아래로 늘어나며 맨 위는 메모리 공간의 끝을 의미하고, null pointer 주소 0을 의미한다.
    - 스택도 한계가 있다.

### 타입

- 동적 타이핑 말고도 안전해서 정적 타이핑이 좋다.
- 인터프리터 방식의 프로그래밍 언어
    - 코드작성이 빠르다.
- 컴파일 방식의 프로그래밍 언어
    - 코드작성이 느리다.
    - 다른 타입의 변수에 다른 타입의 값을 할당할 수 있는지에 따른 구분
        - 강한 타이핑
        - 약한 타이핑
- 타입을 통해 유효성 증명을 할 수 있다.
- 등가 연산자와 타입캐스팅 연산자를 대체하기 위한 목적이 아니라면 연산자 오버로딩은 하지마라 (+=, -=)
- 프레임워크/라이브러리를 무지성 사용 하지마라. 똑똑하게 사용해라.
- 주석보다 타입으로 코드를 더 잘 설명할 수도 있다.
- 기존의 타입은 더 효율적인 저장공간을 사용할 수 있다.
- 참조타입과 값타입
    - 참조타입
        - 힙에 저장
        - 참조는 포인터와 유사.
    - 값 타입
        - 호츨스택에 저장
    - 포인터 자체보다 크기가 작은 데이터를 위해 포인터를 사용하는 것은 안된다.

# 3장 유용한 안티패턴

## 사용하기에 편리하지만 나쁘다고 알려진 습관

### 코드를 변경하지 마라

- 코드 경직성: 기존 코드가 특별한 작업 방식과 밀접하게 연결되어 있을 때 수정이 어려운 것. 코드를 변경하면 다른 여러 곳을 함께 변경해야할 수 있다.
    - 코드가 경직될수록 코드를 조작하기 위해 더 많은 코드를 깨버려야 한다는 것을 의미
- 종속성(의존성)은 코드 경직성을 키우는 하나의 요인
    - 종속을 피할 수는 없음. 체인을 잘 구분해서 관리하자.
- 코드를 빠르게 옮기고 깨버리자
    - 코드를 더 많이 재사용할수록 시간을 더 많이 절약할 수 있다고 생각하지만 이로인해 코드경직성이 커질 수 있다는 것을 기억하자.
- 의존성에 대한 추상화 경계를 넘지말자.
    - 추상화 경계: 코드 계층 주위에 그리는 논리적 경계, 주어진 계층의 관심사 집합을 의미한다.
    - 경계를 넘으면 추상화의 장점을 없애버리게 된다.
- 공통적인 기능을 분리해라
    - 코드를 리팩터링하면 빌드 프로세스가 중단되거나 테스트가 실패할 수 있다.
    - 비즈니스로직을 공통적으로 사용하고 있다면 비즈니스 계층을 만들어서 따로 분리하자.
        - 비즈니스는 실제 비즈니스가 아니라 추상적인 모델이 가진 애플리케이션의 핵심 로직을 의미한다
- 빚을 지지 마라
    - 기술부채는 쌓일 수 밖에 없다. 하지만 사소한 잘못된 결정이 팀 전체의 성과를 망칠 것이다.
    - 기술부채를 억지로 해결하기보다 잠깐 미뤄두자.

## 실제로 유용한 안티패턴

### 처음부터 다시 작성하라

- 코스트가 많이 들지만, 매몰비용때문에 더한 장애를 맞게 된다.
- 동일한 결과를 기대하면서 반복할 때 소요시간은 더 줄어들고 완성도는 더 올라간다.

### 코드가 멈추지 않았어도 개선하자

- 코드 경직성을 해결하는 방법 중 하나는 코드가 굳지 않도록 계속 휘젓는 것이다.
- 코드 종속성을 업데이트하고 앱을 유동적으로 유지하며 변경하기 어려운 가장 경직된 부분을 정기적으로 확인하는 습관을 만들어 놓자.
- 정기적으로 패키지(라이브러리)를 최신 상태로 유지하는 것에는 두 가지 이점이 있다.
    - 유지보수하는 동안 현재 버전으로 업그레이드하는 수고를 분산시킨다.
    - 모든 사소한 업그레이드가 작고 미묘하게 코드나 설계를 손상시킬 수 있다.
- 코드를 깔끔하게 만드는 것은 작성하는 것 만큼 중요하다.
    - 주석을 최신화하고, 네이밍을 변경하라.

### 스스로 반복하라

- 반복이나 복붙형태의 프로그래밍은 보통 선호하지 않는 개념이다.
- 약간의 반복이 있더라도 함수를 만들어 반복 사용해라.
- 코드를 재활용할지, 복사할 것인지는 발신자의 요구사항이 실제로 무엇인지 설명하는 것에 따라 결정된다.
    - 코드의 위치, 모듈, 클래스는 코드의 재사용 여부를 판단하는 지표가될 수 있다.

### 지금 새로운 것을 시도하라.

- 이미 존재하는 것을 만들지 말라
- 하지만 무언가를 발명하는 것을 두려워해서는 안 된다.
    - 의문을 품는 사고방식을 가진 사람들이 발명가가 된다.
    - 모든 발명품에 대안이 있는 것은 아니다.
- 특정 라이브러리를 사용하면 종속성을 가지게 되는데 이런 것을 해결하는 방법은 발명!
    - 라이브러리를 한단계 감싸서 추상화를 시키자.

### 상속을 사용하지 마라.

- 다중상속, 강한 결합, 종속성 역전 원칙 등 다양한 문제를 가지고 있다.
- 합성을 사용하자 (Mixin)

### 클래스를 사용하지 마라.

- 클래스는 훌륭하지만 오버헤드를 발생시키고 값타입에 비해 더 많이 우회하는 동작을 발생시킨다.
- 열거형을 사용해보자
- 구조체는 아주 좋다.

## 모범 사례와 그 반대 사례를 언제 사용할지 확인하는 법

### 불량 코드를 작성하라

- 모범사례를 맹목적으로 적용하다보면 코드를 망칠 수 있다.
- if/else를 사용하지 마라
    - 정확하게는 else를 사용하지 마라
    - 빠른 실패 혹은 행복한 경로 따라가기 기법으로 불린다.
- goto를 사용하라
    - 함수에서 중복되는 종료 지점을 제거해야하는 경우에 한해 아주 잘 작동한다.

### 코드 주석을 작성하지 마라

- 이름을 잘 선택해라.
- 함수를 작게 쪼개서 잘 활용해라.