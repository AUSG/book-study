# 01~05

- [01~05](#0105)
- [추천의 글](#추천의-글)
- [서문](#서문)
  - [이 책의 전제](#이-책의-전제)
- [01부. 동작하는 도메인 모델 만들기](#01부-동작하는-도메인-모델-만들기)
  - [도메인 주도 설계에서의 모델의 유용성](#도메인-주도-설계에서의-모델의-유용성)
  - [소프트웨어의 본질](#소프트웨어의-본질)
- [01. 지식 탐구](#01-지식-탐구)
  - [효과적인 모델링의 요소](#효과적인-모델링의-요소)
  - [지식 탐구](#지식-탐구)
- [02. 의사소통과 언어 사용](#02-의사소통과-언어-사용)
  - [크게 소리내어 모델링하기](#크게-소리내어-모델링하기)
  - [한 팀, 한 언어](#한-팀-한-언어)
  - [문서와 다이어그램](#문서와-다이어그램)
  - [글로 쓴 설계 문서](#글로-쓴-설계-문서)
    - [**문서는 코드와 말을 보완하는 역할을 해야 한다.**](#문서는-코드와-말을-보완하는-역할을-해야-한다)
    - [문서는 유효한 상태를 유지하고 최신 내용을 담고 있어야 한다](#문서는-유효한-상태를-유지하고-최신-내용을-담고-있어야-한다)
  - [설명을 위한 모델](#설명을-위한-모델)
- [03. 모델과 구현의 연계](#03-모델과-구현의-연계)
  - [내부 드러내기: 왜 모델이 사용자에게 중요한가](#내부-드러내기-왜-모델이-사용자에게-중요한가)
  - [HANDS-ON MODELER(실천적 모델러)](#hands-on-modeler실천적-모델러)
- [04. 도메인의 격리](#04-도메인의-격리)
  - [대다수의 성공적인 아키텍처의 네 가지 개념적 계층](#대다수의-성공적인-아키텍처의-네-가지-개념적-계층)
  - [SMART UI(지능형 UI) “안티 패턴”](#smart-ui지능형-ui-안티-패턴)
  - [다른 종류의 격리](#다른-종류의-격리)
- [05. 소프트웨어에서 표현되는 모델](#05-소프트웨어에서-표현되는-모델)
  - [ENTITY(엔티티)](#entity엔티티)
  - [VALUE OBJECT(값 객체)](#value-object값-객체)
  - [SERVICE(서비스)](#service서비스)
  - [MODULE(모듈)](#module모듈)
    - [객체가 아닌 요소를 객체지향 시스템에 혼합할 때 주의점](#객체가-아닌-요소를-객체지향-시스템에-혼합할-때-주의점)


# 추천의 글

- 도메인 모델은 모델을 먼저 그리고 구현을 하는 게 아니다.
  - 가장 숙련된 모델러조차도 시스템이 최초 출시된 다음에나 최상의 아이디어를 얻는다는 사실을 알게 된다.
- 소프트웨어는 복잡하다. 복잡성은 소프트웨어가 태생적으로 지니고 있는 본질적인 특성이며 소프트웨어 개발의 역사는 복잡성을 정복하기 위한 역사라고 해도 무방하다.
  - 대부분의 사람들은 소프트웨어의 복잡성이 기술적인 이슈에 기인한다고 생각하는 것 같다. 그러나 소프트웨어의 복잡성은 기술적인 이슈보다는 소프트웨어가 발을 디디고 있는 문제 도메인에서 기안한다.
- 소프트웨어는 사람의 욕망과 욕구를 해결하려고 만든 창조물이고 사람들의 욕망과 욕구가 개발자에게 전달됐을 때 우리는 그것을 `도메인`이라고 부른다.
  - 예측하기 어려운 인간 군상의 문제를 해결하는 작업은 그 본질적인 특성 때문에 복잡할 수밖에 없다. 
  - 따라서 우리는 기술적인 이슈의 파도에 휩쓸리지 말고 한 말 물러서서 해결해야 하는 문제 도메인에 초점을 맞춰야만 한다.

# 서문

- 성공한 프로젝트의 공통적인 특징은 반복적 설계를 거쳐 발전하고 프로제긑의 일부분이 된 풍부한 도메인이 있었다는 것이다.

- 단순히 모델을 중요하게 취급한다고 해서 점차 향상되는 선순환에 이르지는 않는다.
  - 개발자 역할을 분담하는 데 오류를 범함으로써 모델링과 구현이 단절됐고, 이로써 진행되고 있던 심층적적인 분석 내용이 설계에 반영되지 못하는 결과가 초래됐다.
  - 세부적인 업무 객체의 설계가 정교한 애플리케이션에 해당 객체들을 결합시킬 만큼 엄밀하지 못했다.
  - 반복주기는 계속됐지만 코드는 개선되지 않았다. 이는 개발자 간의 숙련도 차이가 고르지 않아서였다.
  - 그들은 모델 기반 객체를 만들어내기 위한 비공식적인 형식과 기법을 알지 못했고 몇 달이 지난 후 개발 업무는 복잡성이라는 수렁에 빠졌고, 팀원들은 시스템에 대한 응집력 있는 비전을 잃어버렸다.
  - 몇 년간의 노력으로 프로젝트는 적당한 수준의 소프트웨어는 만들어 냈지만 팀원들은 모델에 초점을 맞춘다는 것과 함께 초기의 포부는 단념해야만 했따.

- 수많은 애플리케이션에서 가장 중요한 복잡성은 기술적인 것이 아니다. 그것은 바로 사용자의 활동이나 업무에 해당하는 도메인 자체다. 이러한 도메인의 복잡성을 설계에서 제대로 다루지 않으면 기반 기술을 잘 이해하더라도 무용지물일 것이다. 성공적인 설계라면 틀림없이 소프트웨어의 중심 요소인 도메인을 체계적인 방법으로 다룰 것이다.

## 이 책의 전제

- 대부분의 소프트웨어 프로젝트에서는 가장 먼저 도메인과 도메인 로직에 집중해야 한다.
- 복잡한 도메인 설계는 모델을 기반으로 해야 한다.

- 이 책의 접근법을 적용하기 위한 선행 조건
  - 개발은 반복주기를 토대로 진행돼야 한다.
  - 개발자와 도메인 전문가는 밀접한 관계에 있어야 한다.

  - 안타깝게도 일부 애자일 프로세스의 사상은 오해의 소지가 있다. 이는 “가장 단순함”을 제각기 다르게 정의하기 때문이다.
  - 지속적인 리팩터링은 작은 재설계가 연속적으로 일어나는 것이다.
    - 즉, 확고한 설계 원칙이 없는 개발자는 이해하거나 변경하기 어려운 코드만을 만들어 낼 것이며, 이는 기민함(aility)과는 거리가 멀다.
    - 그리고 예상치 못한 요구사항에 대한 두려움이 종종 과도한 선행 작업으로 이어지기도 하지만, 반대로 지나친 선행 작업을 회피하려는 노력이 “설계에 관해 전혀 깊이 있게 생각하지 않는다는” 또 다른 두려움을 만들어 내기도 한다.

# 01부. 동작하는 도메인 모델 만들기

## 도메인 주도 설계에서의 모델의 유용성

- `모델과 핵심 설계는 서로 영향을 주며 구체화된다.`
  - 모델을 의미있게 만들고 모델의 분석이 최종 산출물인 동작하는 프로그램에 적용되게끔 보장하는 것은 다른 아닌 모델과 구현 간의 긴밀한 연결이다.
  - 이러한 모델과 구현의 연결은 유지보수와 계속되는 기능 개선에도 도움이 되는데, 그 이유는 바로 모델을 이해한 바에 근거해 코드를 해석할 수 있기 때문이다.
- `모델은 모든 팀 구성원이 사용하는 언어의 중추다.`
  - 개발자는 이 언어를 토대로 프로그램에 관해 의견을 나눌 수 있고 개발자와 도메인 전문가가 의사소통하는 데 별도의 번역 절차가 필요하지 않다.
  - 또한 언어가 모델에 기반을 두므로 우리의 타고난 언어 능력에 힘입어 모델 자체를 정제할 수 있다.
- `모델은 지식의 정수만을 뽑아낸 것이다.`
  - 모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식이다.
  - 모델에는 우리가 용어를 선택하고, 개념을 분류하며, 분류한 지식을 서로 연관시킬 때 도메인에 관한 우리의 사고방식이 담겨 있다.
  - 개발자와 도메인 전문가는 공유 언어를 바탕으로 갖가지 정보를 모델로 만들어낼 때 효과적으로 협업할 수 있다.
  - 모델과 구현이 연결되어 있다면 초기 버전의 소프트웨어를 통해 얻은 경험을 모델링 프로세스에 피드백으로 활용할 수 있다.

## 소프트웨어의 본질

- 소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있다.

- 도메인 연구는 대부분의 소프트웨어 프로젝트에서 최우선 과제로 여겨지지 않는다. 대부분의 유능한 개발자는 다뤄야 할 특정 도메인을 학습하는데 관심이 많지 않으며, 더군다나 도메인 모델링 기법을 쌓는 데는 더더욱 전념하지 않는다.
  - 기술자들은 자신의 기술력을 훈련할 수 있는 정량적인 문제를 좋아한다.
    도메인 업무를 무시하고 컴퓨터 과학자로서의 능력에 보탬이 될 것 같지 않은 복잡하고 새로운 지식을 많이 요구한다.
- 대신 기술적인 재능이 있는 사람은 정교한 프레임워크를 만드는 작업에 착수해 기술을 바탕으로 도메인 문제를 해결하려 한다.
  - 도메인을 학습하고 모델링하는 일은 다른 이들의 몫으로 남는다.
  - 소프트웨어의 중심에 있는 복잡성은 정면으로 돌파해야 한다.
  - 그렇지 않으면 도메인과 무관한 소프트웨어를 만들어낼지도 모를 위험을 무릅써야 한다.
- 팀의 리더가 도메인의 중심이 되는 개념을 알고 있어야 해당 도메인의 심층적인 이해를 반영하는 모델 개발이 모르는 사이에 갈피를 잡지 못할 때 소프트웨어 프로젝트를 올바른 방향으로 되돌려 놓을 수 있다.
  - 이렇게 해야만 기술적인 요소에만 집착하여 소프트웨어의 본질을 잊은 기술자들의 실수를 막을 수 있다.
    - e.g. 영화의 재밌는 장면에 누군가의 코트 소매가 가장자리에 찍혔다는 이유로 촬영분을 다른 장면으로 대체했던 자신의 전문 분야를 꼼꼼히 이행하는 데 집중한 필름 편집자의 이야기. 결국 코미디를 잘 아는 감독에 의해 해당 장면은 복원됨.

# 01. 지식 탐구

## 효과적인 모델링의 요소

앞에서 저자가 인쇄 회로 기판(PCB) 설계에 특화된 소프트웨어 툴을 설계하는 과정에서 PCB 엔지니어들과 소통하며 프로젝트를 진행한 예시를 보여줬다.

- 개인적으로 서로 알고 있는 지식들을 그림 등을 통해 표현하고 설명하며 align하는 과정이 인상적이었다.
- 말단 API, 영구 저장소 등을 사용하지 않고 간단하게 코어한 부분만 개발하여 가시화하고 피드백한 것도 인상적이었다.

그리고 이는 성공적으로 기대 이상으로 기능이 풍부한 툴이 탄생하여 성공적으로 진행되었고 이 과정에서 효과적이었던 요소들을 소개한다.

- `모델과 구현의 연계`
  - 초기 프로토타입을 토대로 본질적인 연결 고리를 만든 다음, 이어지는 모든 반복 주기 내내 그 연결 고리를 유지했다.
- `모델을 기반으로 하는 언어 정제`
  - 처음에는 엔지니어가 저자에게 PCB 문제를 설명해야 했고, 저자 또한 다이어그램이 뜻하는 바를 설명해야 했다. 하지만 프로젝트가 진행되면서 누구라도 모델에서 바로 용어를 끄집어내어 모델의 구조와 일관되게 문장을 구성할 수 있게 됐고 별도의 해석 없이도 문장을 명확히 이해할 수 있었다.
- `풍부한 지식이 담긴 모델 개발`
  - 객체는 `행위`를 지니고 `규칙`을 이행했으며
  - 모델은 단순히 데이터 스키마가 아니라 복잡한 문제를 해결하는 데 필수불가결한 것이었다.
  - 그리고 모델에는 다양한 지식이 포함돼 있었다.
- `모델의 정제`
  - 모델이 점차 완전해지면서 중요한 개념이 더해졌으며, 마찬가지로 쓸모없거나 중요하지 않다고 판명된 개념은 제거되었다.
  - 이를 통해 본질적인 개념만을 식별할 수 있는 새로운 모델을 고안해냈다.
- `브레인스토밍과 실험`
  - 스케치를 비롯해 브레인스토밍을 하려는 태도와 결합된 언어를 바탕으로 토의를 모델에 대한 실험실로 변모시켜 수백 가지의 실험용 변종을 연습하고, 시도해 보며, 평가할 수 있었다.
  - 팀에서 시나리오를 검토할 때 시나리오를 말로 표현해보기만 해도 그러한 표현이 명확하고 쉬운지, 아니면 어색한지 빠르게 감지해 낼 수 있었기 때문이다.
  - **지식 탐구는 팀 내 지식을 가치 있는 모델로 만든다.**

## 지식 탐구

도메인 지식 탐구는 혼자하는 게 아니다. 개발자, 도메인 전문가 등 모든 팀 구성원이 함께해야 모델을 좀 더 명료하고 조직화되도록 구성할 수 있다.

모델은 도메인을 이해하는 데 실용적이고 유용해야하고 모델을 쉽게 구현하고 이해하기에 충분히 엄밀해야 한다.

- 팀 구성원이나 개발자, 도메인 전문가에게서 모두 똑같이 지식을 얻고 의사소통 체계를 공유하며, 구현을 거쳐 피드백 고리를 완성하는 일은 아주 중요하다.
- 유용한 모델은 겉으로 드러나 있는 경우가 거의 없고 도메인에 대해 이해도가 높아질 수록 포착하기 어려운 추상화가 서서히 나타나기 시작한다.

# 02. 의사소통과 언어 사용

- 팀의 의사소통에서 사용되는 단어가 도메인에 녹아있어야 한다. 이것은 미묘하지만 아주 중요하다.

- **UBIQUITOUS LANGUAGE(보편 언어)**

> 우선 문장을 쓰고 문장을 잘게 나눈다. 그러고 나서 무작위로 조각들을 섞은 다음 정렬한다. 구절의 순서는 아무런 차이를 만들어내지 않는다.

- 루이스 캐롤
>

- **지식 탐구의 과정은 모델 기반 언어에 팀 전체가 헌신할 때 비로소 가능해진다.**
  - 유비쿼터스 언어를 지속적으로 사용하다보면 모델의 취약점이 드러나고 자연스럽게 이에 대한 대안을 찾게 된다.
  - 모델 기반 언어가 자연스럽게 느껴질 때까지 끈임없이 노력한다면 간결한 요소로 복잡한 아이디어를 표현할 수 있는 완전하고 이해하기 쉬운 모델을 만들어 낼 수 있다.
- **모델을 언어의 근간으로 사용하라. 팀 내 모든 의사소통과 코드에서 해당 언어를 끊임없이 적용하는 데 전념하라. 다이어그램과 문서에서, 그리고 특히 말할 때 동일한 언어를 사용하라.**
- 유비쿼터스 언어의 변화가 곧 모델의 변화라는 것을 인식하라.
- 도메인 전문가는 도메인을 이해하는 데 부자연스럽고 부정확한 용어나 구조에 대해 반대 의사를 표명해야 한다.
  - 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내는 데 촉각을 곤두 세워야 한다.

## 크게 소리내어 모델링하기

- 인간은 구어에 천부적인 재능이 있다. 따라서 다른 형태의 의사소통과 말하기를 분리하면 큰 손실이다.
  - 그리고 안타깝게도 사람들은 이야기를 나눌 때 대개 도메인 모델의 언어를 사용하지 않는다. 물론 예외도 있다.
- **시스템에 관해 이야기를 주고받을 때 모델을 사용하라.**
  - 모델의 요소와 상호작용을 이용하고 모델이 허용하는 범위와 갠며을 보합하면서 시나리오를 큰 소리로 말해보아라.
  - 표현해야 할 것을 더 쉽게 말하는 방법을 찾아내고 그 새로운 아이디러를 다이어그램과 코드에 적용하라.

## 한 팀, 한 언어

- 종종 기술 담당자는 업무 전문가에게 도메인 모델을 보여 줄 필요가 없다고 생각한다.
  - “업무 전문가들에게는 너무 추상적이라서요.”
  - “업무 전문가들은 객체를 이해하지 못해요.”
  - “업무 전문가들이 쓰는 용어로 된 요구사항을 만들어야 해요.”
  - **이런 말은 귀담아 듣지 않아도 된다.**
  - **수준 높은 도메인 전문가도 해당 모델을 이해하지 못한다면 모델이 뭔가 잘못된 것이다.**

![ubiquitous-language-boundary](https://github.com/AUSG/2023-book-study/assets/72328687/0624ec0f-2d1e-45fa-8588-97e094cb5173)b931e95-1363-4b34-aef9-6a921be64a7e)

- **물론 개발자나 도메인 전문가 각각은 서로 이해하지 못하는 광범위한 전문용어를 사용한다.**
  - **그러나 이러한 용어는 유비쿼터스 언어의 확장 영역에 해당한다.**
  - 이 영역의 언어에는 별개의 모델을 반영하면서 같은 도메인에서 쓰이는 대체 어휘 등 모호함을 가져오는 단어는 포함돼 있어서는 안된다.
  - 유비쿼터스 언어가 마련되면 팀 내의 대부분의 표현. 심지어 코드 자체까지 모든 것이 도메인 모델에서 비롯된 동일한 언어를 기반으로 할 것이다.

## 문서와 다이어그램

- **모델은 다이어그램이 아니라는 점을 항상 명심하라. 다이어그램의 목적은 모델을 전달하고 설명하는 데 있다.**
  - 코드는 설계의 세부사항에 대한 저장소 역할을 할 수 있따. 잘 작성된 자바 코드는 UML만큼 표현력이 있따.
  - 다이어그램으로 모델이나 설계를 완벽하게 표현해야 한다는 강박에 사로잡히지 말아라.

## 글로 쓴 설계 문서

- 어떠한 규모의 집단이든 어느 정도는 글로 쓴 문서로 안정과 공유를 꾀할 필요가 있다.

### **문서는 코드와 말을 보완하는 역할을 해야 한다.**

- 각 애자일 프로세스에는 문서에 관한 나름의 철학이 있는데, 익스트림 프로그래밍은 여분의 설계 문서를 전혀 사용하지 않고 코드 스스로 별도의 설명이 필요없는 상태를 유지해야 한다는 입장을 옹호한다.
- **그러나 설계 문서로서의 코드에는 분명 한계가 있다.**
  - 문서는 코드가 이미 잘 하고 있는 것을 하려고 해서는 안된다.
  - 코드가 아닌 다른 문서들은 의미를 설명하고, 대규모 구조에 통찰력을 주며, 핵심 요소에 집중할 필요가 있다.

### 문서는 유효한 상태를 유지하고 최신 내용을 담고 있어야 한다

- 설계 문서의 가장 큰 가치는 다음과 같다.
  - 모델의 개념을 설명하고,
  - 코드의 세부사항을 파악해 나가는 데 도움을 주며,
  - 모델의 의도된 사용 방식에 어떤 통찰력을 준다.
- **문서는 프로젝트 활동과 관련을 맺고 있어야 한다.**
  - 이를 판단하는 가장 쉬운 방법은 문서가 유비쿼터스 언어와 상호작용하는지 살펴보는 것이다.
  - 문서가 프로젝트에서 쓰는 언어로 작성돼 있는가? 문서가 코드에 포함된 언어로 쓰여 있는가?

## 설명을 위한 모델

- **이 책의 요점은 하나의 모델이 구현, 설계, 의사소통의 기초가 되어야 한다는 것이다.**
  - 이러한 각 목적에 각기 다른 모델을 갖추는 것은 바람직하지 않다.
- **설명을 위해 UML과 같은 모델을 사용하지 말라는 것은 아니다.**
  - 설명을 위한 모델은 특정 주제에 맞춰 훨씬 더 전달력이 높은 의사소통 방식을 마음껏 만들어낼 수 있다.

# 03. 모델과 구현의 연계

- 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확성도 의심스러워진다.
  - 동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다.
  - 분석과 설계가 치명적으로 동떨어지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.
- **분석은 도메인의 근본적인 개념을 알기 쉽고 표현력 있는 방식으로 포착해야 한다.**
  - 설계에서는 대상 배포 환경에서 효율적으로 수행되고 애플리케이션에서 다뤄야 할 문제를 올바르게 해결해 줄 수 있느 구성요소를 기술해야 하며,
  - 이러한 구성요소는 프로젝트에서 사용 중인 프로그래밍 도구로 구현할 수 있어야 한다.

- **모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출하라.**
  - 코드를 작성할 때 그 용어를 사용하면 코드가 모델을 표현한 것이 되고,
  - 코드의 변경이 곧 모델의 변경으로 이어질 수 있다.
  - 이 효과는 프로젝트의 나머지 활동에도 퍼져나가야 한다.
  - 구현을 모델과 그대로 묶으려면 보통 객체지향 프로그래밍과 같은 모델링 패러다임을 지원하는 개발 언어가 필요하다.

## 내부 드러내기: 왜 모델이 사용자에게 중요한가

- 설계가 사용자와 도메인 전문가의 기본적인 관심사를 반영하는 모델에 기반을 두면 설계의 골격이 다른 설계 접근법에 비해 더 큰 범위에 걸쳐 사용자에게 표현될 수 있다.
- 즉, 기능에서 모델이 드러나면 사용자가 소프트웨어의 잠재력을 좀 더 많이 접하게 되어 일관성 있고 예상 가능한 행위가 나타날 것이다.
  - e.g. 브라우저 즐겨찾기 기능

## HANDS-ON MODELER(실천적 모델러)

- 소프트웨어 개발 분야에는 고도로 숙련된 엔지니어는 설계를, 덜 숙련된 노동자는 제품을 조립한다는 제조업에서 온 은유가 있다.
  - 하지만 이 은유는 “소프트웨어 개발은 모든 것이 설계다”라는 단순한 이유로 많은 프로젝트를 엉망으로 만들었따.
  - **모든 팀원에게는 각기 전문화된 역할이 있지만 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MODEL-DRIVEN DESIGN과 상충한다.**

- 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나 애플리케이션을 대상으로 모델이 동작하게 만드는 방법을 모른다면, **그 모델은 소프트웨어와 무관해진다.**
  - 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킬 것이고
  - 한편으로 모델 설계자와 구현 프로세스와 분리돼 있을 경우, 구현상의 제약조건을 감안하는 능력을 결코 갖추지 못하거나 금방 잃어버릴 것이다.
  - 모델이 효과적인 구현을 뒷받침하고 핵심 도메인 지식을 추상화한다는 MODEL-DRIVEN DISIGN의 기본적인 제약조건은 절반쯤 사라지고, **결과로 나타나는 모델은 실용적이지 못할 것이다.**
  - 결국 MODEL-DRIVEN DISIGN을 코드로 만드는 과정의 미묘한 사항들은 협업을 통해 알 수 있는데, 설계자가 구현을 하지 못해 개발자와 업무 단절이 생기면 숙련된 설계자의 지식과 솜씨는 결코 다른 개발자에게 전해지지 못할 것이다.
- **결론적으로 모델에 기여하는 모든 기술자는 프로젝트 내에서 수행하는 일차적 역할과는 상관없이 코드를 접하는 데 어느 정도 시간을 투자해야만 한다.**
  - 코드를 변경하는 책임이 있는 모든 이들은 코드를 통해 모델을 표현하는 법을 반드시 배워야 하고
  - 모든 개발자는 모델에 괂나 일정 수준의 토의에 깊이 관여해야 하며, 도메인 전문가와도 접촉해야 한다.
  - 다른 방식으로 모델에 기여하는 사람들은 의식적으로 코드를 접하는 사람들과 유비쿼터스 언어를 토대로 모델의 아이디어를 나누는 데 적극 참여해야 한다.

# 04. 도메인의 격리

- 코드 격리와 관련해서 레이어드 아키텍처 이야기.. (관심사 분리)
- 종종 프로그래밍에서 각 레이어별로 구분이 되지 않는 코드들이 생기는데, 이건 단기적으로 이렇게 하는 것이 뭔가를 동작하게 하는 가장 쉬운 방법이기 때문이다.
- 하지만 도메인에 관련된 코드가 상당한 양의 도메인과 관련이 없는 다른 코드를 통해 널리 확산될 경우 도메인에 관련된 코드를 확인하고 추론하기가 굉장히 어려워진다.
  - **사이드 이펙트가 예측하기 어렵고 커진다는 것이다.**
  - 이러다보면 응집력있고, 모델 주도적인 객체를 구현하는 것이 비현실적인 이야기가 되어버리고 자동화 테스트가 어려워진다.
  - 기술과 로직이 모두 각 활동에 포함돼 있다면 프로그램을 매우 단순하게 유지해야 하며, 그렇지 않으면 프로그램을 이해하기가 불가능해진다.

## 대다수의 성공적인 아키텍처의 네 가지 개념적 계층

- `사용자 인터페이스(또는 표현 계층)`
  - 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 일을 책임짐.
  - 간혹 사람이 아닌 다른 컴퓨터 시스템이 외부 행위자가 되기도 함.
- `응용 계층`
  - 소프트웨어가 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 함.
  - 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호작용하는 데 필요한 것들임.
  - 이 계층은 얇게 유지되고 여기에 업무 규칙이나 지식이 포함되지 않으며, 오직 작업을 조정하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에게 작업을 위임함.
  - 응용 계층에서는 업무 상황을 반영하는 상태가 없지만 사용자나 프로그램의 작업에 대한 진행 상황을 반영하는 상태를 가질 수는 있음.
- `도메인 계층(또는 모델 계층)`
  - 업무 개념과 업무 상황에 관한 정보, 업무 규칙을 표현하는 일을 책임짐.
  - 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처에 위임함.
  - **이 계층은 업무용 소프트웨어의 핵심임.**
  - **MODEL-DRIVEN DESIGN을 가능케 하는 결정적인 계층.**
- `인프라스트럭처 계층`
  - 상위 계층을 지원하는 일반적인 기술적 기능ㅇ르 제공
  - 이러한 기능에는 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI에 위젯 그리기 등이 있음.
  - 또한 인프라스트럭처 계층은 아키텍처 프레임워크를 통해 네 가지 계층에 대한 상호작용 패턴을 지원할 수도 있음.

## SMART UI(지능형 UI) “안티 패턴”

- UI와 응용, 도메인을 분리하는 것은 자주 시도되지만 그다지 이뤄진 바는 없으므로 그러한 분리를 부정하는 것도 그 자체만으로 논의할만한 가치가 있다.
- 수많은 소프트웨어 프로젝트에서는 SMART UI라고 하는 훨씬 덜 복잡한 설계 접근법을 취하며, 또한 계속해서 취해야 한다. 하지만 SMART UI는 하나의 대안에 불과하며, 도메인 주도 설계 접근법과는 서로 양립할 수 없는 상호배타적인 길에 놓인 접근법이다.
- SMART UI를 택한다면 이 책에 내용을 대부분 적용할 수 없을 것이다.
  - 저자는 어떤 상황에 SMART UI를 적용하지 않는지에 관심이 있고, 그래서 저자의 기준으로 “안티 패턴”이라고 한다고 한다.

- 어떤 프로젝트에서 단순한 기능을 전해줘야 하는데, 이러한 기능은 데이터 입력과 표시 방식의 영향을 받고 업무 규칙이 거의 없다.
- 또한 팀원들이 고도의 객체 모델링을 수행하는 사람으로 구성되어 있지 않다면 SMART UI 방식이 유용할 수 있다.
  - 프로젝트 경험이 많지 않은 팀에서 LAYERED ARCHITECTURE와 함께 MODEL-DRIVEN DESIGN을 적용하기로 결정했다면 그 프로젝트 팀은 매우 험악한 학습 곡선에 직면하고 프로젝트는 망할 확률이 높다.
    - 설령 그 팀에 시간을 더 주더라도 말이다.
  - 좀 더 경험이 있는 팀이라면 똑같은 상황에 처하지는 않을 것이다. 노련하게 개발할 것이며 결국 도메인 주도 설계는 야심 찬 프로젝트에 최고의 성과를 가져다 주며, 동시에 매우 탄탄한 기술력을 요한다.
    - 모든 프로젝트가 야심 찬 것은 아니다. 모든 프로젝트 팀 역시 그러한 기술을 갖출 수 있는 것도 아니다.
  - **모든 업무 로직을 사용자 인터페이스에 넣어라. 애플리케이션을 작은 기능으로 잘게 나누고, 나눈 기능을 각기 분리된 사용자 인터페이스로 구현해서 업무 규칙을 분리된 사용자 인터페이스에 들어가게 하라. 관계형 데이터베이스를 데이터의 공유 저장소로 사용하고 이용 가능한 최대한 자동화된 UI 구축 도구와 시각적인 프로그래밍 도구를 사용하라.**
    - 이건 SMART UI의 방식이고 도메인 주도 설계의 맥락에서는 안티 패턴으로 간주될 수 있다.
    - 그럼에도 SMART UI가 다른 특정한 상황에서는 적합한 것이기도 하다.
    - 사실 SMART UI에는 여러 이점이 있으며, 이것이 가장 적합한 상황도 있다.
      - 이는 부분적으로 왜 SMART UI가 그렇게까지 널리 사용되는지를 뒷받침한다.
    - **여기서 SMART UI를 고려해 보는 것은 우리가 왜 도메인에서 애플리케이션을 분리하는지, 그리고 더 중요한 것은 언제 우리가 그렇게 분리하고 싶지 않은지를 이해하는 데 도움이 될 것이다.**

- `SMART UI 장점`
  - 애플리케이션이 단순한 경우 생산성이 높고 효과가 즉각적으로 나타난다.
  - 다소 능력이 부족한 개발자도 약간의 교육으로 이러한 방식으로 업무를 진행할 수 있다.
  - 요구사항 분석 단계에서 결함이 발생하더라도 사용자에게 프로토타입을 배포한 후 요구에 맞게 제품을 변경해서 문제를 해결할 수 있다.
  - 애플리케이션이 서로 분리되므로 규모가 작은 모듈의 납기 일정을 비교적 정확하게 계획할 수 있다. 부가적이고 간단한 작업만으로도 시스템을 확장하기가 수월할 수 있다.
  - 관계형 데이터베이스와 잘 어울리고 데이터 수준의 통합이 가능하다.
  - 4세대 언어 도구와 잘 어울린다.
  - 애플리케이션을 인도했을 때 유지보수 프로그래머가 이해하지 못하는 부분을 신속하게 재작업할 수 있다. 이는 변경의 효과가 특정 UI에 국한되기 때문이다.
- `SMART UI 단점`
  - 데이터베이스를 이용하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않다.
  - 행위를 재사용하지 않으며 업무 문제에 대한 추상화가 이뤄지지 않는다. 업무 규칙이 적용되는 연산마다 업무 규칙이 중복된다.
  - 신속한 프로토타입 작성과 반복주기가 SMART UI가 지닌 태생적인 한계에 도달하게 된다. 이는 추상화의 부재로 리팩터링의 여지가 제한되기 때문이다.
  - 복잡성에 금방 압도되어 애플리케이션의 성장 경로가 순전히 부가적인 단순 응용으로만 향한다. 우아한 방법으로 더욱 풍부한 행위를 갖출 수 있는 방법은 없다.

- **이러한 패턴을 의식적으로 사용한다면 팀은 다른 접근법에서 요하는 상당한 양의 부하를 피할 수 있을 것이다.**
  - 일반적으로 저지르는 실수는 팀에서 여태까지 수행하고 있지 않던 정교한 설계 접근법을 취하는 것이다.
  - 흔히 저지르면서 큰 대가를 치러야 하는 또 다른 실수는 바로 프로젝트에서 요구하지 않는 복잡한 인프라스트럭처를 구축하고 고성능 도구를 사용하는 것이다.

- SMART UI와 LAYERED ARCHITECTURE의 중간쯤에 위치하는 해법도 있다.
  - **결론적으론 아키텍처에서 응집력 있는 도메인 설계가 시스템의 다른 부분과 느슨하게 결합될 수 있게 도메인 관련 코드를 격리한다면 아마 그러한 아키텍처는 도메인 주도 설계를 지원할 수 있을 것이다.**
- 다른 개발 방식도 제각기 어울리는 분야가 있겠지만 여러분은 복잡함과 유연함과 관련된 다양한 제약을 받아들여야 한다.
  - 도메인 설계를 분리한느 데 실패한다면 이것은 실제로 어떤 상황에서는 재앙이 될 수 있다.
  - 복잡한 애플리케이션을 개발하고 있고, MODEL-DRIVEN DESIGN을 하기로 했다면 고통을 감내하고 필요한 전문가를 확보하며 SMART UI를 피해야 한다.

## 다른 종류의 격리

- 아쉽게도 도메인 모델은 인프라스트럭처나 사용자 인터페이스의 영향을 받는다.
  - 따라서 모델에 완전히 통합되지 않는 기타 도메인 구성 요소를 다뤄야 한다.
  - 또한 같은 도메인에 대해 서로 다른 모델을 사용하는 다른 개발팀에 대처해야할 것이다.
  - 이렇듯 갖가지 이유로 도메인 모델이 불분명해지고 모델의 효용성을 잃어버리게 될 수도 있다.
  - 이 관점에서 `모델의 무결성 유지`, `BOUNDED CONTEXT`와 `ANTICORRUPTION LAYER`와 같은 패턴을 책 후반부에서 알아본다.
- 결론적으로 도메인을 격리할 때의 가장 좋은 점은 부수적인 것을 배제하고 도메인 설계에만 집중할 수 있다는 것이다.

# 05. 소프트웨어에서 표현되는 모델

- 여러 모델 요소 가운데 모델을 표현하는 세 가지 패턴 엔티티, 값 객체, 서비스에 대해서 알아보자.
- 도메인 개념을 담는 객체를 정의하는 일은 겉으로는 매우 쉬워 보여도 의미상의 미묘한 차이로 발생할 수 있는 중대한 문제가 잠재되어 있다.
- 이 세 가지 패턴으로 일정한 구분법을 알아보자.
- 어떤 객체를 정의할 때 해당 객체가 한 패턴이나 다른 무언가를 분명하게 따르게 한다면, 그 객체는 더 명확해지고 견고한 설계를 위한 구체적인 설계 결정을 내리는 데 도움이 될 것이다.

## ENTITY(엔티티)

> 수많은 객체는 본질적으로 해당 객체의 속성이 아닌 연속성과 식별성이 이어지느냐를 기준으로 정의된다.
>
- `엔티티`, `참조객체`라고도 한다.
- `연속성`(continuity)과 `식별성`(identity)가 `엔티티`와 `값 객체`를 구분하는 가장 기본적인 방법이다.
  - 식별성: 각종 상태를 바탕으로 추적되거나 서로 다른 구현에 걸쳐 존재하는 것

- **개념적 실벽성은 객체와 해당 객체의 저장 형태, 전화를 거는 사람과 같은 현실의 행위자(actor)의 구현 사이에서 일치해야 한다. 단, 그 안에 필드들(속성)은 일치하지 않을 수도 있다.**
- 기본적으로 해당 객체의 식별성을 정의할 경우 그 객체를 엔티티라고 한다
  - 엔티티는 모델링과 설계상의 특수항 고려 사항이 포함되는데,
  - 자신의 생명주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성을 유지해야하며
  - 이를 추적하려면 식별성이 정의되어 있어야한다.
  - 그리고 엔티티에 포함된 특정 속성보다는 정체성에 초점을 맞춰서 클래스 정의와 책임, 속성, 연관관계를 정의해야한다.
  - 엔티티가 급격하게 변형되지 않거나 생명주기가 복잡하지 않더라도 의미에 따라 엔티티를 분류한다면 무데링 더욱 투명해지고 구현은 견고해질 것이다.
- `몇가지 팁`
  - **한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아라.**
  - **클래스 정의를 단순하게 하고 생명주기의 연속성과 식별성에 집중하라.**
  - **객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의하라.**
  - **객체의 속성으로 객체의 일치 여부를 판단하는 요구사항에 주의하라.**
  - **각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라.**
    - 모델에서 식별성을 구분하는 방법은 어디서든 일치해야하며 모델이 동일하다는 것이 무슨 의미인지 정의해야 한다.

## VALUE OBJECT(값 객체)

- 개념적 식별성이 없는 객체도 많은데, 이런 객체는 사물의 어떤 특징을 묘사한다.
- 이런 것들은 `값 객체`에 속하고 이 객체는 사물을 서술하며 자체적인 특징을 비롯해 모델에 중요한 의미를 가진다.
  - 식별성 관리가 필요하다면 엔티티 아니라면 값 객체. 따라서 도메인마다 이는 다르게 설계할 수 있다.
  - e.g. 전기 공급의 목적지가 주소인 경우 주소는 엔티티가 될 수도 있고, 모델에서 주소 속성이 포함된 엔티티인 “거주지” 를 만들 수도 있다. 이렇게되면 주소는 값 객체일 것이다
- 값 객체는 다른 여러 객체를 조립한 것일 수도 있고 엔티티를 참조할 수도 있다.
  - e.g. 지도 서비스에서 두 도시를 연결하는 경로(Route) 객체는 두 도시, 하나의 고속도로 등 엔티티를 참조할 수 있다. 이 경우 Route는 엔티티를 참조하지면 VALUE에 해당한다.
- **모델에 포함된 어떤 요소의 속성에만 관심이 있다면 그것을 값 객체로 분류하라**
  - 값 객체가 전하는 속성의 의미를 표현하게 하고 관련 기능을 부여하라
  - **또한 불변적(Immutable)으로 다뤄서 사이드 이펙트를 방지하라.**
    - 물론 트레이드오프를 고려하여 의도적으로 변경가능성을 허용하는 경우도 있다.
  - 값 객체에는 아무런 식별성을 부여하지 말고 엔티티를 유지하는 데 필요한 설계상의 복잡성을 피하라.

## SERVICE(서비스)

- `서비스`는 클라이언트 요청에 대해 수행되는 무언가를 의미한다.
  - 소프트웨어 기술 계층에는 수많은 서비스가 있고 서비스는 도메인에도 나타난다.
  - e.g. 소프트웨어에서 수행해야 하는 것에는 해당하지만 상태를 주고받지는 않는 활동을 모델링하는 경우.
- 설계가 매우 명확하고 실용적이라도 개념적으로 어떠한 객체에도 속하지 않는 연산이 포함될 때가 있다.
  - 이러한 문제를 억지로 해결하려 하기보다는 문제 자체의 면면에 따라 서비스를 모델에 명시적으로 포함할 수 있다.
  - 여러 도메인 측면 중에서 객체보다는 행동(action)이나 연산(operation)으로 좀 더 명확하게 표현되는 것도 있는데 이런 경우 어떤 연산의 책임을 특정 `엔티티`나 `값 객체`에 억지로 맡겨서 객체의 정의가 왜곡되거나, 또는 무의미하고 인위적으로 만들어진 객체를 추가하는 것보다는 `서비스`로 표현하는 것이 나을 때가 있다.
  - 그리고 서비스를 정의할 때 이 연산 자체도 객체와 잘 어울리게끔 노력해야 한다.
- 보통 서비스와 같은 행위자는 이름 끝에 `Manager` 와 같은 키워드를 붙인다. 행위자는 자신의 상태를 비롯해 도메인에서 맡고 있는 연산 이상으로는 어떠한 의미도 갖지 않는다.
  - 그럼에도 이러한 해법은 실제 모델 객체를 어지럽히지 않고도 뚜렷이 구분되는 행위의 근거지를 만들어 준다.
- 잘 만들어진 서비스의 특징
  - 연산이 원래부터 엔티티나 값 객체의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
  - 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
  - 연산이 상태를 갖지 않는다.
    - → 사이드 이펙트가 적음
- 서비스도 마찬가지로 연산의 이름을 유비쿼터스 언어의 일부가 되게끔 구성해야한다.
- 응용, 도메인, 인프라스트럭처에 서비스가 각각 존재할 수 있는데, 이는 역할에 따라 잘 분리하자.

## MODULE(모듈)

- MODEL-DRIVEN DESIGN에서 모듈은 모델의 한 부분이므로 도메인의 개념을 반영해야 한다.
- 기술적 고려 사항이 여러가지 있겠지만, 모듈화하는 가장 주된 이유는 바로 인지적 과부하(cognitive overload) 때문이다.
- 모듈로 쪼개지는 것은 코드가 아닌 `개념`이다.
  - **어떤 사람이 한 번에 생각해낼 수 있는 양에는 한계가 있다.**
    - 따라서 결합도를 낮춰야하고,
  - **일관성이 없는 단편적인 생각은 획일적인 생각을 섞어놓은 것처럼 이해하기 어렵다.**
    - 따라서 응집도를 높여야 한다.
- 두 모델 요소가 서로 다른 모듈로 분리될 때, 각 요소는 이전에 비해 좀 더 간접적인 관계에 놓이게 되는데 결합도가 낮다면 모델 요소의 위치 파악하는 부담이 줄어든다.
  - 즉, 어떤 모듈의 내용을 분석할 때 해당 모듈의 내용물과 상호작용하는 것에 대해 조금만 알고 있어도 분석이 가능해진다.
- **유비쿼터스 언어를 구성하는 것으로 모듈의 이름을 지어라.**
  - **모듈 구조와 모듈 이름은 도메인에 통찰력을 줄 수 있어야 한다.**
- **유연함이 필요한 경우에만 유연함을 추구하라.**
  - MODEL-DRIVEN DESIGN의 효과를 누리고자 하는 프로젝트에서 이러한 희생의 대가는 희생으로 당면한 문제를 해결하지 못할 경우가 너무나도 클 것이다.
- 기술적 정교함이 주도하는 패키지화 계획에는 두 가지 비용이 따른다.
  - 프레임워크의 분할 관례 탓에 개념적 객체를 구현하는 요소가 서로 떨어져 있으면 더는 코드에서 모델이 드러나지 않는다.
  - 머릿속에서 다시 합칠 수 있는 만큼밖에 분할돼 있지 않은데 프레임워크에서 그렇게 분할된 결과를 모조리 사용해버리면 도메인 개발자들은 모델을 의미 있는 조각으로 나누는 능력을 잃어버리게 된다.
  - **따라서 단순하게 유지하는 편이 가장 좋다.**
    - 기술 환경에 필수적이거나 실질적으로 개발에 도움이 되는 최소한의 분할 규칙만을 선택하라.
    - 가령 복잡한 데이터 영속화 코드를 객체의 행위적인 측면에서 분리하면 리팩터링이 쉬워질 수도 있다.
- **패키지화를 바탕으로 다른 코드로부터 도메인 계층을 분리하라.**
  - 그렇게 할 수 없다면, 가능한 한 도메인 개발자가 자신의 모델과 설계 의사결정을 지원하는 형태로 도메인 객체를 자유로이 패키지화할 수 있게 하라.

### 객체가 아닌 요소를 객체지향 시스템에 혼합할 때 주의점

- MODEL-DRIVEN DESIGN이 객체지향적일 필요는 없지만 표현력이 풍부한 모델 구성물(객체나 규칙, 또는 워크플로)의 구현에 분명 의존한다.
- 이용 가능한 도구가 그와 같은 표현력을 촉진하지 못하고 표현력이 풍부하지 않은 구현을 만들어낸다면 그것은 부가적인 패러다임의 이점을 잃어버리게 할 것이다.
- 다음 4가지 법칙을 주의하자.
  - **구현 패러다임을 도메인에 억지로 맞추지 않는다.**
    - 도메인에 관한 사고방식은 반드시 하나만 있는 것은 아니다. 패러다임에 어울리는 모델 개념을 찾아라
  - **유비쿼터스 언어에 의지한다.**
    - 각 도구가 서로 엄밀한 관계에 있지 않더라도 언어를 매우 일관되게 사용하면 설계가 분산되는 것을 방지할 수 있다.
  - **UML에 심취하지 않는다.**
    - 사람들이 UML 다이어그램과 같은 도구에 집착해서 그리기 쉬운 방향으로 모델을 왜곡하는 것을 주의하라.
    - UML에 제약조건을 표현하는 기능이 포함돼 있긴 하지만 그것만으론 부족하고
        다른 어떤 그리기 방식이나 간단한 문장으로 설명을 써놓는 편이 객체를 바라보는 특정 관점을 나타내고자 도식 방법을 이상하게 바꾸는 것보다 낫다.
  - **회의적이어야 한다.**
    - 실제 도구가 제 몫을 하고 있는지에 대해서 생각해보자.
    - 단순히 어떤 규칙이 있다고 해서 값비싼 룰 엔진이 필요한 건 아니다.
    - **약간 덜 깔끔하겠지만 규칙은 객체로 표현할 수 있으며, 복합적인 패러다임은 문제를 터무니없이 복잡하게 만든다.**
