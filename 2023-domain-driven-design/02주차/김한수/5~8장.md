
- [06~08](#0608)
- [06. 도메인 객체의 생명주기](#06-도메인-객체의-생명주기)
  - [Aggregate](#aggregate)
  - [Factory](#factory)
    - [Factor를 잘 설계하기 위한 기본 요건](#factor를-잘-설계하기-위한-기본-요건)
  - [Repository](#repository)
    - [Repository의 이점](#repository의-이점)
- [07. 언어의 사용(확장 예제)](#07-언어의-사용확장-예제)
- [08. 도약](#08-도약)
  - [기회](#기회)
  - [기본에 집중하라](#기본에-집중하라)

# 06~08

# 06. 도메인 객체의 생명주기

- 모든 객체에는 생명주기가 있다.
  - 도메인 객체에도 생명주기가 있는데, 이것은 여러 상태 변화를 겪고 갖가지 불변식이 적용된다.
  - 이러한 객체들을 관리하는 데 실패한다면 모델 주도 디자인을 시도하는 것이 쉽게 좌절될 수 있다.
- 도메인 객체의 관리 관련 문제들
  - 생명주기 동안의 무결성 유지하기
  - 생명주기 관리의 복잡성과 모델이 난해해지는 것을 방지하기

- 위 문제들을 이 장에서는 세 가지 패턴을 이용해 해결한다
  - `Aggregate`(집합체)
    - 소유권과 경계를 명확히 정의함으로써 모델을 엄격하게 만들어 객체 간의 연관관계가 혼란스럽지 않게 함.
    - 이 패턴은 생명주기상의 전 단계에 걸쳐 도메인 객체의 무결성을 유지하는데 매우 중요함.
  - `Factory`
  - `Repository`

## Aggregate

- Aggregate는 우리가 데이터의 변경의 단위로 다루는 연관 객체의 묶음을 말한다.
- Aggregate에는 root와 boundary가 존재하며 이 각각은 다음과 같다.
  - 경계(boundary)
    - 경계는 aggregate에 무엇이 포함되고 포함되지 않는지를 정의한다.
  - 루트(root)
    - 루트는 단 하나만 존재하며 aggregate에 포함된 특정 엔티티를 가리킨다.
    - 객체 안의 객체는 서로 참조할 수 있지만, 경계 바깥의 해당 aggregate의 구성요소 가운데 루트만 참조할 수 있다.
    - 루트 이외의 엔티티는 지역 식별성(local identity)을 지니며, 지역 식별성은 aggregate 내에서만 구분되면 된다.
      - 이는 해당 aggregate의 경계 밖에 위치한 객체는 루트 엔티티의 컨텍스트 말고는 aggregate의 내부를 볼 수 없기 때문!
- **개념적 Aggregate를 구현하려면 모든 트랜잭션에 적용되는 다음과 같은 규칙이 필요하다.**
  - 루트 엔티티는 전역 식별성을 지니며, 궁극적으로 불변식을 검사할 책임이 있다.
  - 루트 엔티티는 전역 식별성, 경계 안의 엔티티는 지역 식별성을 지니며 이러한 지역 식별성을 해당 aggregate 안에서만 유일하다.
    - 밖에서 볼때는 추상화되어 상관쓰지 않아도 된다.
  - aggregate의 경계 밖에서는 루트 엔티티를 제외한 aggregate 내부의 구성요소를 참조할 수 없다.
    - 루트 엔티티가 내부 엔티티에 대한 참조를 다른 객체에 전달해 줄 수는 있지만 그러한 객체는 전달받은 참조를 일시적으로만 사용할 수 있고, 참조를 계속 보유하고 있을 수는 없다.
    - 루트는 값 객체의 복사본을 달느 객체에 전달해 줄 수 있으며, 복사본에서는 어떤 일이 일어나든 사이드 이펙트가 없다. 이것은 복사본이 단순한 value이고 aggregate와는 더 이상 연관관계를 맺지 않을 것이기 때문!
  - 데이터베이스 질의를 이용하면 aggregate의 루트만 직접적으로 획득할 수 있다. 달느 객체는 모두 aggregate를 탐색해서 발견해야 한다.
  - aggregate 안의 객체는 다른 aggregate의 루트만 참조할 수 있다.
  - 삭제 연산은 aggregate 경계 안의 모든 요소를 한번에 제거해야 한다. (GC를 이용하면 이렇게 하기 쉽다.)
  - aggregate 경계 안의 어떤 객체를 변경하더라도 전체 aggregate의 불변식은 모두 지켜져야 한다.
- **aggreagate는 생명주기의 전체 단계에서** `불변식이 유지돼야 할 범위`**를 표시해준다.**

## Factory

어떤 객체나 전체 Aggregate를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 Factory가 캡슐화를 제공해준다.

- 어떤 객체를 생성하는 것이 그 자체로 주요한 연산이 될 수 있지만 복잡한 `조립 연산`은 생성된 객체의 책임으로 어울리지 않는다.
  - 이런 책임을 클라이언트에 위임하면 이해하기 어렵고 볼품없는 설계가 만들어질 수 있다.
  - 클라이언트에서 직접 필요로 하는 객체를 생성하면 설계가 지저분해지고 조립되는 객체나 Aggregatae의 캡슐화를 위반하며, 클라이언트와 생선된 객체의 구현이 지나치게 결합된다.
  - **이럴 때 Factory에게 이 조립 연산을 위임하고 클라이언트 입장에서 쉬운 인터페이스를 유지하라.**
- `구현 케이스`
  - Factory Method(팩토리 메서드)
  - Abstract Factory(추상 팩토리)
  - Builder(빌더)

### Factor를 잘 설계하기 위한 기본 요건

- 생성 방법은 원자적(atomic)해야하고
- 생성된 객체나 Aggregate의 불변식을 모두 지켜야하며
- factory는 일관성 있는 상태에서만 객체를 만들어 낼 수 있어야 함.
  - entity의 경우 전체 aggregate를 생성하며 이 때, 모든 불변식을 충족하고 선택적인 요소도 추가되어야 함.
  - value object의 경우에는 모든 속성이 올바른 최종 상태로 초기화되는 것을 의미함.
  - 또한 인터페이스를 통해 올바르게 생성할 수 없는 객체를 요청할 수 있다면, 적절한 예외가 발생시키는 등 완성된 객체를 반환할 수 있도록 해야함.
- factory는 생성된 클래스보다는 생성하고자 하는 타입으로 추상화되어야 함
  - Gamma et al. 1995에서 소개한 세련된 factory 패턴이 도움이 될 것이라고 함.
    - 디자인 패턴 책 말하는듯
    - [https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612)

- Factory는 객체의 `생성`과 `재구성`(reconstitution)이라는 `생명주기 전이`(trainsition)을 캡슐화함
  - `생명주기 전이`는 도메인 설계 중 복잡성을 노출하는 것 중 하나이고
  - DB와 같은 영구 저장소에 들어갔다 나올 때 전이가 일어난다.
  - 이러한 전이는 보통 `Repository`의 책임으로 가져간다.

## Repository

- **객체가 도메인 객체가 아니라 단순 데이터를 담는 컨테이너가 되지 않게 주의하라**
  - 클라이언트 개발자는 항상 실용적으로 데이터를 fetch하고 싶어한다.
  - 그래서 이들이 도메인 객체의 참조를 얻게 구조적으로 둔다면 이들은 좀 더 탐색 가능한 연관관계를 추가해 모델을 엉망으로 만들 수 있다.
    - 이렇게 되면 결국 데이터 접근 인프라를 적용하는 데 급격한 복잡성으로 클라이언트 코드가 빠르게 복잡해지고
    - 도메인 계층에 대한 개발자들의 이해 수준을 낮춰 모델을 도메인 계층과 동떨어진 것으로 만들게 될 것이다.
- `Aggregate` 내부에 존재하는 모든 객체는 `루트`에서부터 탐색을 토대로 접근하는 것 말고는 접근이 금지되어 있다.
- `Repository`는 Aggregate 루트에 대한 **접근을 제공하는 각종 응집력있는 책임이** 포함된다
  - 대충 클라이언트가 join하는 걸 단순화하고 완성된 모델을 내려주는 것까지 포함.
  - 객체를 추가하고 제거하는 메서드를 제공하고 이 메서드가 실제로 DB와 같은 영구 저장소에서 데이터룰 추가, 제거하는 것까지 캡슐화하라.
  - **실질적으로 직접 접근이 필요한 Aggregate 루트에 대해서만 repository를 제공하라**
  - **모든 객체 저장과 접근은 Repository에 위임하고 클라이언트는 모델에 집중하게 하라**

### Repository의 이점

- 영속화된 객체를 획득하고 해당 객체의 생명주기를 관리하기 위한 단순한 모델을 클라이언트에게 제시
- 영속화 기술과 다수의 저장소와 관련된 영역으로부터 애플리케이션과 도메인 설계를 분리해준다.
- 객체 접근에 관한 설계 결정을 전해준다.
- 테스트에서 mock 구현을 손쉽게 대체할 수 있음

# 07. 언어의 사용(확장 예제)

- 화물 운송 도메인을 기준으로한 예시

# 08. 도약

- 리팩터링의 효과는 선형적으로 증하가지 않고 순간 가치가 **도약**하는 시점이 있다.
- 리팩터링은 엔트로피와의 싸움이며 레거시 시스템이 퇴보하는 것을 막는 최전선에 놓여 있다.
- 이 도약하는 시점은 소규모 리팩토링 과정을 거쳐 통찰력이 쌓이고 그 과정에서 서서히 모습을 드러낸다.

- 저자의 심층 모델을 설계하고 리팩터링한 뒤 도약한 사례
  - 도메인 언어에 대해 이해하고 리팩터링하니 유비쿼터스 언어로 이야기하는 게 자연스러워졌음
  - 3주라는 시간을 PM과 이야기하여 확보함
    - 이 기간 동안 신규 기능 개발은 정지됨

## 기회

- 도메인에 대해 좀 더 이해하고 심층 모델로 도약할 수 있는 기회가 찾아올 때 우리는 종종 리팩터링에 대한 두려움을 느낀다.
  - 이건 큰 기회와 더 큰 위험을 수반하는 것이다. 시점이 적절하지 못할 수도 있다.
  - 그렇지만 많은 프로젝트에서 모델과 설계에서 나타나는 가장 중요한 발전은 이러한 리팩토링을 통한 도약을 거쳐 이뤄진다.

## 기본에 집중하라

- 도약을 위해 프로젝트 진행을 정지한 채 마비상태에 빠져서는 안 된다.
  - 일반적으로 수많은 적정 규모의 리팩터링을 수행한 후에야 도약이 나타나기 때문이다.
- 도약이 등장할 수 있는 무대를 마련하려면 지식탐구와 함께 인내심을 가지고 유비쿼터스 언어를 만드는 일에 집중해야 한다.
- 중요한 도메인 개념을 조사하고 그러한 개념을 모델 내에 명시적으로 표현하며
  - 유연해지도록 설계를 정제하고
  - 모델의 정수를 추출해야 한다.
- **도약에 앞서 명확함을 늘리는 데 도움이 되는 이러한 예측 가능한 영역을 만드는 노력을 멈춰서는 안 된다.**
  - 똑같은 일반적인 개념의 틀에 갇혀 있더라도 점진적으로 모델의 깊이를 더하는 적정 규모의 개선 작업을 망설이지 마라.
  - 또한 너무 멀리 내다보려고 하다가 마비상태에 빠져서는 안 된다.
  - 그렇지만 기회를 놓치지 않기 위해 예의주시하라.
- **유비쿼터스 언어가 아니라 기술적인 언어들로 도메인을 설명하고 있다면 잘못된 설계인지 검토하라**
