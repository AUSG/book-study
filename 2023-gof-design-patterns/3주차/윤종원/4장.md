# Table of contents

- [4장](#4)
    - [장식자(DECORATOR)](#decorator)
    - [퍼사드(FACADE)](#facade)
    - [플라이급(FLYWEIGHT)](#flyweight)
    - [프록시(PROXY)](#proxy)
    - [구조 패턴에 대한 논의](#---)
        - [적응자 패턴 대 가교 패턴](#----)
        - [복합체 패턴 대 장식자 패턴 대 프록시 패턴](#-------)

## 장식자(DECORATOR)

- 객체에 동적으로 새로운 책임을 추가할 수 있도록 해준다
- 새로운 기능을 추가할 때 서브클래스를 생성하는 것보다 더 융통성 있는 방법을 제공한다


- 이를 상속으로도 달성할 수 있지만 이는 정적이고 클래스가 너무 많이 늘어난다
- 더 나은 방법은 해당 기능을 가진 장식자를 추가하는 것이다
- 장식자는 같은 인터페이스를 가지므로 사용자에게는 장식자의 존재가 숨겨진다
- 이 덕분에 장식자를 무한으로 중첩하는 것도 가능하다


- 동적으로 또한 투명하게 각각의 객체에 새로운 책임을 추가하고 싶을 때 사용
- 상속으로 서브클래스를 만드는 데 한계가 왔을 때 사용


- 단순한 상속보다 설계가 더욱 유연해진다
    - 클래스 수도 줄이고, 동적으로 기능 조정 가능
- 클래스 계통의 상부 클래스에 많은 기능이 누적되는 것을 피할 수 있다
    - 데코레이터에 이러한 책임을 나눌 수 있다
- 장식자를 사용하면 작은 규모의 객체가 많아진다
    - 이를 잘 인지하고 있으면 유용하겠지만 그렇지 않다면 관리할 객체가 많아져 복잡해질 수 있다.


- 컴포넌트 클래스가 매우 복잡하고 무거운 특성을 가진다면 전략 패턴이 더 나은 해결 방법이다
    - 전략은 자신만의 인터페이스를 가질 수 있으므로

## 퍼사드(FACADE)

- 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공
- 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의


- 퍼사드 패턴은 서브시스템에 대한 단순하면서도 기본적인 인터페이스를 제공해 대부분의 개발자들에게 적합한 클래스 형태를 제공
- 퍼사드를 통해 사용자와 다른 서브시스템간의 결합도를 줄일 수 있다
- 서브시스템을 계층화시킬 때, 퍼사드 패턴을 사용하면 각 서브시스템의 계층에 대한 접근점 제공
- 응용프로그램 쪽에서 서브시스템 클래스를 사용하는 것을 완전히 막지는 않는다. 퍼사드를 사용할지 서브시스템 클래스를 직접 사용할지 결정할 수 있다


- 추상 팩토리는 퍼사드에 대한 대안으로, 플랫폼에 종속적인 클래스를 감추는 데 쓴다
- 중재자 패턴도 기존의 클래스의 기능성을 추상화한다는 점에서 퍼사드 패턴과 비슷하다
    - 다만, 중재자 패턴은 참여한 객체가 서로 알지 못하도록 한다면 퍼사드는 서브시스템 인터페이스 자체를 추상화해 사용을 용이하게 하려는 목적을 갖는다

## 플라이급(FLYWEIGHT)

- 객체를 공유해서 다수의 작은 객체들을 효과적으로 지원


- 작은 것 하나하나를 객체로 관리하면 유용한 면이 이씾만 비용적인 문제가 발생한다.
- 플라이급 패턴은 이를 객체 공유로 해결한다


- 플라이급 객체는 공유 가능한 객체지만 독립적인 객체로도 동작한다.
- 즉, 공유될 수 없는 객체의 인스턴스와 구분되지 않는다


- 본질적(intrinsic) 상태와 부가적(extrinsic) 상태가 존재한다
- 본질적 상태는 상황과 무관한 상태로 플라이급 객체에 저장되어야 한다
- 그러나 상황에 종속적인 것들은 공유될 수 없으므로 사용자 객체가 다룬다


- 대량의 객체를 사용하고, 그로 인해 비용이 너무 높고, 대부분의 객체 상태는 부가적인 것이고 많은 부분을 적은 수의 공유 객체로 대체할 수 있을 때 사용


- 저장소 비용을 절약을 가져오지만 부가적인 상태를 만들어 부가적인 상태에 대한 연산, 그리고 이에 대한 런타임 비용이 생겨날 수도 있다
- 많은 객체가 공유될수록 저장소 비용 절약이 커지므로 많은 것이 저장되고 공유될 수 있을 때 사용


- 복합체 패턴과 조합해 그래프와 같이 계층적 구조를 모델링 하는데 사용되기도 한다
- 상태 패턴 또는 전략 패턴을 플라이급 객체로 구현할 수도 있다

## 프록시(PROXY)

- 다른 객체에 대한 접근을 제어하기 위한 객체


- 객체에 대한 접근을 제어하는 한 가지 이유는 실제로 그 객체를 사용할 수 있을 때까지 객체 생성과 초기화에 들어가는 비용 및 시간을 물지 않겠다는 것


- 리모트에 있는 객체를 로컬처럼 다루게 해주거나, 실제로 필요할 때 초기화를 담당하거나, 객체에 대한 접근을 제어하거나, 접근이 일어날 때 추가적인 행동을 수행하는 등의 프록시가 존재
    - 스마트 포인터


- 프록시를 사용하면 성능을 최적화하거나, 사실을 숨기거나, 객체에 대한 관리를 할 수 있다
- 혹은 copy-on-write도 최적화 프록시의 일종


- 어댑터는 객체의 인터페이스와 다른 인터페이스를 제공하지만 프록시는 동일한 인터페이스를 제공
- 데코레이터는 프록시와 구현 방법이 비슷한데 목적이 다르다
    - 프록시 종류에 따라 구현 방법이 달라지기도 한다

## 구조 패턴에 대한 논의

- 결국 상속이나 복합을 사용해서 문제를 해결하기 때문에 패턴들이 다 비슷비슷 할 수밖에 없다.
- 차이점은 결국 왜 이 패턴을 써야 하는가다.

### 적응자 패턴 대 가교 패턴

- 둘 다 객체에 대한 직접 접근 대신 우회적 방법으로 접근해 유연성을 증대
- 두 패턴의 차이는 목적
    - 적응자
        - 인터페이스 간의 불일치 해결
    - 가교
        - 추상적 개념, 구현을 분리하고 이를 연결


- 적응자 패턴은 이미 개발이 완료된 경우 주로 사용
- 가교 패턴은 추상적 개념을 구현하는 방법이 여러 가지이고 각각 독립적으로 진화할 수 있음을 발견했을 때 사용
    - 즉, 설계가 완료되기 전

### 복합체 패턴 대 장식자 패턴 대 프록시 패턴

- 복합체 패턴과 장식자 패턴은 구조가 비슷
    - 여러 객체를 조직화하기 위해 재귀적 합성 기법을 사용
    - 다만 역시 목적은 다르다


- 장식자 패턴은 상속 없이 객체에 새로운 서비스를 추가하는 것이 목적
- 복합체 패턴은 클래스 구조화에 초점
    - 관련 객체를 하나의 인터페이스로 다룰 수 있도록 일관성 부여


- 다만 이런 의도들이 상충되는 것은 아니고 상호보완적이므로 함께 사용할 때도 많다


- 프록시 패턴도 이와 구조가 비슷
    - 다만 프록시는 기능 제공 주체에 접근할 수 있을 뿐이지만 장식자는 기능을 담당하기도 한다

