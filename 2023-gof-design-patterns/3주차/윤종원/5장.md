- [5장](#5)
    - [서론](#)
    - [책임 연쇄(CHAIN OF RESPONSIBILITY)](#-chain-of-responsibility)
        - [명령(COMMAND) 패턴](#command-)
    - [해석자(INTERPRETER)](#interpreter)
    - [반복자(ITERATOR)](#iterator)
    - [중재자(MEDIATOR)](#mediator)

## 서론

- 행동 패턴은 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고맂므을 어느 객체에 정의하는 것이 좋은지 등을 다룬다
- 객체나 클래스에 대한 패턴을 정의하는 것이 아니라 그들 간의 상호작용에 대하여 정의하는 것


- 행동 클래스 패턴은 클래스 사이의 행동 책임을 분산시키기 위해 상속을 사용
- 행동 객체 패턴은 상속보다는 복합을 통해서 객체 사이의 행동 처리의 책임을 분산
    - 여기서 중요한 것은 관련된 객체들이 서로를 어떻게 알 수 있는가

## 책임 연쇄(CHAIN OF RESPONSIBILITY)

- 메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴


- 객체의 연결 고리에 존재하는 객체는 누구든지 동일한 요청을 처리할 수 있어야 한다.
- 이를 위해서 연결 고리의 모든 객체들은 공통의 인터페이스를 가져야 한다.


- 하나 이상의 객체가 요청을 처리하고, 어떤 것이 선행자인지 모를 때
- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때


- 객체 간의 행동적 결합도가 적어진다
    - 요청을 어떻게, 누가 처리하는지 알 필요가 없다
- 객체에게 책임을 할당하는 데 유연성을 높일 수 있다
- 메시지 수신이 보장되지는 않는다


- 기존의 연결 정보를 활용하거나, 새롭게 연결하거나


- 처리 요청을 객체로 만들면, 요청을 처리하는 객체가 런타임에 타입을 확인하고, 필요한 정보를 얻는 것이 가능하다


- 보통 사용자의 이벤트를 처리하기 위해서 이 패턴을 많이 사용한다


- 복합체 패턴과 함께 대부분 사용된다

### 명령(COMMAND) 패턴

- 요청 자체를 캡슐화
- 요청이 서로 다른 매개변수를 만들고, 요청을 대기시키거나 로깅하고, 되돌릴 수 있는 연산을 지원


- 요청받은 연산이 무엇인지, 이를 처리할 객체가 누구인지에 대한 아무런 정보 없이 임의의 객체에 메시지를 보내야 할 때도 있다
- 명령 패턴은 요청 자체를 객체로 바꿔 요청을 처리
    - 이 객체는 다른 객체처럼 저장되거나 전달될 수 있다


- 여러 개의 커맨드를 종합하면 매크로 커맨드도 가능
- 명령을 동적으로 교체하는 것도 가능


- 수행할 동작을 객체로 매개변수화하면 콜백 함수와 비슷


- 실행 취소 기능, 혹은 재적용에 대한 구현도 쉽게 가능


- 여러 연산을 조합한 상위 수준의 연산을 써서 시스템을 구조화하고 싶을 때 유용
    - 트랜잭션처럼


- 연산을 호출하는 객체와 연산을 수행하는 객체를 분리
- 새로운 명령 추가가 쉽다


- 취소 또는 반복 명령을 지원하기 위해서는 추가적인 상태 관리가 필요

## 해석자(INTERPRETER)

- 언어의 문법에 대한 표현을 정의하면서 이를 사용해 해당 언어로 기술된 문장을 해석


- 특정 종류의 문제가 자주 발생하면 간결한 언어를 사용해 문제를 문장으로 표현하는 것이 나을 수도 있다
    - 정규 표현식처럼


- 해석자 패턴은 클래스를 이용해 각각의 문법이 갖는 규칙을 정의


- 해석이 필요한 언어가 존재하거나 AST로 그 언어의 문장을 표현하고자 할 때 좋다
- 정의할 문법이 간단할 때 사용하면 좋다
- 효율성은 큰 고려 사항이 아니다
    - 효율을 중시하면 파스 트리를 직접 해석하는 것이 아니라 파스 트리를 다른 형태로 번역하는 것이 좋다
    - 이때 번역에도 해석자 패턴을 사용할 수 있다


- 문법의 변경과 확장이 쉽다
- 문법 구현이 쉽다
- 복잡한 문법은 관리가 어렵다
    - 컴파일러 생성기나 파서 생성기를 사용하는 것이 바람직
- 표현식을 해석하는 새로운 방법을 추가할 수 있다


- 플라이급 패턴을 사용하면 효율을 높일 수 있다

## 반복자(ITERATOR)

- 내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공


- 새로운 내용을 삽입, 삭제하거나 순회하는 내용을 반복자 객체에 정의하는 것
- 다양한 순회 알고리즘을 구현하는 것도 가능


- 집합 객체의 다양한 순회 방법을 제공
- 집합 객체에 따라 하나 이상의 순회 방법을 제공


- 누가 반복을 제어?
    - 외부 반복자
        - 사용자가 반복을 제어
        - 순회를 계속하고 다음번 원소를 명시적으로 요청
        - 내부 반복자보다 유연한 방법
    - 내부 반복자
        - 반복자 자신이 제어를 담당
        - 처리할 연산을 내부 반복자에게 전달
        - 사용하기가 쉽다


- 순회 중에 값이 수정되면 위험하다
    - 가장 쉬운 방법은 복사본 순회
    - 그러나 비용이 많이 든다
    - 견고한 반복자가 되려면 순회 중에는 삽입이나 삭제가 발생해서는 안 된다
        - 이는 보통 집합 객체에 반복자를 등록하는 방식을 사용
        - 삽입이나 삭제시 집합 객체가 보유한 반복자의 상태도 함께 벼경

## 중재자(MEDIATOR)

- 한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의
- 객체들이 직접 서로를 참조하지 않도록 해 객체 사이의 약한 결합을 촉진시켜, 개발자가 객체의 상호작용을 독립적으로 다양화시킬 수 있게 만든다


- 시스템을 여러 객체로 분할하면 객체의 재사용을 증대시킬 수 있지만 이러한 분할은 객체 간 상호작용의 급증을 유발하고 이로 인해 오히려 재사용성이 저하될 수도 있다
- 또한 객체가 더 이상 독립적이지 않게 될 수도 있다
- 시스템이 하나의 거대한 덩어리처럼 동작해 행동을 변경하는 것이 어려워진다


- 별도의 중재자 객체를 활용해 상호작용과 관련된 행동을 하나의 객체로 모아서 이런 문제를 피할 수 있다
- 중재자 객체는 객체 그룹 간의 상호작용을 제어하고 조화를 이루는 역할
- 덕분에 객체 사이의 연결 정도가 줄어든다


- 여러 객체가 잘 정의된 형태이지만 복잡한 상호작용을 가질 때, 객체 간의 의존성이 구조화되지 않을 때, 이해하기 어려울 때
- 한 객체가 다른 객체를 너무 많이 참조하고, 상호작용해 객체를 재사용하기 힘들 때
- 여러 클래스에 분산된 행동들이 상속 없이 상황에 맞게 수정되어야 할 때


- 서브클래싱을 제한
    - 다른 객체 사이의 분산된 객체의 행동들을 하나의 객체로 국한
    - 따라서 Colleague 클래스는 여전히 재사용 가능
- Colleague 객체 사이의 종속성 줄임
- 객체 프로토콜 단순화
- 객체 간의 협력 방법 추상화
- 통제가 집중화
    - 상호작용과 관련된 모든 프로토콜을 캡슐화하므로 내부 구현이 매우 복잡해질 수 있다

