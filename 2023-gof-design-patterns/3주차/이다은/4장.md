### 장식자
- 객체에 동적으로 새로운 책임을 추가할 수 있게 함 -> 기능 추가할 때 서브클래스보다 융통성 있는 방법 제공
- 활용성
  - 동적으로, 투명하게, 다른 객체에 영향 주지 않고 개개의 객체에 새로운 책임 추가하기 위해 사용
  - 제거될 수 있는 책임에 사용
  - 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용
- 결과
  - 단순한 상속보다 설계의 융통성 증대
  - 클래스 계통의 상부측 클래스에 많은 기능 누적되는 상황 예방
  - 장식자와 해당 장식자의 구성요소가 동일한 것은 아님
  - 장식자를 사용함으로써 작은 규모의 객체들이 많이 생김
- 구현
  - 인터페이스 일치시키기 (동일한 부모 클래스 상속)
  - 추상 클래스로 정의되는 Decorator 클래스 생략
  - Component 클래스는 가벼운 무게 유지하기
  
### 퍼사드
- 한 서브시스템 내의 인터페이스 집합에 대해 획일화된 하나의 인터페이스 제공
- 결과
  - 서브시스템의 구성요소 보호
  - 서브시스템과 사용자 코드 간의 결합도 약화
  - 서브시스템 클래스를 직접 사용할 수도 있음
- 구현
  - 사용자와 서브시스템 간의 결합도 줄이기
  - 서브시스템 클래스 중 공개할 것과 감출 것 고민하기
  
### 플라이급
- 공유를 통해 많은 수의 소립 객체들을 효과적으로 지원
- 결과
  - 공유해야 하는 인스턴스 전체 수 절감
  - 객체별 본질적 상태의 양 절감
  - 부가적인 상태는 연산되거나 저장될 수 있음
- 구현
  - 부가적 상태 제외
  - 공유할 객체 관리

### 프록시
- 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체 생성
  - 원격지 프록시: 서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체
  - 가상 프록시: 요청이 있을 때만 필요한 고비용 객체 생성
  - 보호용 프록히: 원래 객체에 대한 실제 접근 제어
  - 스마트 참조자: 원시 포인터의 대체용 객체, 실제 객체에 접근이 일어날 때 추가적인 행동 수행
- 결과
  - 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실 숨길 수 있음
  - 가상 프록시는 요구에 따라 객체를 생성하는 등 처리 최적화할 수 있음
  - 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임짐


### 구조 패턴에 대한 논의
- 적응자 패턴 vs 가교 패턴
  - 적응자의 목적은 이미 존재하는 두 인터페이스 간의 불일치 해결
  - 가교 패턴은 추상적 개념과 구현 따로 만들고 이를 연결시키려는 것이 주목적
- 복합체 패턴 vs 장식자 패턴 vs 프록시 패턴
  - 장식자 패턴은 상속 없이 객체에 새로운 서비스를 추가하려는 것이 목적
  - 복합체 패턴은 클래스 구조화에 초점
  - 프록시는 서비스를 제공하는 대상에 참조자를 직접 관리하는 불편함을 해결하려는 목적