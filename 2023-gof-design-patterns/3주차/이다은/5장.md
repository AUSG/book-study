# Chapter 5. 행동 패턴
- 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘을 어느 객체에 정의하는 것이 좋은지 다룸
- 행동 클래스 패턴: 클래스 사이에 행동 책임 분산하기 위해 상속 사용
  - 템플릿 메서드 패턴: 간단, 일반적인 패턴, 알고리즘에 대한 추상화된 정의, 알고리즘 한 단계씩 정의
  - 해석자 패턴: 문법을 클래스 계통으로 구성, 이 클래스들의 인스턴스에 대한 연산으로서 해석자를 구현
- 행동 객체 패턴: 상속보다는 복합을 통해 객체 사이에 행동 처리 책임 분산
  - 중재자 패턴: 관련된 객체 집합 사이의 중재자로 새로운 객체를 하나 도입
  - 책임 연쇄 패턴: 한 객체에게 보낸 메시지가 내부적으로 연결된 다른 객체에게 자동으로 전달
  - 감시자 패턴: 객체 간의 종속성을 정의하고 관리하는 패턴
  - 명령 패턴: 요청 자체를 객체로 만들어서 이 객체를 매개변수로 넘기거나 수행한 명령 리스트에 저장하는 방식으로 사용할 수 있게 함
  - 상태 패턴: 객체의 상태를 또 다른 객체로 정의하여 객체의 상태가 바뀌면 이에 대항하는 객체를 변경할 수 있도록 함
  - 방문자 패턴: 하나의 행동을 여러 클래스에 걸쳐서 분산할 수 있게 해줌
  - 반복자 패턴: 모은 객체들을 순회하거나 차례로 접근하는 방법 제공

### 책임 연쇄
- 메시지를 보내는 객체과 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴
- 활용성
  - 하나 이상의 객체가 요청을 처리해야 하고 그 요청 처리자 중 어떤 것이 선행자인지 모를 때 처리자가 자동으로 확정되어야 할 때 사용
  - 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때 사용
  - 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때
- 결과
  - 객체 간의 행동적 결합도가 적어짐
  - 객체에게 책임을 할당하는 데 유연성을 높일 수 있음
  - 메시지 수신이 보장되지는 않음
- 구현
  - 후속 처리자들의 연결 고리 구현하기
  - 후속 처리자 연결하기
  - 처리 요청의 표현부를 정의
  - 스몰토크를 쓸 때 자동 전달 기능을 이용

### 명령
- 요청 자체를 캡슐화하는 것
- 요청이 서로 다른 사용자를 매개변수로 만들고 요청을 대기시키거나 로깅, 되돌릴 수 있는 연산 지원
- 활용성
  - 수행할 동작을 객체로 매개변수화하고자 할 때 사용
  - 서로 다른 시간에 요청을 명시하고 저장하며 실행하고 싶을 때
  - 실행 취소 기능을 지원하고 싶을 때
  - 시스템이 고장 났을 때 재적용 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때
  - 기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때
- 결과
  - 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리
  - 일급 클래스
  - 명령을 여러 개를 복합해 복합 명령을 만들 수 있음
  - 새로운 명령 객체를 추가하기 쉬움
- 구현
  - 명령 패턴은 수신 객체를 동적으로 발견할 수 있는 능력을 지녀야 함
  - 취소 및 반복 연산 지원
  - 취소를 진행하는 도중 오류가 누적되는 것 피하기
  - C++ 템플릿 사용

### 해석자
- 어떤 언어에 대해 그 언어의 문법에 대한 표현을 정의하며 그것을 사용해 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의
- 활용성
  - 정의할 언어의 문법이 간단함
  - 효율성은 별로 고려할 사항이 아님
- 결과
  - 문법의 변경과 확장이 쉬움
  - 문법의 구현 용이
  - 복잡한 문법 관리 용이
  - 표현식을 해석하는 새로운 방법 추가 가능
- 구현
  - 추상 구문 트리 생성
  - Interpret() 연산 정의
  - 플라이급 패턴 적용해 단말 기호 공유

### 반복자
- 내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법 제공
- 활용성
  - 객체 내부 표현 방식을 모르고도 집합 객체의 각 원소들에 접근하고 싶을 때
  - 집합 객체를 순회하는 다양한 방법을 지원하고 싶을 때
  - 서로 다른 집합 객체 구조에 대해서도 동일한 방법으로 순회하고 싶을 때
- 결과
  - 집합 객체의 다양한 순회 방법 제공
  - Iterator은 Aggregate 클래스의 인터페이스 단순화
  - 집합 객체에 따라 하나 이상의 순회 방법이 제공될 수 있음
- 구현
  - 사용자가 반복 제어 -> 외부 반복자, 반복자 자신이 제어 -> 내부 반복자
  - 커서: Aggregate 클래스에 순회 알고리즘을 정의하고 Iterator에 순회의 상태 저장
  - 견고한 반복자가 되려면 순회 중에는 삽입이나 삭제가 일어나지 말아야 하고 집합 객체를 복사하는 방법을 사용하지 않아야 함
  - Iterator 클래스에는 First(), Next(), IsDone(), CurrentItem() 연산이 꼭 필요함
    - Previous(), SkipTo() 연산을 추가로 가지면 좋음
  - 프록시 패턴을 활용해 다형성을 지닌 반복자를 효율적으로 구현할 수 있음
  - 반복자에는 특수한 접근 권한이 있음
  - 복합체를 위한 반복자, 널 반복자

### 중재자
- 한 집합에 속해있는 객체의 상호작용을 캡슐화 하는 객체 정의
- 활용성
  - 여러 객체가 잘 정의된 형태이기는 하지만 복잡한 상호작용을 가질 때
  - 한 객체가 다른 객체를 너무 많이 참조하고 너무 많은 의사소통을 수행해서 그 객체를 재사용하기 힘들 때
  - 여러 클래스에 분산된 행동들이 상속 없이 상황에 맞게 수정되어야 할 때
- 결과
  - 서브클래싱 제한
  - Colleague 객체 사이의 종속성 줄임
  - 객체 프로토콜을 단순화
  - 객체 간의 협력 방법 추상화
  - 통제 집중화
- 구현
  - 추상 클래스인 Mediator 생략
  - 동료 객체-중재자 객체 간 의사소통