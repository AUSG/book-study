# Decorator Pattern (Wrapper Pattern)

## 배경

자식 클래스들의 합성으로 인한 클래스 수 폭발

## 해결

상속 대신 집합관계 또는 합성을 사용

- 집합 관계 : 한 객체가 다른 객체에 대한 참조를 갖고 일부 작업을 위임
- 상속 : 객체 자체가 부모 클래스에서 행동을 상속한 후 해당 작업을 수행

래퍼는 래핑된 객체와 같은 인터페이스를 구현.

**아래는 래퍼를 사용해 Notifier 클래스 내에 있는 간단한 이메일 알림 행동은 그대로 두고 다른 모든 알림 메서드를 데코레이터로 바꾼 모습**

## 적용

- 객체들이 사용하는 코드를 훼손하지 않으면서 런타임에 추가 행동을 객체들에 할당할 수 있어야 할 때 사용
- 상속을 사용하여 객체의 행동을 확장하는 것이 어색하거나 불가능할 때 사용

## 장단점

### 장점

- 새 자식 클래스를 만들지 않고도 객체의 행동을 확장할 수 있음
- 런타임에 객체들에서부터 책임을 추가하거나 제거할 수 있음
- 객체를 여러 데코레이터로 래핑하여 여러 행동을 합성할 수 있음
- 단일 책임 원칙. 다양한 행동들의 여러 변형들을 구현하는 모놀리식 클래스를 여러 개의 작은 클래스들로 나눌 수 있음

### 단점

- 래퍼들의 스택에서 특정 래퍼를 제거하기 어려움
- 데코레이터의 행동이 데코레이터 스택 내의 순서에 의존하지 않는 방식으로 데코레이터를 구현하기 어려움
- 게층들의 초기 설정 코드가 가독성이 떨어질 수 있음

# Facade Pattern

## 문제

시스템에 여러 서브 시스템이 있고 이들과의 상호작용이 복잡할 때, 클라이언트는 각 서브 시스템의 내부 구조를 알 필요 없이 간단한 인터페이스를 통해 상호작용하기를 원함

## 해결

단일 인터페이스를 제공하여 서브 시스템들의 복잡한 내부 구조를 감춤.

## 적용

- 복잡한 하위 시스템에 대해 제한적이지만 간단한 인터페이스가 필요할 때 사용
  - 프레임워크의 복잡성을 간단한 인터페이스 뒤에 숨김
- 하위 시스템을 계층들로 구성하려는 경우 사용

## 장단점

### 장점

- 복잡한 하위 시스템에서 코드를 별도로 분리할 수 있음

### 단점

- 앱의 모든 클래스에 결합된 전지전능한 객체가 될 수 있음

# Flyweight Pattern

## 문제

많은 수의 유사한 객체들이 사용될 때, 객체들이 많은 메모리를 차지함

## 해결

객체의 공통 부분을 공유하고
개별적 상태는 각 객체에서
관리함으로써
메모리 사용을 최적화

![스크린샷 2023-11-18 오전 8.44.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/af55a34b-9237-4a8d-9996-7f267aeaa8d5/c0283b98-225e-44aa-8da7-1f2d318cf341/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.44.04.png)

## 적용

- 프로그램이 많은 수의 객체들을 지원해야 해서 사용할 수 있는 RAM을 거의 다 사용했을 때만 사용

## 장단점

### 장점

- 유사한 객체들이 많다고 가정하면 많은 RAM을 절약할 수 있음

### 단점

- 플라이웨이트 메서드를 호출할 때마다 콘텍스트 데이터의 일부를 다시 계산해야 한다면 CPU 주기 대신 RAM을 절약하고 있는 것일지도 모름
- 코드가 복잡해지므로 새로운 팀원들은 왜 entity 상태가 그런 식으로 분리되었는 지 모를 수 있음

# Proxy Pattern

## 문제

객체에 직접 접근하는 것이 비효율적이거나 적절하지 않은 상황이 발생.

예를 들면 네트워크 자원, 메모리 집약적 객체, 보안이 중요한 객체 등

## 해결

실제 객체 대신 사용되는 대리 객체를 제공하여 실제 객체에 대한 접근을 제어하고 관리

## 적용

- 지연된 초기화(가상 프록시) : 어쩌다 필요한 무거운 서비스 객체가 항상 가동되어 있어 시스템 자원을 낭비하는 경우, 앱이 시작될 때 객체를 생성하는 대신, 객체 초기화를 실제로 필요한 시점까지 지연할 수 있음
- 접근 제어(보호 프록시) : 특정 클라이언트만 서비스 객체를 사용할 수 있도록 하는 경우 사용할 수 있음.
  - 예를 들어 객체들이 운영 체제의 중요한 부분이고 클라이언트들이 응용프로그램인 경우
- 원격 서비스의 로컬 실행(원격 프록시) : 서비스 객체가 원격 서버에 있는 경우
- 요청들의 로깅(로깅 프록시) : 서비스 객체에 대한 요청들의 기록을 유지하려는 경우
- 요청 결과들의 캐싱(캐싱 프록시) : 클라이언트 요청들의 결과들을 캐시하고 이 캐시들의 수명 주기를 관리해야 할 때, 특히 결과들이 상당히 큰 경우 사용
- 스마트 참조 : 사용하는 클라이언트들이 없어 거대한 객체를 해제할 수 있어야 할 때 사용

## 장단점

### 장점

- 클라이언트들이 알지 못하는 상태에서 서비스 객체를 제어할 수
  있습니다.
- 클라이언트들이신경쓰지않을때서비스객체의수명주기를
  관리할 수 있습니다.
- 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는
  경우에도 작동합니다.
- 개방*/*폐쇄 원칙. 서비스나 클라이언트들을 변경하지 않고도 새
  프록시들을 도입할 수 있습니다.

### 단점

- 새로운 클래스를 많이 도입해야 하므로 코드가 복잡해짐
- 서비스의 응답이 늦어질 수도

# 1. Chain of Responsibility Pattern

> 책임 연쇄 패턴, CoR

## 문제

요청을 처리해야할 때, 여러 객체 중 어떤 객체가 요청을 처리할 지 미리 정하기 어려운 상황

## 해결

요청을 처리할 수 있는 여러 객체들을 체인으로 연결함.

요청은 체인을 따라 전달되며, 각 객체는 요청을 처리하거나 다음 객체로 전달할 수 있음

## 적용

- 다양한 종류의 요청들을 처리할 것으로 예상되지만 정확한 요청 유형들과 순서들을 미리 알 수 없는 경우에 사용
- 특정 순서로 여러 핸들러를 실행해야 할 때 사용
- 핸들러들의 집합과 그들의 순서가 런타임에 변경되어야 할 때 사용

## 장단점

### 장점

- 요청의 처리 순서를 제어할 수 있음
- 단일 책임 원칙 : 작업을 호출하는 클래스들을 작업을 수행하는 클래스들과 분리할 수 있음
- 개방/폐쇄 원칙 : 기존 클라이언트 코드를 손상하지 않고 앱에 새 핸들러를 도입할 수 있음

### 단점

- 일부 요청들은 처리되지 않을 수 있음

# 2. Command Pattern

## 문제

요청을 발행하는 객체와 요청을 수행하는 객체 사이의 결합도를 낮추고자하는 상황

또 요청을 로깅하거나 작업을 취소하는 기능이 필요한 상황

## 해결

요청을 객체 형태로 캡슐화하여 사용자는 요청의 실행을 요청 객체를 통해 제어함

# 3. Iterator Pattern

## 문제

컬렉션의 내부 표현방식을 노출하지 않고 그 내부를 순회하고자 할 때

## 해결

컬렉션의 내부 구조에 관계없이 컬렉션의 요소룰 순회할 수 있는 방법을 제공

# 4. Mediator Pattern

## 문제

여러 객체들이 서로 복잡하게 상호작용하는 시스템에서 객체 간의 결합도가 높아지는 문제가 발생

## 해결

객체들 간의 직접적인 상호작용을 줄이고, 모든 커뮤니케이션을 중재자 객체를 통해 이루어지게 함으로써 객체 간의 결합도를 낮춤
