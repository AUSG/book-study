- 메멘토 패턴
  - 대부분의 개발자는 이 패턴을 ‘실행 취소’와 관련지어 기억한다. 하지만 트랙잭션(= 롤백)들을 처리할 때 필수 불가결한 패턴이다.
  - 객체에 getter, setter 등으로 객체의 캡슐화가 위반될 때 사용하라.
  - 클라이언트들이 메멘토들을 너무 자주 생성하면 앱이 많은 RAM을 소모할 수 있다.
  - 케어테이커들이 더 이상 쓸모없는 메멘토들을 파괴할 수 있도록 오리지네이터의 수명주기를 추적해야 한다.
  - PHP, 파이썬 및 JavaScript와 같은 대부분의 동적 프로그래밍 언어에서는 메멘토 내의 상태가 그대로 유지된다고 보장할 수 없다.
  - 때로는 프로토타입이 메멘토 패턴의 더 간단한 대안이 될 수 있다.
- 옵서버 패턴
  - 프로그래밍 언어가 함수형 타입을 지원하는 subscriber 계층구조를 함수들의 집합으로 바꿀 수 있다.
  - 실제 객체 집합들을 미리 알 수 없거나, 이러한 집합들이 동적으로 변경될 때 사용하라.
    - 이러한 문제는 GUI 클래스 작업할 때 자주 경험할 수 있다.
  - 이 패턴은 앱의 일부 객체들이 제한된 시간 동안 또는 특정 경우에만 다른 객체들을 관찰해야 할 때 사용하라.
  - 커맨드, 중재자, 옵서버 및 책임 연쇄 패턴은 요청의 발신자와 수신자를 연결하는 다양한 방법을 다룬다.
  - 중재자와 옵서버 패턴의 차이는 애매하다. 하나만 구현하는 것도 가능하지만, 때로는 두 패턴을 동시에 적용할 수 있다.
- 상태 패턴
  - 주요 개념은 모든 주어진 순간에 프로그램이 속해 있을 수 있는 상태들의 수는 유한하다는 것이다.
  - finite state machine과 밀접하게 관련되어 있다.
  - 전략 패턴과 비슷해 보이지만 한 가지 중요한 차이점이 있다. 상태 패턴에서는 특정 상태들을 서로 인식하고 다른 상태로 전이를 할 수 있지만, 전략 패턴은 그렇지 않다.
  - 현재 상태에 따라 다르게 행동하는 객체가 있을 때, 상태들의 수가 많고, 상태가 자주 변경될 때 사용하라.
  - 클래스가 행동하는 방식을 변경하는 거대한 조건문들로 오염된 클래스가 있을 때 사용하라.
  - 몇 가지 상태만 있거나, 머신이 거의 변경되지 않을 때 상태 패턴을 적용하는 것은 과도할 수 있다.
  - 상태는 전략의 확장으로 간주할 수 있다.
- 전략 패턴
  - 객체 내에서 한 알고리즘의 다양한 변형들을 사용하고 싶을 때, 그리고 런타임 중에 한 다른 알고리즘으로 전환하고 싶을 때 사용하라.
  - 일부 행동을 실행하는 방식에서만 차이가 있는 유사한 클래스들이 많은 경우에 사용하라.
  - 같은 알고리즘의 다른 변형들 사이를 전환하는 거대한 조건문이 있는 경우 사용하라.
  - 전략 패턴을 적용함으로서 상속을 함성으로 대체할 수 있다.
  - 알고리즘을 사용하는 코드에서 알고리즘의 구현 세부 정보들을 고립할 수 있다.
  - 알고리즘이 몇 개 밖에 되지 않고 거의 변하지 않는다면, 굳이 패턴과 함께 사용되는 새로운 클래스들과 인터페이스들로 프로그램을 지나치게 복잡하게 만들 이유가 없다.
  - 현대 언어에서는 익명 함수를 인자로 넣음으로서 전략 패턴과 같은 효과를 누릴 수 있는 경우가 많다.
  - 패턴은 특정 방식으로 코드의 구조를 짜는 레시피에 불과하지 않다.
  - 데코레이터는 객체의 피부를 변경. 전략 패턴은 객체의 내장을 변경할 수 있다고 비유할 수 있다.
- 템플릿 메서드 패턴
  - 클라이언트들이 알고리즘의 특정 단계들만 확장할 수 있도록 하고 싶을 때, 그러나 전체 알고리즘이나 알고리즘 구조는 확장하지 못하도록 하려고 할 때 사용하라.
  - 거의 같은 알고리즘들을 포함하는 여러 클래스가 있는 경우에 사용하라. 결과적으로 알고리즘이 변경되면 모든 클래스를 수정해야 할 수도 있다.
  - 일부 클라이언트들은 알고리즘의 제공된 골격에 의해 제한될 수 있다.
  - 자식 클래스에서 부모 클래스의 기본 구현을 억제하여 리스코프 치환 원칙을 위반할 수 있다.
  - 단계들이 더 많을수록 유지가 더 어려운 경향이 있다.
  - 팩토리 메서드는 템플릿 메서드의 특수화라고 생각할 수 있다.
  - 탬플릿 메서드 패턴은 상속을 기반으로 하기 때문에 정적이고, 전략 패턴은 객체 수준에서 작동하므로 동적이다.
- 비지터 패턴
  - [더블 디스패치](https://refactoring.guru/design-patterns/visitor-double-dispatch)를 통해 번거로운 조건문을 대체할 수 있다.
  - 비지터 패턴은 복합체 트리와 같은 복잡한 객체 구조와 함께 사용할 때 가장 큰 이득을 볼 수 있다.
  - 보조 행동들의 비즈니스 로직을 정리하라.
  - 행동이 클래스 계층구조의 일부 클래스들에서만 의미가 있고, 다른 클래스들에서는 의미가 없을 때 사용하라.
  - 비지터 객체는 다양한 객체들과 작업하면서 유용한 정보를 축적할 수 있다. 이는 객체 트리와 같은 복잡한 객체 구조를 순회하는 경우와 같을 때 유용할 수 있다.
  - 비지터 패턴은 커맨드 패턴의 강력한 버전으로 취급할 수 있다.