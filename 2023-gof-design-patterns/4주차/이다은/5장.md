### 메멘토
- 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜 둠으로써 이후 해당 객체가 그 상태로 되돌아올 수 있도록 함
- 활용성
  - 어떤 객체의 상태에 대한 스냅샷을 저장한 후 나중에 이 상태로 복구해야 할 때
  - 상태를 얻는 데 필요한 직접적인 인터페이스를 두면 그 객체의 구현 세부사항이 드러날 수밖에 없고, 이것으로 객체의 캡슐화가 깨질 때
- 결과
  - 캡슐화된 경계 유지할 수 있음
  - Originator 클래스를 단순화할 수 있음
  - 메멘토의 사용으로 더 많은 비용이 들어갈 수 있음
  - 제한 범위 인터페이스와 광범위 인터페이스를 정의해야 함
  - 메멘토를 관리하는 데 필요한 비용이 숨어있음
- 구현
  - 고려해야 할 것
    - 언어의 지원 여부
    - 점증적 상태 변경 저장

### 감시자
- 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함
- 활용성
  - 어떤 추상 개념이 두 가지 양상을 갖고 하나가 다른 하나에 종속적일 때
  - 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 프로그래머들은 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때
  - 어떤 객체가 다른 객체에 자신의 변화를 통보할 수 있는데 그 변화에 관심있어 하는 객체들이 누구인지에 대한 가정 없이도 그러한 통보가 될 때
- 결과
  - Subject와 Observer 클래스 간에는 추상적인 결합도만 존재
  - 브로드캐스트 방식의 교류를 가능하게 함
  - 예측하지 못한 정보 갱신
- 구현
  - 주체와 그것의 감시자를 대응시킴
  - 하나 이상의 주체를 감시
  - 누가 갱신을 촉발시킬 것인지 결정
  - 삭제한 주체에 대한 무효 참조자를 계속 유지할 때가 있음
  - 통보 전에 주체의 상태가 자체 일관성을 갖추도록 만들어야 함
  - 감시자별 갱신 프로토콜을 피함
  - 자신이 관심 있는 변경이 무엇인지 명확하게 지정
  - 복잡한 갱신의 의미 구조 캡슐화
  - Subject와 Observer 클래스를 합침

### 상태
- 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가
- 활용성
  - 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라 런타임에 행동이 바뀌어야 함
  - 어떤 연산에 그 객체의 상태에 따라 달라지는 다중 분기 조건 처리가 너무 많이 들어 있을 때
- 결과
  - 상태에 따른 행동을 국소화하며, 서로 다른 상태에 대한 행동을 별도의 객체로 관리함
  - 상태 전이를 명확하게 만듦
  - 상태 객체는 공유될 수 있음
- 구현
  - 누가 상태 전이를 정할 것인가 결정
  - 테이블 기반의 대안도 있음
  - 상태 객체의 생성과 소멸
  - 동적 상속을 이용하는 방법

### 전략
- 동일 계열의 알고리즘군 정의하고 각 알고리즘을 캡슐화하며 상호교환 가능하도록 만듦
- 활용성
  - 행동들이 조금씩 다를 뿐 개념적으로 관련된 많은 클래스들이 존재할 때
  - 알고리즘 변형이 필요할 때
  - 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 때
  - 하나의 클래스가 많은 행동을 정의하고, 이런 행동들이 그 클래스의 연산 안에서 복잡한 다중 조건문의 모습을 취할 때
- 결과
  - 동일 계열의 관련 알고리즘군이 생김
  - 서브클래싱을 사용하지 않는 대안
  - 조건문을 없앨 수 있음
  - 구현의 선택이 가능
  - 사용자는 서로 다른 전략을 알아야 함
  - Strategy 객체와 Context 객체 사이에 의사소통 오버헤드가 있음
  - 개체 수가 증가함
- 구현
  - Strategy 및 Context 인터페이스 정의
  - 전략을 템플릿 매개변수로 사용
  - Strategy 객체에 선택성 부여

### 템플릿 메서드
- 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룸
- 활용성
  - 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 함
  - 서브클래스 사이의 공통적 행동을 추출해 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 때
  - 서브클래스의 확장을 제어할 수 있음
- 구현
  - C++의 접근 제한 방법 이용
  - 기본 연산의 수 최소화
  - 이름 짓는 규칙 만들기

### 방문자
- 객체 구조를 이루는 원소에 대해 수행할 연산을 표현
- 활용성
  - 다른 인터페이스를 가진 클래스가 객체 구조에 포함되어 있으며 구체 클래스에 따라 달라진 연산을 이들 클래스의 객체에 대해 수행하고자 할 때
  - 각각 특징이 있고 관련되지 않은 많은 연산이 한 객체 구조에 속해있는 객체들에 대해 수행될 필요가 있음 + 연산으로 클래스들을 "더럽히고" 싶지 않을 때
  - 객체 구조를 정의한 클래스는 거의 변하지 않지만, 전체 구조에 걸쳐 새로운 연산을 추가하고 싶을 때
- 결과
  - Visitor 클래스는 새로운 연산을 쉽게 추가
  - 방문자를 통해 연산들을 한 군데로 모으고 관련되지 않은 연산을 떼어낼 수 있음
  - 새로운 ConcreteElement 클래스를 추가하기 어려움
  - 클래스 계층 구조에 걸쳐 방문
  - 상태를 누적할 수 있음
  - 데이터 은닉을 깰 수 있음

### 행동 패턴에 대한 논의
- 다양성의 캡슐화
  - 많은 행동 패턴의 주된 목적이 다양성을 캡슐화하려는 것
  - 프로그램의 어떤 양상이 파편화될 때 행동 패턴이 해당 양상을 하나의 객체로 캡슐화 한 객체 정의
  - 객체의 종류: Strategy, State, Mediator, Iterator
- 인자가 되는 객체
  - 몇몇 패턴에서 항상 객체를 인자로 사용하는 예를 볼 수 있음 
  - Ex) 방문자 패턴, 명령 패턴, 메멘토 패턴
- 의사소통을 캡슐화할 것인가, 분산시킬 것인가?
  - 중재자 vs 감시자
    - 중재자 패턴은 다른 객체 사이의 교류를 Mediator 객체 내에 캡슐화
    - 감시자 패턴은 Observer 클래스와 Subject 클래스를 도입함으로써 객체 간의 상호교류를 분산
- 메시지 송신자와 수신자 사이의 결합도 없애기
  - 협력 관계를 갖는 객체가 다른 객체를 직접 참조하면 서로 간에 종속성이 생기는데, 이를 없애려는 패턴 -> 명령, 감시자, 중재자, 책임 연쇄 패턴
    - 메시지를 보내는 송신자와 메시지를 받는 수신자 사이의 결합도를 없애려는 패턴

### 결론
- 행동 패턴끼리는 대체로 서로 보완적이며 서로의 기능을 강화시켜줌
- 행동 패턴은 또 다른 유형과의 패턴과도 잘 통합될 수 있음