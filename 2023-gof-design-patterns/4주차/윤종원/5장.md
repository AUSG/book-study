# 5장

- [5장](#5)
    - [메멘토(MEMENTO)](#memento)
    - [감시자(OBSERVER)](#observer)
    - [상태(STATE)](#state)
    - [전략(STRATEGY)](#strategy)
    - [템플릿 메서드(TEMPLATE METHOD)](#-template-method)
    - [방문자(VISITOR)](#visitor)
    - [행동 패턴에 대한 논의](#---)

## 메멘토(MEMENTO)

- 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 실체화 시켜 가지고 있어 이후 그 객체가 그 상태로 돌아갈 수 있도록 하는 패턴


- 객체의 내부 상태를 기록하고 싶을 때가 있다
    - 체크포인트
    - 오류 복구
    - 연산 수행 결과 취소
- 그러나 객체는 상태를 캡슐화하므로 다른 객체는 상태에 접근할 수 없다


- 메멘토 패턴은 Originator 객체가 가진 내부 상태의 스냅샷을 저장하는 객체
    - 실행 취소 패턴을 구현하려면 Originator 객체가 메멘토 객체에게 상태를 알려달라는 요청을 보낼 수 있다


- 메멘토에 정보를 저장하고 메멘토에서 정보를 검색할 수 있는 것은 원조본의 자격을 가진 객체뿐이다


- 메멘토 패턴은 어떤 객체의 상태의 스냅샷을 저장하고, 나중에 복구하고 싶을 때 사용
- 상태를 얻고 싶지만 캡슐화를 깨고 싶지는 않을 때


- 캡슐화로 기존 경계를 유지할 수 있다
- Originator 클래스를 단순화할 수 있다
    - 다양한 버전의 내부 상태를 직접 관리할 필요가 없으므로
- 정보 양이 많다면 메멘토의 사용이 큰 비용을 초래할 수도 있다
- 메멘토를 관리하는 데도 비용이 필요하다
    - Caretaker 객체는 자신이 보관하고 있는 메멘토를 삭제할 책임이 있다
    - 하지만 Caretaker 객체는 얼마나 많은 상태가 메멘토에 저장되었는지 알 방법이 없다


- 메멘토는 증분적으로 상태를 저장하는 것이 좋다


- 메멘토 기반 반복 인터페이스도 있당
    - https://japhr.blogspot.com/2015/12/an-iterator-memento.html


- 명령 패턴과 메멘토 패턴을 결합해서 사용할 수도 있다

## 감시자(OBSERVER)

- 일 대 다 객체 의존 관계를 정의하고, 객체 상태가 변할 때 그 변화를 토이하는 패턴


- 하나의 시스템을 여러 객체로 분할했을 때 생기는 문제 중 하나는 여러 객체의 일관성을 유지해야 한다는 것
- 하지만 결합도를 높이고 싶지는 않다


- 감시자 패턴
    - 주체 : Subject
    - 감시자 : Observer


- 어떤 추상 개념이 두 가지 양상을 갖고 하나가 다른 하나에 종속적일 때
- 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때
- 어떤 객체가 아무 가정 없이 자신의 변화를 통보할 수 있을 때


- 감시자 패턴을 사용하면 주체 및 감시자 모두를 독립적으로 변형하기 쉽다. 감시자를 재사용하지 않고도 주제를 재사용할 수 있고, 주제 없이도 감시자를 재사용할 수 있다.
- 또한 주체나 감시자의 수정 없이 감시자를 추가하는 것도 가능하다
- 결국 주체와 감시자 사이에 약결합을 유지할 수 있다
- 또한 브로드캐스트 방식이 가능해진다
- 다만, 감시자는 다른 감시자의 존재를 모르므로 갱신 비용이 큰 경우 문제가 생기고 이를 추적하기 어려울 수도 있다


- 누가 갱신을 촉발시키는지에 따라 유형이 나뉜다


- 관심있는 변경을 명확하게 지정하도록 하면 좀더 효율화할 수 있다

## 상태(STATE)

- 객체의 내부 상태에 따라서 행동이 달라지도록 하는 것
- 객체가 상태에게 동작을 위임


- 객체의 행동이 상태에 따라 달라질 수 있고, 상태에 따라서 런타임에 동작이 달라질 때
- 상태에 따라 달라지는 분기 조건 처리가 너무 복잡할 때


- 상태에 따른 행동을 별도의 클래스로 분리하므로 상태 추가나 수정이 쉬워진다
- 상태 전이를 명확하게 만들어준다
- 상태 객체를 공유할 수 있다
    - 타입으로만 표현되므로


- 누가 상태 전이를 저의할 것인가?
    - Context 클래스가 알 수도 있고 State의 서브클래스가 알 수도 있다
    - 후자가 더 일반적으로 더 유연한 방식
    - 단, 서브클래스 사이의 종속성이 생길 수도 있다
- 또는 테이블을 구성해 입력 값과 상태 전이를 매핑하는 것도 가능
    - 프로그램 변경 없이 테이블만 수정해도 동작 변경 가능
    - 하지만 테이블 탐색이 가상 함수 호출보다 비효율적일 수도 있으며, 떄로는 상태 흐름이 규칙에 맞지 않을 수도 있고, 상태 전이에 따른 처리 동작을 추가하기 어렵다


- 런타임의 클래스 변경을 지원하는 언어도 있다


- 상태 객체는 공유 시점이나 공유 방법을 정의하는 데에 플라이급 패턴을 사용한다
- 상태 객체는 종종 싱글톤이다

## 전략(STRATEGY)

- 같은 계열의 알고리즘 군을 정의하고, 각 알고리즘을 캡슐화해 런타임에 교체할 수 있도록 한다


- 같은 역할을 하는 알고리즘을 클래스에 하드코딩하는 것은 다음과 같은 이유로 별로 바람직하지 않다
    - 알고리즘이 다양해지만 프로그램이 점점 복잡해진다
    - 때에 따라서 필요한 알고리즘이 다르므로 모든 알고리즘을 다 제공할 필요는 없다
    - 알고리즘과 사용자 코드가 합쳐져있으면 알고리즘 수정 및 추가가 어렵다
- 따라서 각 알고리즘을 하나의 클래스로 캡슐화한다


- 행동들이 조금씩 다를 뿐 개념적으로 관련된 많은 클래스가 존재할 때
- 알고리즘의 변형이 필요할 때
- 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 때, 노출하지 말아야 할 복잡한 자료구조를 전략 클래스에 둬서 해결
- 하나의 클래스가 많은 행동을 정의하고, 이런 행동들이 그 클래스의 연산 안에서 복잡한 다중 조건문의 모습을 취할 때


- 상속 또한 이를 해결하는 방법 중 하나이지만 이는 추후 수정이어렵고 유지보수가 어렵다. 전략 패턴은 서브클래시응 사용하지 않는 대안이다
- 조건문을 없앨 수 있다
- 구현의 선택이 가능해진다
- 하지만 전략 사이에 공통 인터페이스를 저의해야만 한다
- 객체 수가 증가한다


- 전략 객체는 규모가 작으므로 플라이급 패턴으로 정의하는 것도 좋다

## 템플릿 메서드(TEMPLATE METHOD)

- 상위 객체에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적인 알고리즘은 서브클래스에서 정의


- 템플릿 메서드는 서브클래스가 오버라이드할 수 있는 추상 연산을 사용해 알고리즘을 정의
- 추상 연산을 통해 알고리즘의 일부 단계를 정의함으로써, 템플릿 메서드는 각 단계의 순서는 고정하되 단계의 처리를 다양화할 수 있다


- 어떤 알고리즘에서 변하지 않는 부분을 정의해두고 일부분을 다양화하고 싶을 때
- 서브클래스 사이의 공통적인 행동을 추출하고 싶을 때
- 서브클래스의 확장을 제어하고 싶을 때


- 템플릿 메서드는 할리우드 원칙이라는 역전된 제어 구조를 끌어낸다


- 팩토리 메서드 패턴은 종종 템플릿 메서드 패턴이라고도 한다

## 방문자(VISITOR)

- 객체 구조를 이루는 원소에 대해서 수행할 연산을 표현한다
- 연산을 적용할 원소의 클래스 변경 없이 새로운 연산을 정의할 수 있다


- 연산들을 분리하고, 구조와 연산을 분리할 때 유용한 패턴이다
- 즉, 각 클래스에서 서로 관련된 연산을 모아서 별도의 객체로 묶고 이를 방문자라고 한다
- 따라서 연산이 적용되는 원소에 대한 클래스 계통과 적용할 연산을 정의하는 클래스 계통이 생긴다


- 각각 특징이 있고, 관련되지 않은 많은 연산이 한 객체 구조에 속해있는 경우
- 객체 구조를 정의한 클래스는 거의 변하지 않지만, 전체 구조에 걸쳐 새로운 연산을 추가하고 싶을 때


- 덕분에 새로운 연산을 쉽게 추가할 수 있다
- 관련된 연산을 모을 수 있다
- 하지만 객체 구조 변경은 어려워진다
- 또한 캡슐화를 깨버릴 수도 있다


- 방문자 패턴은 이중 디스패치를 이용한다

## 행동 패턴에 대한 논의

- 많은 행동 패턴의 주된 목적은 다양성을 캡슐화하는 것
- 전략 객체는 알고리즘을 캡슐화
- 상태 객체는 상태에 의존적인 행동을 캡슐화
- 중재자 객체는 객체 사이의 프로토콜을 캡슐화
- 반복자 객체는 객체의 구성요소에 접근하거나 원소들을 순회하는 방법을 캡슐화


- 중재자와 감시자 패턴은 경쟁적이다
    - 감시자 패턴은 객체 간의 상호교류를 분산시키고 중재자 패턴은 객체 고류를 중재자 객체 내에 캡슐화한다


- 재사용성 부분에선 감시자 패턴이 좋다
- 하지만 객체 간의 흐름을 파악하는 데는 중재자 패턴이 더 좋다


- 협력 관계를 갖는 객체가 다른 객체를 직접 참조하면 종속성이 생긴다
- 따라서 명령, 감시자, 중재자, 책임 연쇄 패턴은 송신자와 수신자 사이의 결합도를 없애려는 패턴이다


- 잘 설계또니 객체지향 시스템은 여러 가지 패턴이 조화롭게 내재된 시스템이다
- 하지만 설계자들이 그 패턴의 의미를 의식해서 조합했기 때문이 아니다
- 클래스 또는 객체 수준에서 하는 조합이 아닌, 패턴 수준에서 하는 조합이 되어야 높은 활용성을 동반한 한결같은 시너지를 낼 수 있다

