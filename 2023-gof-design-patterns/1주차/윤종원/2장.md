- [2.1 설계 문제들](#21--)
- [2.2 문서 구조](#22--)
    - [재귀적 합성](#-)
    - [글리프](#)
    - [복합체 패턴](#-)
- [2.3 서식 설정](#23--)
    - [서식 설정 알고리즘의 캡슐화](#---)
    - [합성자와 복합](#-)
    - [전략 패턴](#-)
- [2.4 사용자 인터페이스 장식하기](#24---)
    - [투명한 포함(transparent enclosure)](#-transparent-enclosure)
    - [단일 글리프](#-)
    - [장식자 패턴](#-)
- [2.5 다양한 룩앤필 표준 지원](#25----)
    - [객체 생성의 추상화](#--)
    - [팩토리와 제품 클래스](#--)
    - [추상 팩토리 패턴](#--)
- [2.6 다중 윈도우 시스템 지원](#26----)
    - [추상 팩토리 패턴을 사용할 수 있을까요?](#-----)
    - [구현 종속성을 캡슐화](#--)
    - [Window와 WindowImp](#window-windowimp)
    - [가교 패턴](#-)
- [2.7 사용자 조작](#27--)
    - [요청의 캡슐화](#-)
    - [Command 클래스와 서브클래스](#command--)
    - [취소 가능성](#-)
    - [명령 이력](#-)
    - [명령 패턴](#-)
- [2.8 철자 검사와 붙임표 연결](#28----)
    - [흩어진 정보에 대한 접근](#---)
    - [접근과 순회 방법을 캡슐화하기](#---)
    - [Iterator 클래스와 서브클래스](#iterator--)
    - [반복자 패턴](#-)
    - [순회, 그리고 순회 중의 작동](#----)
    - [분석 작업을 캡슐화하기](#--)
    - [Visitor 클래스와 서브클래스](#visitor--)
    - [방문자 패턴](#-)
- [2.9 요약](#29-)


- WYSIWYG 방식의 문서 편집기 설계

## 2.1 설계 문제들

- 다양한 기능과 문제들

## 2.2 문서 구조

- 문서는 문자, 선, 다각형 등 다양한 요소를 그냥 배열한 것이지만 설계자 입장에서는 이를 그래픽 요소가 아니라 행과 열, 그림, 표 또는 다른 형태의 하위 구조 등의 물리적인 구조로 볼 수도 있다
- 또한 이 하위 구조는 다른 하위 구조를 포함할 수 있다


- 적합한 기능을 제공하기 위해서는 문서의 물리적 구조에 부합하는 내부 표현을 사용해야 한다

### 재귀적 합성

- 계증척으로 구조화된 정보를 보여주는 가장 일반적인 방법으론 재귀적 합성(recursive composition) 기법이 있다
- 단순한 것에서 복잡한 것을 점진적으로 만들어 낼 수 있다


- 각 객체에 대응되는 클래스가 필요
- 이런 객체들을 일관되게 다루기 위한 인터페이스가 필요

### 글리프

- 글리프(Glyph) : 화면에 표시되는 구성요소를 포괄적으로 일컫는 개념
- 3가지의 책임
    - 어떻게 자기 자신을 그리는지
    - 차지하는 영역이 얼마나 되는지
    - 자신의 자식들과 부모가 누구인지

### 복합체 패턴

- 복잡한 계층 구조 표현하기에 좋다

## 2.3 서식 설정

### 서식 설정 알고리즘의 캡슐화

- 서실 설정 알고리즘은 복잡한 경향이 있으므로 알고리즘은 문서 구조에 독립적이어야한다
- 이상적으론 서식 설정 알고리즘과 무관하게 새로운 Glyph 클래스를 추가할 수 있어야 한다
- 혹은 새로운 서식 설정 알고리즘을 추가하더라도 기존 Glyph 클래스를 변경해서는 안 된다


- 알고리즘을 별도의 객체로 둘러싸면 알고리즘을 캡슐화해 교체가능하게 만들 수 있다

### 합성자와 복합

- 문서의 물리적 구조를 지원하는 클래스와 서식 설정 알고리즘을 담당하는 클래스를 분리하면 유연성을 얻을 수 있다
- Glyph 클래스를 고치지 않고 새로운 서식 설정 알고리즘을 개발하거나 서식 설정 알고리즘을 고치지 않고 새로운 Glyph 클래스를 추가하거나 변경할 수 있다
- 또한 런타임에 이러한 알고리즘을 변경하는 것이 가능하다

### 전략 패턴

- 알고리즘을 객체로 캡슐화하는 것은 전략 패턴의 의도다
- 전략 패턴에는 알고리즘을 캡슐화한 객체와 이 객체가 동작할 동작 환경으로 나뉜다


- 전략 패턴에서 중요한 점은 전략과 동작 환경에 대한 인터페이스가 충분히 일반화되어야 한다는 것이다
- 그래야 다양한 배경 혹은 다양한 전략을 지원할 수 있다

## 2.4 사용자 인터페이스 장식하기

- 새로운 장식을 쉽게 추가하려면 상속을 써서 사용자 인터페이스에 장식 요소를 추가해서는 안 된다
- 다른 사용자 인터페이스에 어떤 장식 요소가 있을지 몰라야만 유연성을 보장할 수 있다

### 투명한 포함(transparent enclosure)

- 결국 사용자 인터페이스에 장식을 추가하기 위해서는 기존 코드의 확장이 필요하다
- 하지만 이러한 확장을 위해서 상속을 사용하면 클래스가 급증하게 될 수도 있다


- 이럴 때는 객체 합성이 더 유연한 확장 방법이 될 수 있다
- 장식 자체를 별도의 객체로 만들며 된다


- 이때 장식도 Glyph 클래스의 일종이 되어야 한다
- 사용자가 장식 유무와 상관없이 객체를 다룰 수 있어야 하기 때문이다


- transparent enclosure
    - 단일 자식에 기반을 둔 합성
    - 호환되는 인터페이스의 개념

### 단일 글리프

- 장식을 복합과 독립적으로 관리함으로써 장식과 관련된 클래스를 단순화할 수 있고 클래스의 수도 줄일 수 있다
- 또한 이미 존재하는 복합의 기능을 복제할 필요도 없다

### 장식자 패턴

- 데코레이터 패턴
- 장식은 객체에 추가할 수 있는 모든 책임에 해당

## 2.5 다양한 룩앤필 표준 지원

- 다양한 하드웨어나 플랫폼을 지원하는 건 정말 중요한 일
- 쉽게 이식이 가능하도록 설게해야 한다


- 이때 이식성에서 걸리는 부분이 바로 룩앤필 표준의 다양성이다
- 플랫폼마다 다른 룩앤필을 가지고 있다


- 여기에서 목표하는 것은 새로운 룩앤필을 손쉽게 지원하고, 런타임에 룩앤필을 변경할 수 있도록 유연성을 지원하는 설계

### 객체 생성의 추상화

- 명시적인 생성자 호출도 피해야하고, 이와 동시에 전체 위젯을 쉽게 변경할 수 있어야 한다
- 이 두 마리 토끼는 객체를 생성하는 과정 자체를 추상화함으로써 모두 잡을 수 있다

### 팩토리와 제품 클래스

- 팩토리를 사용하면 클래스 생성을 추상화 할 수 있다
- 또한 코드에 특정 구현 내용이 드러나는 것을 피할 수 있다


- 팩토리 객체를 생성하기 위해서 싱글톤 패턴을 사용할 수도 있다

### 추상 팩토리 패턴

- 추상 팩토리 패턴에는 팩토리와 제품이 참가한다
- 이 패턴을 사용하면 인스턴스를 직접 만들지 않고서도 관련된 제품 객체의 군을 생성할 수 있다
- 이는 제품 객체의 종류는 일정하고, 각 객체의 특성이 제품군마다 다를 때 좋다


- 추상 팩토리 패턴은 동일 계열의 제품군만을 다룰 수 있다는 점에서 다른 생성 패턴과 다르다
- 다른 생성 패턴은 한 종류의 제품 객체만 상대할 수 있다

## 2.6 다중 윈도우 시스템 지원

- 여러 플랫폼의 윈도우 시스템은 서로 호환되지 않는다

### 추상 팩토리 패턴을 사용할 수 있을까요?

- 윈도우 시스템 간의 이식성은 룩앤필 표준에 대한 독립성과는 다른 점이 있다
- 추상 팩토리 패턴을 적용할 때는 각 룩앤필별로 정확한 위젯 클래스를 정의했다
- 즉, 특정 표준별로 추상 제품 클래스에서 각각 구체적인 제품을 만들 수 있었다
- 하지만 윈도우 시스템은 각 회사마다 서로 다른 여러 개의 클래스 계층을 가지고 있는데, 이 계층이 서로 호환 가능하다고 볼 수 없어서 위젯별로 공통의 추상 클래스를 정의하기 어렵다
- 따라서 제품이 갖는 인터페이스에서 공통된 연산을 정의하는 별도의 위젯 계층을 만들어야 한다


- 결과적으로 하는 일은 비슷하지만 구체적인 방법이 다르므로 이를 분리하자

### 구현 종속성을 캡슐화

- 윈도우 기능의 인터페이스를 생각해보자
    - 모든 시스템의 기능의 교집합
    - 모든 시스템의 기능의 합집합
- 두 방법 모두 문제가 있으므로 그 중간이 필요하다


- 윈도우 시스템의 기능을 하나의 인터페이스 객체로 캡슐화하고, 각 플랫폼에 따라 이 인터페이스를 구현한다면 서브클래스가 급증하는 문제를 막을 수 있고 런타임 윈도우 설정도 가능해진다

### Window와 WindowImp

- WindowImp는 추상 클래스고 윈도우 시스템에 종속된 클래스를 추상화환다
- Window 클래스는 WindowImp를 가지고 있다


- 윈도우 시스템 구현이 WindowImp 클래스 속에 있으므로 Window 클래스와 윈도우 시스템 사이의 종속이 사라진다


- 추상 팩토리에게 윈도우 시스템별 구현 객체 생성을 맡길 수 있다

### 가교 패턴

- 브릿지 패턴


- 프로그래머는 WindowImp 인터페이스를 직접 사용하지 않고 Window 객체만을 이용하므로 WindowImp 인터페이스는 프로그래머가 바라보는 윈도우의 개념과 일치할 필요는 없다


- 즉, Window 인터페이스는 응용프로그램 프로그래머가 만족하는 것이어야 하고 WindowImp 인터페이스는 실제 윈도우 시스템의 특성에 맞아야 한다
- 이를 분리함으로써 독립적으로 구현하고 확장할 수 있다


- 이러한 예는 가교(브릿지) 패턴의 한 예이다
- 서로 독립적으로 확장되지만 함께 동작해야 하는 개념들을 별도의 클래스 계층으로 분리해준다

## 2.7 사용자 조작

- 사용자의 인터페이스가 바뀌더라도 사용자 조작 기능이 바뀌진 않는다

### 요청의 캡슐화

- 요청을 매개변수로 받을 수도 있지만 이는 redo/undo를 구현하기 어렵고, 함수에 상태를 결합시키기 어려우며 함수를 확장하거나 재사용하기도 어렵다
- 따라서 각 요청을 객체로 캡슐화하려고 한다
    - 이렇게 하면 상속을 통해서 요청 구현을 확장하거나 재사용도 가능
    - 상태도 저장할 수 있고 redo/undo도 가능

### Command 클래스와 서브클래스

- Command : 요청 인터페이스

### 취소 가능성

- Command에 `Unexecute()` 연산을 추가
- 이때 `Execute()` 연산이 저장한 취소 정보를 활용


- 런타임에 취소 여부를 판단할 수도 있다

### 명령 이력

- 이력 관리하면서 undo/redo 하면 된당

### 명령 패턴

- 이는 커맨드 패턴 사용한 것
- 요청을 캡슐화
- 요청을 발생시키는 데 필요한 인터페이스를 제공해주므로 사용자 쪽에서는 서로 다른 요청을 동일하게 처리할 수 있다

## 2.8 철자 검사와 붙임표 연결

- 철자 검사나 붙임표 위치를 구하는 알고리즘도 다양하다
- 또한 문서 구조 안에는 이러한 내용이 들어가지 않았으면 좋겠다
    - 단어 개수 세기, 테이블 값 합산 등 다양한 기능이 추가될 것이믈

### 흩어진 정보에 대한 접근

- 현재는 데이터가 흩어져있다
- 또한 데이터를 분석 방법마다 정보에 접근하는 방식이 달라질 수 있다


- 접근 방법은 서로 다른 데이터 구조를 포괄할 수 있어야 한다
- 서로 다른 순회 방법이 지원되어야 한다

### 접근과 순회 방법을 캡슐화하기

- 자식들을 저장하는 자료 구조를 외부에 숨길 필요가 있다
- 한 가지 방법은 Glyph 인터페이스에 순회 관련 추상 연산을 추가하는 것
- 하지만 새로운 순회 방법을 추가하ㄹ고 하면 꽤나 복잡해진다
    - Glyph 서브 클래스를 매번 수정해야 한다
- 또한 하나의 구조가 순회 방법을 여러 가지 지원하도록 하는 것도 어렵다

### Iterator 클래스와 서브클래스

- Iterator : 구조 접근과 순회에 필요한 일반 인터페이스
- 이 인터페이스는 Iterator 서브클래스 쪽에서 구현한다
- 덕분에 자료 구조나 순회 방법에 맞는 Iterator 서브 클래스를 구현하면 끝난다
    - 새로운 종류의 순회 방법을 추가하더라도 Glyph 클래스를 수정할 필요가 없다

### 반복자 패턴

- 반복자 패턴은 객체 구조에 대한 접근 및 순회 방법을 지원하기 위한 기법이다
- 이는 복합 구조뿐만 아니라 컬렉션에도 잘 응용할 수 있다

### 순회, 그리고 순회 중의 작동

- 이제 순회할 수 있으니 분석 방법을 준비해야 한다
- 순회와 순회 중 작동을 따로 뗴어놓을 수 있다면 훨씬 더 높은 유연성과 재사용성을 얻을 수 있다


- 분석 방법은 글리프의 종류를 구별할 수 있어야 한다
- 한 가지 쉬운 방법은 Glyph 클래스 자체에 분석 기능을 넣는 것이다
- 하지만 이 방법은 새로운 분석이 추가될 때마다 모든 Glyph 클래스를 변경해야 한다

### 분석 작업을 캡슐화하기

- 따라서 분석 작업 자체를 별도의 객체로 캡슐화할 필요가 있다
- 분석 작업을 나타내는 별도의 클래스를 정의하고 이 클래스의 인스턴스를 반복자와 함께 사용한다


- 이 방법을 사용하려면 분석 객체가 타입 검사와 다운캐스트 기능에 의존하지 않고 어떻게 글리프의 종류를 구분할 수 있는지다

### Visitor 클래스와 서브클래스

- Visitor는 구조를 순회하면서 다른 객체에 방문(visit)하여 적절한 일을 수행한다

### 방문자 패턴

- Visitor 패턴은 Glyph 클래스의 변경 없이도 추가 가능성을 내포한 글리프 구조 분석을 가능하게 한다
- 또한 이는 복합 객체뿐만 아니라 모든 구조에 다 적용할 수 있는 패턴이다


- 방문자 패턴을 사용하기 전에 반드시 확인해야 하는 부분이 하나 있다
- 가장 자주 변경되는 클래스 계층이 무엇인가 하는 것이다
- 구조가 안정된 경우에 방문자 패턴은 적절하지만 구조가 자주 변경된다면 매번 새로운 `Visit` 연산을 추가해야 하므로 공수가 늘어난다

> Small talk 언어도 다루니까 Double Dispatch 관련 내용이 나올 줄 알았는데 없군요..?

## 2.9 요약

- 8개의 패턴을 사용해 보았다~
- 아직 더 많은 패턴들이 있다~
- 문서 편집기뿐만 아니라 다양한 곳에 패턴을 적용할 수 있다~

