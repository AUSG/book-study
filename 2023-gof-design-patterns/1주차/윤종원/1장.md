- [1.1 디자인 패턴이란?](#11--)
- [1.2 스몰토크 MVC를 사용한 디자인 패턴](#12--mvc---)
- [1.3 디자인 패턴 기술하기](#13---)
- [1.4 디자인 패턴 카탈로그](#14---)
- [1.5 카탈로그 조직화하기](#15--)
- [1.6 디자인 패턴을 이용하여 문제를 푸는 방법](#16------)
    - [적당한 객체 찾기](#--)
    - [객체의 크기 결정](#--)
    - [객체 인터페이스의 명세](#--)
    - [객체 구현 명세하기](#--)
        - [클래스 상속 대 인터페이스 상속](#----)
        - [구현에 따르지 않고 인터페이스에 따르는 프로그래밍](#-----)
    - [재사용을 실현 가능한 것으로](#---)
        - [상속 대 합성](#--)
        - [위임](#)
        - [상속 대 매개변수화된 타입](#---)
    - [런타임 및 컴파일 타입의 구조를 관계짓기](#-----)
    - [변화에 대피한 설계](#--)
        - [응용프로그램](#)
        - [툴킷](#)
        - [프레임워크](#)
- [1.7 디자인 패턴을 고르는 방법](#17----)
- [1.8 디자인 패턴 사용 방법](#18----)


- 설계는 지금 당장 갖고 있는 문제를 해결할 수 있어야 하지만, 나중에 생길 수 있는 문제나 추가된 요구 사항들도 수용할 수 있도록 일반적이고 포괄절이어야한다.
- 하지만 처음부터 설계를 정확하게 하기는 불가능에 가깝다


- 전문가들은 초보자들과 달리 전에 사용했던 해결책을 다시 사용한다

## 1.1 디자인 패턴이란?

- 디자인 패턴 : 기존 환경 내에서 반복적으로 일어나는 문제들을 설명한 후, 그 문제들에 대한 해법의 핵심을 설명해준다


- 디자인 패턴은 어떤 세부적인 구현 방법이나 전체 아키텍처 설계에 대한 내용이 아니다
- 특정한 전후 관계에서 일반적인 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명이다

## 1.2 스몰토크 MVC를 사용한 디자인 패턴

- 스몰토크에서는 UI 만들 때 MVC(Model/View/Controller)의 세 가지 클래스를 사용한다
- MVC 패턴에서 Model과 View 관계를 일반화하면 감시자(Observer) 패턴이 된다.


- 뷰 안에 뷰가 담길 수 있고 그 여부와 상관없이 외부에서는 뷰로 바라볼 수 있는데 이는 복합체(Composite) 패턴


- 뷰와 컨트롤러 관계는 전략 패턴에 가까움

## 1.3 디자인 패턴 기술하기

- 다이어그램이 전부가 아니다
- 동기, 설계를 위한 다양한 결정, 대안, 장단점 등도 필요하다

## 1.4 디자인 패턴 카탈로그

## 1.5 카탈로그 조직화하기

- 패턴을 분류하는 기준은 두 가지
    - 목적 -> 생성, 구조, 행동
    - 범위 -> 클래스 or 객체


- 혹은 패턴 간의 참조 관계에 따라 분류

## 1.6 디자인 패턴을 이용하여 문제를 푸는 방법

### 적당한 객체 찾기

- 객체지향 설계의 가장 어려운 부분은 시스템을 구성할 객체의 분할을 결정하는 것
- 분석 모델로부터 만들어진 객체지향 설계는 실세계와 대응되지 않는 경우가 많다
- 실세계를 그대로 반영하는 모델링은 현재의 실세계는 반명할 수 있지만 미래의 실세계는 반영할 수 없다
- 추상화는 설계의 유연성을 증진하기 위한 노력 중 하나다


- 디자인 패턴은 덜 명확한 추상적 개념를 알아보는 데에 도움을 준다
- 어떤 객체들은 설계를 유연하고 재사용 가능한 것으로 만들면서 드러난다

### 객체의 크기 결정

- 크기나 개수와 관련된 디자인 패턴이 많다

### 객체 인터페이스의 명세

- 객체가 인터페이스로 통신하면 구현이 자유로워진다
- 런타임에 실제 요청을 받는 객체에 따라서 다른 코드가 실행되는 동적 바인딩(dynamic binding)이 가능
- -> 다형성 가능


- 디자인 패턴은 인터페이스에 정의해야 할 중요 요소가 무엇이고, 어떤 종류의 데이터를 주고받아야 하는지 식별해준다
- 때로는 인터페이스에 넣지 말아야 할 것을 알려주기도 한다
- 또는 인터페이스 간의 관련성도 정의해준다

### 객체 구현 명세하기

- Mixin 클래스는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스
- 인스턴스로 만들 의도가 없다는 면에서 추상 클래스와 비슷
- 믹스인 클래스를 사용하기 위해서는 다중 상속이 필요

```scala
abstract class Manager { // 트레이트가아닌 추상클래스임에 주의


  def lookup(): Unit = {
    println("Base lookup")
  }
}


// 슈퍼클래스로 Manager를 선언하였다. 이 선언은 TaskManager 트레이트가 Manager를 상속한 클래스에만 Mixin될 수 있다는 것이다.
trait TaskManager extends Manager {


  override def lookup(): Unit = {
    println("TaskManager task lookup")
    super.lookup()
  }
}


trait JobManager extends Manager {


  override def lookup(): Unit = {
    println("JobManager job lookup")
    super.lookup()
  }
}


// extends Manager가 빠져있다면 즉, Manager 클래스를 상속하지 않았다면 컴파일 에러가 발생한다.
class ManagerImpl extends Manager with TaskManager with JobManager {


  override def lookup(): Unit = {
    println("Impl lookup")
    super.lookup()
  }
}


object Test {


  def main(args: Array[String]): Unit = {
    val manager = new ManagerImpl
    manager.lookup()
  }
}


/*
  결과 출력:
  Impl lookup
  JobManager job lookup
  TaskManager task lookup
  Base lookup
*/
```

```rust
pub trait Summarizable {
    fn summary(&self) -> String {
        format!("(Read more from {}...)", self.author_summary())
    }
}


impl Summarizable for Tweet {
}


let tweet = Tweet {
    username: String::from("horse_ebooks"),
    content: String::from("of course, as you probably already know, people"),
    reply: false,
    retweet: false,
};


println!("1 new tweet: {}", tweet.summary());
```

- 모든 언어가 다중 상속이 필요한 것은 X

#### 클래스 상속 대 인터페이스 상속

- 클래스는 객체의 내부 상태와 그 객체의 연산에 대한 구현 방법을 정의
- 객체의 타입은 객체의 인터페이스를 정의
- 즉, 하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있다


- 클래스 상속은 이미 정의된 객체의 구현을 바탕으로 한다
- 인터페이스 상속(서브타이핑)은 어떤 객체가 다른 객체 대신에 상요될 수 있는 경우를 지정


- 대부분의 프로그래밍 언어는 인터페이스와 구현 상속을 구분하지 않지만, 프로그래머들은 실제로 구분해서 사용한다

#### 구현에 따르지 않고 인터페이스에 따르는 프로그래밍

- 구현의 재사용이 상속의 전부가 아니다
- 동일한 인터페이스를 갖는 객체군을 정의해준다


- 덕분에 사용자는 특정 객체를 몰라도 요청할 수 있다
- 즉, 서브시스템 간의 구현 종속성이 사라진다

> 구현이 아닌 인터페이스에 따라 프로그래밍

### 재사용을 실현 가능한 것으로

#### 상속 대 합성

- 객체지향에서 기능의 재사용을 보통 상속이나 객체 합성으로 구현하낟
- 서브클래싱에 의한 재사용을 화이트박스 재사용이라고 한다
    - 내부를 볼 수 있으므로


- 객체 합성은 클래스 상속에 대한 대안
- 객체를 합성하려면 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해야 한다
- 이런 스타일의 재사용을 블랙박스 재사용이라고 한다
    - 객체의 내부는 모른 채 인터페이스를 통해서만 재사용


- 상속과 합성은 장단점이 있다
    - 클래스 상속은 컴파일 시점에 정적으로 저으이되고 언어가 직접 지원
- 단, 클래스 상속은 부모 클래스의 구현을 변경할 수 없고 부모 클래스 구현에 의존하므로 캡슐화를 파괴하며 부모 클래스 변경이 모든 서브 클래스에게 영향을 미친다
- 그래서 이에 대한 대안으로 기능이 거의 없는 추상 클래스를 상속하기도 한다


- 혹은 객체 합성을 사용할 수 있다
- 런타임에 동적으로 정의
- 인터페이스를 잘 정의해야 한다
- 인터페이스 덕분에 런타임에 다른 의존성으로 대체 가능한다
- 덕분에 구현에 대한 의존이 많이 줄어든다
- 각 클래스의 캡슐화를 유지할 수 있다.
- 대신, 클래스의 수는 적어지고 객체의 수는 더 맣아질 수도 있다

> 객체 합성이 클래스 합성보다 더 나은 방법

- 여러 구성요소를 잘 조합하면 모든 새로운 기능을 얻을 수 있다
- 하지만 실제로는 구성요소 집합이 충분하지 않기 때문에 기존 구성요소의 조합을 통한 재사용만으로는 목적을 달성할 수 없을 수도 있다
- 이 경우 상속에 의한 재사용은 기존 클래스를 조합해 새로운 구성요소를 쉽게 만들 수 있게 해준다
- 즉, 상속과 객체 합성은 적절히 조합되어야 한다

#### 위임

- 위임(delegation)은 수신 객체가 연산의 처리를 위임자(delegate)에게 넘긴다
- 위임의 가장 중요한 점은 런타임에 행동을 구성할 수 있게 해주고, 이런 방식도 변경할 수 있다는 것이다
- 대신 위임이 갖는 단점은 정적인 소프트웨어보다 이해하기 어렵다는 것, 런타임에 비효율적이라는 것


- 이 덕분에 상태 패턴, 전략 패턴에서 처리를 전달하는 객체를 수정하지 않고 객체의 행동을 변경할 수 있다
- 중재자 패턴, 가교 패턴 등등

#### 상속 대 매개변수화된 타입

- 기능 재사용에 매개변수화된 타입(parameterized type)을 사용할 수도 있다
- 어떤 언어에서는 제네릭(generic)이라고도 하고 템플릿(template)이라고도 한다


- 타입을 정의할 일부 타입을 지정하지 않은 채 정의한다


- 클래스 상속, 객체 합성과 함께 행동을 구성할 수 있는 세 번째 방법

### 런타임 및 컴파일 타입의 구조를 관계짓기

- 컴파일 시점에 확정되는 코드 구조와는 달리 런타임 구조는 객체의 상호작용에 따라서 달라질 수 있다
- 즉, 컴파일 구조와 런타임 구조는 별개의 독립성을 가진다


- 객체 관계
    - 집합(aggregation)
        - 한 객체가 다른 객체를 소유하거나 책임을 진다
        - -> 포함(having) or 부분(part of)
        - 즉, 두 객체의 생존주기가 똑같다
    - 인지(acquaintance)
        - 알고 있음(knows of)
        - -> 연관(association) or 사용(using)
        - 서로가 요청할 수는 있지만 책임을 지지는 않는다
        - 즉, 조금 더 약한 관계


- 단, 둘은 구분하기가 어렵다
- 두 관계의 구현 방법이 동일할 때가 많기 때문이다


- 즉, 언어의 처리 방식이 아니라 사용 목적에 따라 결정
- 집합 관계는 인지 관계보다 강력한 영속성의 개념을 가진다
- 하지만 인지 관계는 조금 더 동적이며 자주 바뀐다


- 시스템의 런타임 구조는 언어가 아니라 설계자가 만든다
- 코드 자체가 시스템의 동작 방법을 모두 보여줄 수는 없다


- 따라서 많은 디자인 패턴이 컴파일 시점과 런타임 구조를 명시적으로 구분한다

### 변화에 대피한 설계

- 재사용을 최대화하기 위해서는 새로운 요구 사항과 기존 요구 사항에 발생한 변경을 예측하여 시스템 설계가 진화할 수 있도록 해야 한다


- 디자인 패턴은 어떤 구체적인 원인으로 앞으로 시스템을 변경해야 한다는 것을 미리 보여줌으로써 위험을 줄여준다
- 디자인 패턴은 다른 부분에 독립적으로 시스템 구조를 변경할 수 있게 하여, 시스템이 어떤 특정 변화에 순응할 수 있도록 한다.


- 디자인 패턴을 써서 재설계 할 수밖에 없게 하는 흔한 이유들
    - 특정 클래스에서 객체 생성
        - 객체를 생성할 때 클래스 이름을 명시하면 의존성이 생긴다
        - 이를 방지하려면 객체를 직접 생성해서는 안 된다
        - -> 추상 팩토리, 팩토리 메서드, 프로토타입 패턴
    - 특정 연산에 대한 의존성
        - 특정 연산을 사용하면 구현에 의존이 생긴다
        - 요청의 처리 방법을 직접 명시하지 않으면 요청 처리 방법을 쉽게 변경할 수 있다
        - -> 책임 연쇄(chain of responsibility), 커맨드 패턴
    - 하드웨어와 소프트웨어 플랫폼에 대한 의존성
        - 하드웨어나 플랫폼에 종속하면 다른 곳으로 이식하기 어렵다
        - 혹은 플랫폼의 버전 변경을 따라가기 힘들 수도 있다.
        - 이러한 플랫폼 종속성을 제거하는 것이 중요하다
        - -> 추상 팩토리, 브릿지 패턴
    - 객체의 표현이나 구현에 대한 의존성
        - 객체 표현, 구현을 알고 있으면 의존성이 생긴다
        - 따라서 객체를 변경하기가 힘들어진다
        - -> 추상 팩토리, 브릿지, 메멘토, 프록시
    - 알고리즘 의존성
        - 알고리즘을 확장하거나, 최적화하거나 교체할 필요가 있다
        - 즉, 알고리즘에 대한 종속성을 없애고 싶을 때도 있다
        - -> 빌더, 이터레이터, 전략, 템플릿 메서드, 비지터
    - 높은 결합도
        - 결합도가 높으면 독립적으로 재사용하기 힘들다
        - 또한 클래스 하나 수정하려고 하면 시스템 전체를 이해해야 한다
        - 약한 결합도는 클래스 자체의 재사용을 가능케하고 이해 가능한 시스템을 만든다
        - 추상 클래스 수준에서 결합도를 정의하거나 계층화시켜 낮은 결합도를 이뤄낼 수 있다
        - -> 추상 팩토리, 브릿지, CoR, 명령, 퍼사드, 중재자, 옵저버
    - 서브클래싱을 통한 기능 확장
        - 서브클래싱으로 객체 재정의하는 것은 쉬운 일이 아니다
        - 부모 클래스에 대한 의존성이 생긴다
        - 또한 단순히 확장을 이유로 새로운 서브클래스를 만들면 클래스 수가 엄청 늘어난다
        - 일반적으로 객체 합성과 위임은 상속보다 훨씬 유연하다
        - 새로운 서브 클래스를 정의하지 않고도 기존 응용 프로그램에 새로운 기능을 추가할 수 있다.
        - 하지만 오히려 이해하기 어려워질 수도 있다
        - -> 브릿지, CoR, 데코레이터, 옵저버, 전략
    - 클래스 변경이 편하지 못한 점
        - 클래스를 변경하는 게 어려울 때가 있다
        - -> 어댑터, 데코레이터, 비지터

#### 응용프로그램

- 응용 프로그램을 구축할 때는 내부 재사용(internal reuse), 유지보수성 및 확장성의 우선순위가 높다

#### 툴킷

- 툴킷이란 일반적인 목적의 유용한 기능을 제공하는 재사용 가능한 클래스의 집합
- 툴킷은 코드 재사용을 도와준다
- 다만 여러 응용프로그램에서 툴킷을 사용할 수 있어야 하므로 응용프로그램 설계보다 더 어렵다
- 어떠한 목적으로 사용될지 모르기 때문에 가정을 최대한 줄여야한다

#### 프레임워크

- 프레임워크는 특정한 부류의 소프트웨어에 재사용을 부여해 개발할 수 있도록 만들어주는 클래스들의 집합이다
- 프레임워크는 설계의 가변성을 미리 정의해 두고 만들었기 때문에 응용프로그램 설계자나 구현자는 응용프로그램에 종속된 부분만 설계하면 된다
- 즉, 프레임워크는 응용프로그램 영역에 걸쳐 공통의 클래스들을 정의해 일반적인 설계 결정을 미리 해둔다
- 따라서 프레임워크는 코드의 재사용보다는 설계의 재사용을 강조한다


- 프레임워크를 사용하면 응용프로그램들이 비슷한 구조를 갖게 되므로 유지보수가 쉬워지고 일관된 모습이 남는다
- 대신 설계가 다 비슷비슷해진다


- 프레임워크 설계가 제일 어렵다
- 프레임워크는 더 유연하고 확장 가능하도록 설계해야 한다


- 응용프로그램과 프레임워크 사이의 결합도는 낮을수록 더 좋다.
- 그렇지 않으면 프레임워크에서 일어난 작은 변화가 응용프로그램을 크게 변화시킨다


- 디자인 패턴은 프레임워크의 문서화에도 도움을 준다


- 패턴과 프레임워크 사이에는 3가지 차이가 있다
    - 디자인 패턴이 프레임워크보다 더 추상적이다
    - 디자인 패턴은 프레임워크에 비해 소규모의 아키텍처다
    - 디자인 패턴은 프레임워크에 비해 덜 특수화되어 있다


- 프레임워크는 객체지향 시스템이 재사용의 효과를 최대화하는 방법이다

## 1.7 디자인 패턴을 고르는 방법

- 디자인 패턴은 종류가 많기 때문에 고르기 어렵다
- 문제에 적합한 디자인 패턴을 찾아내는 여러 가지 접근 방법이 있다
    - 패턴이 어떻게 문제를 해결했는지 파악하기
    - 패턴의 의도 살펴보기
    - 패턴들 간의 관련성 파악하기
    - 비슷한 목적의 패턴들을 모아서 공부하기
    - 재설계의 원인 파악하기
    - 설계에서 가변성을 가져야 하는 부분이 어디인지 파악하기

## 1.8 디자인 패턴 사용 방법

- 단계적으로 공부할 수 있다~


- 패턴을 단순하게 옮기는 것이 아니라 응용프로그램에 잘 맞게 적용하기


- 디자인 패턴을 아무렇게나 적용해서는 안 된다
- 오히려 설계를 복잡하게 만들고 성능을 떨어뜨리기도 한다
- 패턴을 적용할 때는 그 패턴이 주는 유연성이 정말로 필요한지 고려하기

