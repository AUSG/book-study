# Chapter 1. 서론
- 디자인 패턴의 요소
  - 패턴 이름: 한두 단어로 설계 문제와 해법을 서술
  - 문제: 언제 패턴을 사용하는가를 서술, 해결할 문제와 배경 설명
  - 해법: 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임, 협력 관계 서술
  - 결과: 디자인 패턴을 적용해서 얻는 결과와 장단점 서술

<br/>

- MVC
  - 모델: 응용프로그램 객체
  - 뷰: 스크린에 모델을 디스플레이 하는 방법
  - 컨트롤러: 사용자 인터페이스가 사용자 입력에 반응하는 방법 정의
- 뷰와 모델 간 등록/통지 프로토콜로 종속성 제거
  - 뷰는 반드시 모델과 동기화 되어 있어야 함
  - 일반적인 경우로도 확장 가능: 한 객체에서 일어난 변경을 다른 객체들에 반영하도록 별도의 객체 설계 -> 감시자 패턴
- Controller 객체를 사용해 반응 방법을 캡슐화
  - 뷰와 컨트롤러는 전략 패턴

<br/>

- 패턴 분류 기준
  - 목적: 패턴이 무엇을 하는지 정의
    - 생성: 객체의 생성 과정에 관여
    - 구조: 클래스나 객체의 합성에 관여
    - 행동: 클래스나 객체들이 상호작용하는 방법, 책임을 분산하는 방법 정의 
  - 범위: 패턴을 어디에 적용하는지
    - 클래스: 클래스와 서브클래스 간의 관련성, 상속, 컴파일 타임, 정적
    - 객체: 객체 관련성, 런타임, 동적

<br/>

- 객체: 데이터와 이 데이터에 연산을 가하는 프로시저를 함께 묶은 단위
  - 요청: 객체가 연산을 실행하게 하는 유일한 방법
  - 연산: 객체의 내부 데이터의 상태를 변경하는 유일한 방법
- 적당한 추상화를 통해 유연성을 해치지 않는 객체를 설계해야 함
- 디자인 패턴을 통해 알맞은 객체의 크기 결정 가능
- 인터페이스: 객체가 정의하는 연산의 모든 시그니처 => 객체의 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합
- "구현이 아닌 인터페이스에 따라 프로그래밍합니다."
- 상속 < 클래스 합성 < 객체 합성
- 위임(delegation): 두 객체가 하나의 요청 처리. 수신 객체가 연산의 처리를 위해 위임자에게 보냄.
- 제네릭(매개변수화된 타입): 타입을 정의할 때 타입이 사용하는 다른 모든 타입을 다 지정하지 않은 채 정의

<br/>

- 디자인 패턴을 써서 재설계를 할 수밖에 없게 하는 이유
  - 특정 클래스에서 객체 생성
  - 특정 연산에 의한 의존성
  - 하드웨어와 소프트웨어 플랫폼에 대한 의존성
  - 객체의 표현이나 구현에 대한 의존성
  - 알고리즘 의존성
  - 높은 결합도
  - 서브클래싱을 통한 기능 확장
  - 클래스 변경이 편하지 못한 점

<br/>

- 디자인 패턴과 프레임워크의 차이점
  - 디자인 패턴이 프레임워크보다 추상적
  - 디자인 패턴은 프레임워크에 비해 소규모의 아키텍처 요소
  - 디자인 패턴은 프레임워크에 비해 덜 특수화되어 있음

<br/>

- 디자인 패턴 고르는 방법
  - 패턴이 어떻게 문제 해결하는지 파악
  - 패턴의 의도 부분 보기
  - 패턴들 간의 관련성 파악
  - 비슷한 목적의 패턴을 모아서 공부
  - 재설계의 원인 파악
  - 설계에서 가변성을 가져야 하는 부분 파악