# Chapter 4. 구조 패턴
- 구조 패턴: 더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴
  - 구조 클래스 패턴: 상속 기법을 이용해 인터페이스나 구현을 복합
  - 구조 객체 패턴: 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법
  - 복합체 패턴: 두 종류의 객체에 대한 클래스로 클래스 계층 구조를 어떻게 형셩하는지 보여주는 방법
  - 플라이급 패턴: 객체들을 공유할 수 있는 구조 정의
  - 퍼사드 패턴: 여러 객체를 대표하는 객체인 퍼사드로 자신이 받은 메시지를 자신이 대표하고 있는 다른 객체에 전달하는 역할 수행
  - 가교 패턴: 객체의 개념적 추상화와 구현을 분리해 각각 독립적으로 다양하게 변형할 수 있게 함
  - 장식자 패턴: 객체에 동적으로 새로운 책임을 추가할 수 있는 방법 제공

<br/>

- 적응자
  - 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킴. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킴
  - 활용성
    - 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
    - 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
    - 이미 존재하는 여러 개의 서브클래스를 사용해야 하는에 서브클래스들의 상속을 통해 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때 (객체 적응자만 해당)
  - 결과
    - 어댑터 클래스는 어댑티 클래스를 상속하기 때문에 어댑티에 정의된 행동을 재정의할 수 있음
    - 한 개의 객체만 사용하며 어댑티로 가기 위한 추가적인 포인터 간접화는 피룡하지 않음
    - 하나의 어댑터 클래스로 모든 어댑티 클래스와 이를 상속받는 서브클래스 모두를 이용할 수 있게 됨
    - 어댑티 클래스의 행동을 재정의하기가 매우 어려움
  - 고려해야 하는 것
    - 어댑터 클래스가 실제 적응 작업을 위해 들어가는 폼을 얼마나 되나
    - 대체 가능 적응자
    - 양방향 적응자를 통한 투명성 제공
  - 구현
    - 클래스 적응자를 C++로 구현
    - 대체 가능 적응자 구현
      - 어댑티에 정의된 인터페이스들 중 적응이 필요한 연산의 최소 집합을 만듦
  
<br/>

- 가교
  - 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 함
  - 활용성
    - 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고 싶을 때
    - 추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장되어야 할 때
    - 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무런 영향을 주지 않아야 할 때
    - 사용자에게 구현을 완벽하게 은닉하길 원할 때 (C++)
    - 처음의 Motivation 다이어그램에서 본 것처럼 클래스 계통에서 클래스 수가 급증하는 것을 방지하고자 할 때
    - 여러 객체들에 걸쳐 구현을 공유하고자 하며, 사용자 쪽에 공개하고 싶지 않을 때
  - 결과
    - 인터페이스와 구현 분리
    - 확장성 제고
    - 구현 세부 사항을 사용자에게서 숨기기
  - 구현
    - Implementor 하나만 두기
    - 정확한 Implementor 객체 생성
    - Implementor 공유

<br/>

- 복합체
  - 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성
  - 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴
  - 활용성
    - 부분-전체의 객체 계통을 표현하고 싶을 때
    - 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때
  - 결과
    - 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통 정의
    - 사용자의 코드가 단순해짐
    - 새로운 종류의 구성요소 쉽게 추가 가능
    - 설계가 지나치게 범용성을 많이 가짐
  - 구현
    - 포함 객체에 대한 명확한 참조자
    - 구성요소 공유
    - Component 인터페이스를 최대화
    - 자식을 관리하는 연산 선언
    - 컴포넌트가 컴포넌트의 리스트를 구현하는 건 자식의 개수가 어느 정도 될 때만 가치 있는 방법
    - 자식 사이의 순서 정하기
    - 성능 개선을 위한 캐싱
    - 가비지 컬렉션이 없는 경우 Composite 클래스가 구성요소 삭제의 책임을 짐
    - 구성요소를 저장하기 위해 가장 적당한 데이터 구조 고민