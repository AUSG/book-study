# 단위테스트의 원칙

단위 테스트는 상대적으로 격리된 방식으로 코드의 구별되는 단위를 테스트한다.

코드의 단위는 특정 클래스, 함수, 코드 파일을 의미할 때가 많다.

테스트를 통해 궁극적으로 중요한 것은 코드를 잘 테스트하고 이 작업을 유지보수할 수 있는 방법으로 수행하는 점이다.

## 단위 테스트 기초
- 테스트 중인 코드: 실제 코드
- 테스트 코드: 단위 테스트를 구성하는 코드
- 테스트 케이스: 테스트 코드의 각 파일의 일반적인 케이스
  - 준비: 테스트할 특정 동작을 호출하기위헌 수행
  - 실행: 테스트 중인 동작을 실제로 호출하는 코드
  - 단언: 테스트 중인 동작이 실행되고 나면 실제로 올바른 일이 발생했는지 확인

- 테스트 러너: 실제로 테스트를 실행하는 도구

## 좋은 단위 테스트는 어떻게 작성할 수 있는가?
단위 테스트에서 문제가 발생하면 유지 관리가 매우 어렵고, 버그가 테스트 코드에서 발견되지 못하고 배포한 뒤애 발생할 수 있다.

좋은 테스트의 조건)
- 훼손의 정확한 감지
- 세부 구현 사항에 독립적
- 잘 설명되는 실패
- 이햐할 수 있는 테스트 코드
- 쉽고 빠르게 실행

### 훼손의 정확한 감지
단위 테스트의 가장 명확하고 주된 목표는 코드가 훼손되지 않았는지 확인하는 것이다.

- 코드에 대한 초기 신뢰를 준다: 코드 병합 전 실수를 발견할 수 있다.
- 미래의 훼손을 막하준다: 다른 개발자들이 코드 변경 과정에서 실수로 코드를 훼손할 가능성을 줄여준다.

### 세부 구현 사항에 독립적

- 기능적 변화: 코드가 외부로 보이는 동작을 수정한다.
- 리팩터링: 큰 함수를 작은 함수로 분할하거나 재사용하기 쉽도록 코드의 구주를 변화한다.

### 잘 설명되는 실패
무심코 망가뜨린 코드를 잘 모를 수 있기 때문에 테스트 실패가 무엇이 잘못됐는지 알려주지 않는다면 그것을 알아내기 위해 많은 시간을 낭비할 것이다.

### 이해 가능한 테스트 코드
서로 다른 테스트 케이스가 무엇을 위한 테스트인지 쉽게 이해할 수 있다.

### 쉽고 빠른 실행
테스트를 빠르고 쉽게 유지해야 실제로 많은 테스트를 진행하고 효율을 극대화할 수 있다.

## 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라.
퍼블릭 API에 집중하면 세부 사항이 아닌 코드 사용자가 궁극적으로 신경 쓸 동작에 집중할 수 밖에 없다. 이렇게 하면 중요한 사항만 테스트하는데 도움이 된다.

## 테스트 더블
의존성을 실제로 사용하는 것에 대한 대안으로 테스트 더블이 있다. 의성을 시뮬레이션하는 객체지만 테스트에 더 적합하게 사용할 수 있다.

### 테스트 더블을 사용하는 이유

- 테스트 단순화
- 테스트로부터 외부 세계 보호
- 외부로부터 테스트 보호

### 목(Mock)
목은 클래스나 인터페이스를 시뮬레이션하는 데 멤버함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않는다.

### 스텁
스텁은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션한다.

### 목과 스텁은 문제가 될 수 있다.
- 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다.
- 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.

### 페이크
페이크는 클래스의 대체 구현체로 테스트에서 안전하게 사용할 수 있다.

- 페이크로 인해 보다 실질적인 테스트가 가능하다.
- 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다.

## 테스트 철학으로부터 신중하게 선택하라.
- TDD: 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성한다.
- BDD: 사용자, 고객, 비즈니스 관점에서 소프트웨어가 보여야 할 행동을 식별하는데 집중하는 것이다.
- ATDD: 고객의 관점에서 소프트웨어가 보여줘야하는 동작을 식별하고 작동하는지 검증한다.