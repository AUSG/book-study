- [9. 코드를 재사용하고 일반화할 수 있도록 하라](#9------)
    - [9.1 가정을 주의하라](#91--)
        - [9.1.1 가정은 코드 재사용 시 버그를 초래할 수 있다](#911--------)
        - [9.1.2 해결책: 불필요한 가정을 피하라](#912----)
        - [9.1.3 해결책: 가정이 필요하면 강제적으로 하라](#913-----)
            - [문제의 소지가 있는, 강제되지 않은 가정](#-----)
            - [가정의 강제적 확인](#--)
    - [9.2 전역 상태를 주의하라](#92---)
        - [9.2.1 전역 상태를 갖는 코드는 재사용하기에 안전하지 않을 수 있다](#921---------)
            - [누군가 이 코드를 재사용하려고 하면 어떻게 되는가?](#------)
        - [9.2.2 해결책: 공유 상태에 의존성 주입하라](#922-----)
    - [9.3 기본 반환값을 적절하게 사용하라](#93----)
        - [9.3.1 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다](#931---------)
        - [9.3.2 해결책: 상위 수준의 코드에서 기본값을 제공하라](#932------)
    - [9.4 함수의 매개변수를 주목하라](#94---)
        - [9.4.1 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다](#941---------)
        - [9.4.2 해결책: 함수는 필요한 것만 매개변수로 받도록 하라](#942-------)
    - [9.5 제네릭의 사용을 고려하라](#95---)
        - [9.5.1 특정 유형에 의존하면 일반화를 제한한다](#951-----)
        - [9.5.2 해결책: 제네릭을 사용하라](#952---)

# 9. 코드를 재사용하고 일반화할 수 있도록 하라

- 이미 누군가가 주어진 하위 문제를 해결했다면 이를 재사용하는 것이 타당하다
    - 시간 절약
    - 이미 테스트되었으므로 버그 가능성 줄어든다

- 하지만 하위 문제에 대한 해결책이 이미 존재한다고 항상 재사용할 수 있는 것은 아니다
    - 자신의 사례에 맞지 않는 가정을 하거나
    - 필요 없는 다른 기능과 함께 구성되어 있거나

- 따라서 향후에 재사용이 가능하도록 의도적으로 코드를 작성하고 구조화하는 것이 바람직하다
- 초기에 좀 더 노력이 필요하지만, 아주 많이 필요하지는 않으며 장기적으로 시간을 절약해준다

- 이는 간결한 추상화 계층과 모듈화와 관련되어 있다
- 이렇게 하면 하위 문제에 대한 해결책이 서로 느슨하게 결합하는 코드로 나누어지는 경향이 있다

## 9.1 가정을 주의하라

- 가정을 하면 코드가 더 단순해지거나, 효율적으로 되거나, 둘 다 될 수도 있다
- 하지만 가정으로 인해 코드가 더 취약해지고 활용도가 낮아져 재사용하기에 안전하지 않을 수 있다
    - 이를 재사용하거나, 혹은 수정할 때 문제가 될 수 있다
- 즉, 코드를 개선하는 쉬운 방법처럼 보였던 가정이 코드가 재사용되자마자 버그의 원인이 될 수도 있다

- 따라서 가정을 할 때는 가정으로 초래될 비용과 이점을 생각해봐야 한다
- 코드 단순화, 효율성의 명백한 이득이 미미하다면 오히려 늘어난 취약성으로 인한 비용이 장점을 능가할 수도 있다

### 9.1.1 가정은 코드 재사용 시 버그를 초래할 수 있다

- 가정은 코드 깊숙한 곳 코드 혹은 주석에 있기 때문에 호출하는 쪽에서 이를 인지할 가능성은 매우 낮다

### 9.1.2 해결책: 불필요한 가정을 피하라

- 가정이 가져다 주는 이익이 크지 않은 경우 가정이 별로 가치가 없을 수도 있다
- 오히려 코드를 재사용하거나 요구 사항이 변경되면 버그가 발생할 수도 있다

- 다만 가정이 가져다 주는 이점이 크다면 가정은 충분히 가치가 있다

### 9.1.3 해결책: 가정이 필요하면 강제적으로 하라

- 코드에 가정이 있더라도 다른 개발자는 가정을 모를 수도 있다는 것을 명심해야 한다
- 따라서 가정을 확실하게 알리기 위해서 가정을 강제적으로 시행해야 한다
    1. 가정이 깨지지 않게 만들어라
        1. 가정이 깨지면 컴파일이 되지 않도록
    2. 오류 전달 기술을 사용하라
        1. 가정을 깨지지 않게 만드는 것이 불가능한 경우 오류를 감지하고 오류 신호 전달 기술을 사용해 신속하게 실패

#### 문제의 소지가 있는, 강제되지 않은 가정

- 강제되지 않는 가정에 의존하는 함수가 또 여러 개 퍼져있는 경우 이를 사용하는 다른 코드에서 문제가 퍼질 수도 있다

#### 가정의 강제적 확인

- 실패와 오류는 명확하게 드러나는 것이 최선이다
- 오류 전달 기법을 사용하여 가정을 강제로 인지하게 만들 수 있다

- 가정은 취약성의 증가라는 측면에서 관련 비용을 수반하는 경향이 있다
- 만약 가정이 필요하다면 다른 개발자가 그 가정으로 인해 오류에 빠지지 않도록 최선을 다해야 한다

## 9.2 전역 상태를 주의하라

- 전약 상태(global state) 또는 전역 변수(global variable)는 실행되는 프로그램 내의 모든 콘텍스트 사이에 공유된다
- 전역변수는 프로그램 내의 모든 콘텍스트에 영향을 미치기 때문에 전역변수를 사용할 때는 누구도 해당 코드를 다른 목적으로 재사용하지 않을 것이라는 암묵적인 가정을 전제한다

### 9.2.1 전역 상태를 갖는 코드는 재사용하기에 안전하지 않을 수 있다

- 전역 상태를 갖는 코드는 재사용하기 어렵다

#### 누군가 이 코드를 재사용하려고 하면 어떻게 되는가?

- 문제를 방지하기 위해 중복 코드가 생기거나, 문제가 생긴다
- 전역 상태를 사용하지 않는 것이 훨씬 낫다

### 9.2.2 해결책: 공유 상태에 의존성 주입하라

- 의존성 주입은 전역 상태를 사용하는 것보다 더 통제된 방법으로 서로 다른 클래스 간에 상태를 공유하는 좋은 방법이기도 하다

## 9.3 기본 반환값을 적절하게 사용하라

- 합리적인 기본값은 사용자 친화적인 소프트웨어를 만들기 위한 좋은 방법이다
- 사용자가 직접 사용하지 않는 소프트웨어에서도 기본값은 여전히 유용하다

- 단, 기본값을 제공하려면 다음과 같은 가정이 필요하다
    - 어떤 기본값이 합리적인지
    - 더 상위 계층의 코드는 기본값을 받든지 명시적으로 설정된 값을 받든지 상관하지 않는다

- 이런 가정을 상위 수준의 코드에서 하는 것이 낮은 층위에서 하는 것보다 비용이 적게 드는 경향이 있다
    - 가정의 비용
- 낮은 수준의 코드는 근본적인 하위 문제를 해결하여 더 광범위하게 재사용되는 경향이 있어서 모든 용도에 적합한 기본값을 선택하기가 훨씬 더 어렵다

### 9.3.1 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다

- 기본값을 정의하는 코드의 계층이 낮을수록 그 가정이 적용되는 상위 계층은 더 많아진다
- 기본값을 제공하는 클래스와 기본값을 정의하는 것은 별개의 문제다
- 더 나은 방법은 상위 계층의 코드가 자신에게 적합한 방식으로 기본값을 처리할 수 있도록 하는 것이다

### 9.3.2 해결책: 상위 수준의 코드에서 기본값을 제공하라

- 어떤 기본값을 사용할지에 대한 결정을 호출하는 쪽에서 하도록 하면 코드의 재사용성이 향상된다

## 9.4 함수의 매개변수를 주목하라

- 함수가 데이터 객체나 클래스 내의 포함된 모든 정보가 필요한 경우 해당 함수가 객체나 클래스의 인스턴스를 매개변수로 받는 것이 타당하다
    - 매개변수가 줄어들고 데이터의 세부 사항을 알 필요도 없다
- 하지만 함수가 한두 가지 정보만 필요로 할 때는 객체나 클래스의 인스턴스를 매개변수로 사용하는 것은 코드의 재사용성을 해칠 수 있다

### 9.4.1 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다

- 필요 없는 값에 대해서도 많이 알아야 하므로 재사용하기 어려워진다
- 함수는 필요한 것만 매개변수로 받는 것이 더 바람직하다

### 9.4.2 해결책: 함수는 필요한 것만 매개변수로 받도록 하라

- 일반적으로 함수가 필요한 것만 받으면 재사용성이 올라가고 이해하기도 쉽다
    - 단, 이는 상황에 따라 다르므로 각자 판단해야 한다
- 객체 대신 값을 전달하면 모듈성을 해칠 수 있다

## 9.5 제네릭의 사용을 고려하라

- 제네릭 혹은 템플릿을 사용하면 유형에 대한 구체적 명시 없이 클래스를 만들 수 있다
- 제네릭을 사용하면 아주 적은 양의 추가 작업이 있지만 코드의 일반화가 크게 향상된다

### 9.5.1 특정 유형에 의존하면 일반화를 제한한다

- 하위 문제가 비슷함에도 불구하고 특정 유형에 의존하면 다른 하위 문제를 해결해줄 만큼 일반화되지 않는다
- 코드가 일반화되어 거의 동일한 하위 문제를 해결할 수 있다면 훨씬 더 바람직하다

### 9.5.2 해결책: 제네릭을 사용하라

- 하위 문제에 대한 해결책이 모든 데이터 유형에 쉽게 적용될 수 있을 때 특정 유형에 의존하는 대신 제네릭을 사용하더라도 추가적인 노력이 거의 들어가지 않는다
- 하지만 덕분에 코드는 더 일반화되고 재사용이 가능해진다


