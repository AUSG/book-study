- [11. 단위 테스트의 실제](#11---)
    - [11.1 기능뿐만 아니라 동작을 시험하라](#111----)
        - [11.1.1 함수당 하나의 테스트 케이스만 있으면 적절하지 않을 때가 많다](#1111---------)
        - [11.1.2 해결책: 각 동작을 테스트하는 데 집중하라](#1112------)
            - [모든 동작이 테스트되었는지 거듭 확인하라](#----)
            - [오류 시나리오를 잊지 말라](#---)
    - [11.2 테스트만을 위해 퍼블릭으로 만들지 말라](#112-----)
        - [11.2.1 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다](#1121--------)
        - [11.2.2 해결책: 퍼블릭 API를 통해 테스트하라](#1122---api--)
        - [11.2.3 해결책: 코드를 더 작은 단위로 분할하라](#1123------)
    - [11.3 한 번에 하나의 동작만 테스트하라](#113-----)
        - [11.3.1 여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안 될 수 있다](#1131----------)
        - [11.3.2 해결책: 각 동작은 자체 테스트 케이스에서 테스트하라](#1132-------)
        - [11.3.3 매개변수를 사용한 테스트](#1133---)
    - [11.4 공유 설정을 적절하게 사용하라](#114----)
        - [11.4.1 상태 공유는 문제가 될 수 있다](#1141------)
        - [11.4.2 해결책: 상태를 공유하지 않거나 초기화하라](#1142-----)
        - [11.4.3 설정 공유는 문제가 될 수 있다](#1143------)
        - [11.4.4 해결책: 중요한 설정은 테스트 케이스 내에서 정의하라](#1144-------)
        - [11.4.5 설정 공유가 적절한 경우](#1145----)
    - [11.5 적절한 어서션 확인자를 사용하라](#115----)
        - [11.5.1 부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다](#1151---------)
        - [11.5.2 해결책: 적절한 확인자를 사용하라](#1152----)
    - [11.6 테스트 용이성을 위해 의존성 주입을 사용하라](#116------)
        - [11.6.1 하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다](#1161--------)
        - [11.6.2 해결책: 의존성 주입을 사용하라](#1162----)
    - [11.7 테스트에 대한 몇 가지 결론](#117-----)

# 11. 단위 테스트의 실제

## 11.1 기능뿐만 아니라 동작을 시험하라

- 개발자들이 종종 실수하는 것은 테스트할 목록에 함수 이름만 추가하는 것이다
    - 즉, 함수마다 하나의 테스트 케이스를 작성

- 함수는 종종 여러 개의 동작을 할 수도 있고, 한 동작이 여러 함수에 걸쳐 있을 수도 있다
- 함수별로 테스트 케이스를 하나씩만 작성하면 중요한 동작을 놓칠 수 있다
- 따라서 함수가 수행하는 모든 동작을 테스트해야 한다

### 11.1.1 함수당 하나의 테스트 케이스만 있으면 적절하지 않을 때가 많다

- 개발자가 행동이 아니라 기능 테스트에 집중하면 코드가 잘못 수정되어도 테스트는 여전히 통과할 수 있다

### 11.1.2 해결책: 각 동작을 테스트하는 데 집중하라

- 함수와 동작 사잉 일대일로 연결이 안 되는 경우가 많다
- 함수 자체를 테스트하는 데만 집중하면, 정작 실제로 신경 써야 할 중요한 동작을 검증하지 않는 테스트 케이스를 작성하기가 매우 쉽다

- 테스트 코드의 양이 실제 코드의 양보다 많지 않다면, 모든 동작이 실제로 테스트되고 있지 않음을 나타내는 경고 표시일 수도 있다

- 테스트를 위해 코드가 보일 행동을 생각해내는 연습을 하는 것은 코드의 잠재적인 문제를 발견하는 좋은 방법이다

#### 모든 동작이 테스트되었는지 거듭 확인하라

- 코드가 제대로 테스트되었는지 여부를 측정하기 위한 한 가지 좋은 방법은 수정된 코드에 버그나 오류가 있음에도 여전히 테스트를 통과할 수 있는지에 대해 생각해보는 것이다
    - 삭제해도 여전히 컴파일되거나 테스트가 통과한다
    - 참 거짓 논리를 반대해도 테스트가 통과하는가
    - 논리 연산자나 산술 연산자를 바꿔도 테스트가 통과하는가
    - 상수값이나 하드 코딩된 값을 변경해도 테스트가 통과하는가

- 모든 코드에는 존재 이유가 있어야 한다
- 불필요한 코드라면 제거되어야 한다
    - 아니라면 이에 의존하는 어떤 중요한 행동이 있다는 것을 의미한다

- 기능을 변경하면 적어도 하나의 테스트 케이스는 실패해야 한다

- 단 예외가 있는데 바로 방어적으로 프로그래밍 오류를 검사하는 코드다
    - 이는 코드를 의도적으로 수정해 가정을 깨는게 아니라면 테스트 할 수가 없다

- 돌연변이 테스트(mutation test)를 사용하면 기능의 변화가 테스트 실패를 초래하는지 확인하는 것을 어느 정도 자동화할 수 있다

#### 오류 시나리오를 잊지 말라

- 간과하기 쉬운 또 다른 중요한 동작은 오류 시나리오가 발생할 때 코드가 어떻게 동작하는가다

- 코드가 서로 다른 오류 시나리오를 처리하고 알리는 방법은 코드를 작성하거나 호출하는 쪽 모두가 관심을 갖는 중요한 동작이다
- 따라서 이 경우 역시 테스트해야 한다

- 함수당 하나의 테스트 케이스만 작성하는 것으로 테스트가 충분히 되는 경우는 거의 없다
- 함수에 집중하기 보다는 궁극적으로 중요한 모든 행동을 파아갛고 각각에 대한 테스트 케이스가 있는지 확인하는 것이 더 효과적이다

## 11.2 테스트만을 위해 퍼블릭으로 만들지 말라

- 프라이빗 함수는 구현 세부 사항이며 클래스 외부의 코드가 인지하거나 직접 사용하는 것이 아니다
- 프라이빗 함수 중 일부를 테스트 코드에서 사용할 수 있도록 하고 싶을 때도 있지만 이는 좋은 생각이 아니다
    - 구현 세부 사항과 밀접하게 연관된 테스트가 될 수 있다
    - 궁극적으로 우리가 신경 써야 하는 코드의 동작을 테스트하지 않을 수 있기 때문이다

### 11.2.1 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다

- 프라이빗 함수를 테스트를 위해 퍼블릭으로 만들고 이를 주석문으로 명시해도 이는 세부 조항이무로 간과되기 쉽다
- 또한 우리가 중요하게 여기는 동작을 제대로 테스트하지 못할 수도 있다
- 테스트가 구현 세부 사항에 독립적이지 못하게 된다
- 퍼블릭 API를 변경한 효과를 갖는다

- 좋은 단위 테스트는 궁극적으로 중요한 행동을 테스트해야 한다
- 이렇게 하면 테스트는 코드의 문제점을 정확하게 감지할 가능성을 극대화하여 구현 세부 사항에 독립적으로 된다

### 11.2.2 해결책: 퍼블릭 API를 통해 테스트하라

- 이 원칙의 목적은 구현 세부 사항이 아니라 실제로 중요한 동작을 테스트하라는 것이다

- 테스트를 위해 프라이빗 함수를 퍼블릭으로 만들어 외부로 보이게 하는 것은 대부분의 경우 구현 세부 사항을 테스트한다는 것을 보여주는 경고 신호다
- 단, 어떤 행동이 중요하고 궁극적으로 신경 써야 하는 것이라면, 퍼블릭 API 여부와 상관없이 테스트되어야 한다

- 클래스가 너무 복잡하거난 많은 논리를 포함하면 퍼블릭 API를 통해 모든 동작을 테스트하는 것이 까다로울 수 있다
- 이 경우 코드의 추상화 계층이 너무 크다는 것을 의미하기 때문에 코드를 더 작은 단위로 분할하는 것이 유익하다

### 11.2.3 해결책: 코드를 더 작은 단위로 분할하라

- 클래스가 하는 일이 너무 많다면 테스트학 어려울 수 있다
- 이 경우 클래스를 더 작은 단위로 분할하면 테스트가 더 수월해질 수 있다

- 코드를 테스트하기 위해 프라이빗 함수를 퍼블릭으로 만든다면 이는 실제로 신경 써야 하는 행동을 테스트하지 않는다는 경고 신호로 받아들여야 한다

## 11.3 한 번에 하나의 동작만 테스트하라

- 각각의 시나리오는 그에 해당하는 별도의 테스트 케이스로 테스트하는 것이 가장 자연스럽다

### 11.3.1 여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안 될 수 있다

- 테스트 케이스가 정확히 무엇을 하고 있는지 이해하기 어렵다
- 혹은 실패 메시지가 어떤 동작에 문제가 있는지 설명하는 데 있어 특별한 도움이 되지 않는다

### 11.3.2 해결책: 각 동작은 자체 테스트 케이스에서 테스트하라

- 잘 명명된 테스트 케이스를 사용해 각 동작을 개별적으로 테스트해야 한다
- 단, 코드 중복이 많아진다는 단점이 있다
- 만약 각 테스트 케이스에서 사용된 값과 설정이 일부 사소한 차이를 제외하고 거의 동일한 경우 매개변수화된 테스트를 사용하면 도움이 될 수 있다

### 11.3.3 매개변수를 사용한 테스트

- 매개변수를 사용한 테스트를 활용하면 테스트 케이스를 나누면서 중복을 줄이는 효과를 얻을 수 있다

## 11.4 공유 설정을 적절하게 사용하라

- 테스트 케이스는 의존성을 설정하거나 테스트 데이터 저장소에 값을 채우거나 다른 종류의 상태를 초기화하는 등 어느 정도의 설정이 필요할 때가 있다
- 이런 설정을 하려면 시간과 노력이 많이 들고, 리소스도 많이 필요하므로 설정이나 상태를 공유하는 경우가 종종 있다

- 상태 공유(sharing state)
    - 실행하는 데 시간이 오래 걸리거나 비용이 많이 드는 경우 유용하다
    - 하지만 가변적인 경우 다른 테스트 케이스에 악영향을 미칠 수 있다
- 설정 공유(sharing configuration)
    - 테스트 케이스 사이에서 설정을 공유한다
    - 그러나 이도 문제가 될 수 있다

- 설정 공유는 테스트를 단순화하기 위한 유용한 방법이다
- 그러나 이는 양날의 검이 될 수 있다
    - 잘못된 방법으로 테스트 설정을 공유하면 테스트가 취약하고 효과적이지 못할 수 있다

### 11.4.1 상태 공유는 문제가 될 수 있다

- 한 테스트 케이스가 수행하는 모든 조치는 다른 테스트 케이스에 영향을 미치지 않아야 한다
- 테스트 케이스 간에 상태를 공유하고 이 상태가 가변적이면 이 규칙을 실수로 위반하기 쉽다

- 상태를 공유하지 않는 것이 최선이다
- 꼭 필요하다면 한 테스트 케이스에 의한 변경이 다른 테스트 케이스에 영향을 미치지 않도록 조심해야 한다

### 11.4.2 해결책: 상태를 공유하지 않거나 초기화하라

- 가장 좋은 방법은 공유하지 않는 것다
    - 매번 새 인스턴스를 생성하거나 테스트 더블을 사용한다
- 불가능하다면 각 테스트 케이스 간에 반드시 상태가 초기화되도록 많은 주의를 기울여야 한다

### 11.4.3 설정 공유는 문제가 될 수 있다

- 설정을 공유하면 테스트가 효과적이지 못할 때가 있다
    - 설정을 수정했을 때 여전히 테스트는 통과하지만 처음 테스트를 만들 때 테스트하려고 했던 의도에서 벗어날 수 잇다
        - 즉, 문제가 발생했을 때 해당 테스트는 완벽하게 보호하지 못한다

- 설정 공유는 테스트 코드 반복을 줄여주지만 일반적으로 테스트에서 중요한 값이나 상태는 공유하지 않는 것이 최선이다
- 설정을 공유하면 어떤 테스트 케이스가 어떤 특정 항목에 의존하는지 정확하게 추적하는 것이 매우 어려우며, 향후 변경 사항이 발생했을 때 테스트 케이스가 원래 목적했던 동작을 더 이상 테스트하지 않게 될 수 있다

### 11.4.4 해결책: 중요한 설정은 테스트 케이스 내에서 정의하라

- 모든 테스트 케이스에 대해 반복해서 설정을 하는 것이 어려워 보일 수 있지만 테슽 케이스가 특정 값이나 설정 상태에 의존한다면 그렇게 하는 것이 더 안전한 경우가 많다
- 보통 헬퍼 함수를 사용하면 더 쉽게 작업할 수 있으므로 코드를 반복하지 않아도 된다

- 테스트 케이스의 결과가 설정값에 직접 영향을 받는 경우 해당 테스트 케이스 내에서 설정하는 것이 가장 좋다
    - 향후의 코드 변경으로 인해 의도치않게 테스트 코드에 문제가 생기는 것을 방지할 수 있다
    - 또한 각 테스트 케이스에서 원인과 결과가 명확해진다

### 11.4.5 설정 공유가 적절한 경우

- 테스트 설정 공유는 조심해야 하지만 반드시 하지 말아야 하는 것은 아니다
- 필요하면서도 테스트 케이스의 결과에 직접적인 영향을 주지 않는 설정이 있다면 이는 공유해도 괜찮다

## 11.5 적절한 어서션 확인자를 사용하라

### 11.5.1 부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다

- 테스트는 실패했을 때 왜 실패했는지, 어떻게 다른지 충분히 설명해줘야 한다

### 11.5.2 해결책: 적절한 확인자를 사용하라

- 코드에 문제가 있을 때 테스트가 반드시 실패해야 한다는 점 외에도 테스트가 어떻게 실패할지에 대해 생각해보는 것이 중요하다

## 11.6 테스트 용이성을 위해 의존성 주입을 사용하라

- 테스트 대상 코드에서 사용하는 의존성의 특정 인스턴스를 테스트 코드가 제공해야 하는 경우가 있다
- 테스트 코드가 이 작업을 할 수 없는 경우 특정 동작을 테스트하는 것이 불가능할 수도 있다

### 11.6.1 하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다

- 하드 코딩된 의존성은 테스트 코드에서 수정할 수가 없어 테스트가 불가능할 수도 있다

### 11.6.2 해결책: 의존성 주입을 사용하라

- 의존성 주입을 사용하면 테스트 코드에서 의존성을 교체할 수 있다
- 또한 의존성 주입을 사용하면 코드를 조금 더 느슨하게 결합되게 만들어 테스트 용이성을 높여준다

## 11.7 테스트에 대한 몇 가지 결론

- 통합 테스트, 종단 간 테스트

- 회귀 테스트
    - 코드가 잘못 변경되면 이를 감지해주는 테스트
- 골든 테스트
    - 스냅샷 비교
    - 실패 원인 파악이 어렵고 어쩔 때는 매우 취약하고 신뢰하기 어렵다
- 퍼즈 테스트
    - 무작위 값이나 흥미로운 값으로 코드를 호출하고 코드의 동작이 멈추지 않는지 테스트한다
