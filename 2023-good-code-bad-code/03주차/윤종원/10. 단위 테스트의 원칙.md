- [10. 단위 테스트의 원칙](#10---)
    - [10.1 단위 테스트 기초](#101---)
    - [10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?](#102-------)
        - [10.2.1 훼손의 정확한 감지](#1021---)
        - [10.2.2 세부 구현 사항에 독립적](#1022----)
        - [10.2.3 잘 설명되는 실패](#1023---)
        - [10.2.4 이해 가능한 테스트 코드](#1024----)
        - [10.2.5 쉽고 빠른 실행](#1025---)
    - [10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라](#103--api-----)
        - [10.3.1 중요한 동작이 퍼블릭 API 외부에 있을 수 있다](#1031----api----)
    - [10.4 테스트 더블](#104--)
        - [10.4.1 테스트 더블을 사용하는 이유](#1041----)
            - [테스트 단순화](#-)
            - [테스트로부터 외부 세계 보호](#---)
            - [외부로부터 테스트 보호](#--)
        - [10.4.2 목](#1042-)
        - [10.4.3 스텁](#1043-)
        - [10.4.4 목과 스텁은 문제가 될 수 있다](#1044------)
            - [목과 스텁은 실제적이지 않은 테스트를 만들 수 있다](#-------)
            - [목과 스텁을 사용하면 테스트가 구현 세부 정보에 유착될 수 있다](#---------)
        - [10.4.5 페이크](#1045-)
            - [페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다](#-------)
            - [페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다](#--------)
        - [10.4.6 목에 대한 의견](#1046---)
    - [10.5 테스트 철학으로부터 신중하게 선택하라](#105----)

# 10. 단위 테스트의 원칙

- 코드가 처음 작성될 때 그리고 수정될 때마다 코드가 의도한 대로 작동한다는 것을 스스로 확신할 수 있는 방법이 필요하다
    - 테스트는 이런 확신을 하기 위한 주된 방법이다

- 단위 테스트는 상대적으로 격리된 방식으로 코드의 구별되는 단위를 테스트하는 것이다
    - 어떤 개발자들은 단위 테스트에서 테스트 대상이 되는 코드가 의존하는 코드를 차단하려고 하는 반면, 다른 개발자들은 의존하는 코드를 포함해서 테스트하는 것을 선호한다

- 결국 테스트의 목적은 코드를 잘 테스트하고 이 작업을 유지보수할 수 있는 방법으로 수행하는 것이다것이다

## 10.1 단위 테스트 기초

- 테스트는 중요하다
- 훌륭한 테스트를 하기 위해서는 테스트만 있다고 되는 것이 아니라, 좋은 테스트가 필요하다

## 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?

- 단위 테스트를 제대로 작성하는 것은 어렵다
- 단위 테스트에서 문제가 생기면 유지 관리가 매우 어렵고, 버그가 테스트 코드에서 발견되지 못하고 배포한 뒤에 발생할 수도 있다

- 좋은 단위 테스트가 가져야 할 5가지 주요 기능
    - 훼손의 정확한 감지
        - 코드가 훼손되면 테스트가 실패
        - 테스트는 코드가 훼손된 경우에만 실패
    - 세부 구현 사항에 독립적
        - 세부 구현 사항을 수정하더라도 테스트 코드는 수정하지 않는다
    - 잘 설명되는 실패
        - 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명
    - 이해할 수 있는 테스트 코드
        - 테스트 코드가 무엇을 테스트하고, 어떻게 테스트하는지 이해하기 쉬워야 한다
    - 쉽고 빠르게 실행
        - 빠르게 실행되어야 한다

### 10.2.1 훼손의 정확한 감지

- 단위 테스트의 가장 명확하고 주된 목표는 코드가 훼손되지 않았는지 확인하는 것이다
    - 의도된 대로 수행하며 버그가 없다는 것을 확인

- 원래 코드가 훼손되면 컴파일되지 않거나 테스트가 실패해야 한다
- 이는 매우 중요한 두 가지 역할을 한다
    - 코드에 대한 초기 신뢰를 준다
        - 쉽게 실수를 발견하고 수정할 수 있다
    - 미래의 훼손을 막아준다
        - 코드의 훼손을 막는 방법은 컴파일을 중지하거나 테스트가 실패하는 것이다
        - 컴파일을 멈추는 것은 불가능하니 모든 올바른 동작을 테스트를 통해 확인해야 한다
        - 코드 변경으로 인해 되던 기능이 안되는 것을 회귀(regression)이라고 한다
        - 회귀를 탐지할 목적으로 테스트를 실행하는 것을 회귀 테스트(regression test)라고 한다

- 또한 테스트는 대상 코드가 실제로 훼손된 경우에만 실패해야 한다
- 코드가 정상일 때 때로는 성공하고 때로는 실패하는 테스트를 플래키(flakey)라고 한다
    - 무작위성, 타이밍 기반 레이스 조건, 외부 시스템에 의존하는 등의 테스트의 비결정적 동작에 기인한다

- 만약 코드가 정상인데 테스트가 계속 실패하면 사람들은 테스트를 무시할 것이다

### 10.2.2 세부 구현 사항에 독립적

- 기능적인 변경은 테스트 코드도 같이 수정되기를 기대한다
    - 만약 그러지 않아도 된다면 원래 테스트가 충분하지 않았을 수도 있다
- 리팩터링은 구현 세부 사항은 변경하지만 기능 변경은 없으므로 이상적이라면 테스트 코드를 수정하지 않아도 된다
    - 이런 테스트를 작성하면 리팩터링에 대한 확신을 갖기가 매우 쉽다
    - 테스트가 구현 세부 정보에 의존하지 않으면 코드 리팩터링에 실수가 있었는지 확인해주는 테스트 결과를 신뢰할 수 있다

- 일반적으로 기능 변경과 리팩터링을 동시에 하지 않는 것이 좋다

### 10.2.3 잘 설명되는 실패

- 결국 개발자는 테스트가 실패하면 원인을 찾아야 한다
- 테스트가 코드에서 동작하지 않는 부분을 명확하고 정확하게 설명하려면 문제가 발생했을 때 어떤 실패 메시지를 만들어낼지, 이것이 개발자에게 유용할지 생각해볼 필요가 있따

- 테스트 실패가 잘 설명되도록 하는 좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사하고 각 테스트 케이스에 대해 서술적인 이름을 사용하는 것이다
- 테스트가 실패할 때 케이스 이름만 확인해도 파악할 수 있다

### 10.2.4 이해 가능한 테스트 코드

- 새로운 기능을 반영하면 테스트 코드도 수정해야 한다
- 테스트 코드도 일종의 코드 수정이다
    - 즉, 정확히 수정하고자 하는 부분만 수정해야 한다

- 문제가 발생할 수 있는 가장 일반적인 두 가지 경우는 다음과 같다
    - 한 번에 너무 많은 것을 테스트하는 것
    - 너무 많은 공유 테스트 설정을 사용하는 것
- 이는 이해하기 어렵고 추론하기 어려운 테스트로 이어질 수 있다

- 또한 일부 개발자들은 테스트 코드를 일종의 사용 설멍서로 사용하기 때문에 테스트 코드는 이해하기 쉬워야 한다

### 10.2.5 쉽고 빠른 실행

- 단위 테스트는 자주 실행한다
- 느린 단위 테스트는 개발자의 작업 속도를 느리게 만든다
- 테스트가 느리면 테스트가 힘든 작업이 되고, 테스트가 힘들면 하고 싶지 않은 마음이 든다

## 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

- 퍼블릭 API에 초점을 맞추면 세부 사항이 아닌 코드 사용자가 궁극적으로 신경 쓸 동작에 집중할 수밖에 없다
- 이는 실제로 중요한 사항만 테스트하는 데 도움이 되며, 테스트 과정에서 구현 세부 사항에 상관없이 테스트를 수행할 수 있다

### 10.3.1 중요한 동작이 퍼블릭 API 외부에 있을 수 있다

- 테스트 대상 코드는 수많은 다른 코드에 의존하는 경우가 많다
    - 의존하는 코드에 외부 입력이 제공되거나, 부수 효과를 일으킨다면 테스트의 의미가 달라질 수도 있따

- 퍼블릭 API를 사용해 도작을 시작하거나 확인할 수 없다면 테스트하지 말아야 한다는 주장도 있다
- 하지만 퍼블릭 API로 제공되지 않는 것 중에서도 테스트 코드가 알아야 할 다른 사항들이 있을 수 있다
    - 설정해야 하는 의존성은 세부 사항이지만 설정하지 않고는 테스트를 할 수 없다
- 퍼블릭 API가 아니더라도 중요한 동작이라면 테스트해야 한다
    - 즉, 무엇이 목적인지, 무엇이 수단인지를 잘 구분해서 테스트를 짜야한다

- 가능하면 퍼블릭 API를 사용해서 테스트한다
- 그러나 중요한 동작을 퍼블릭 API로 테스트할 수 없는 경우도 있다
    - 서버와 상호작용 하거나 데이터베이스에 값을 읽고 쓰는 경우
    - 이런 경우에는 퍼블릭 API를 벗어날 필요가 있다
        - 테스트를 구현 세부 사항에 최대한 독립적으로 수행하도록 주의해야 한다
- 결국 가장 중요한 것은 코드의 모든 중요한 동작을 테스트하는 것이다

## 10.4 테스트 더블

- 코드는 종종 다른 것에 의존한다
- 코드를 완벽하게 테스트하기 위해서는 입력을 설정하고 부수 효과를 검증해야 한다
- 하지만 의존성을 실제로 사용하는 것이 항상 가능하거나 바람직한 것은 아니다

- 의존성을 실제로 사용하는 것에 대한 대안으로 테스트 더블(test double)이 있다.
    - 목, 스텁, 페이크
- 테스트 더블은 의존성을 시뮬레이션하는 객체지만, 테스트하기 편하도록 만들어져있다

### 10.4.1 테스트 더블을 사용하는 이유

- 다음과 같은 목적으로 테스트 더블을 사용한다
    - 테스트 단순화
        - 일부 의존성은 테스트에 사용하기 어렵다
            - 의존성이 복잡한 경우 테스트는 더 복잡해지고 구현 세부 사항과 밀접하게 결합될 수 있다
        - 의존성 대신 테스트 더블을 사용하면 테스트가 단순홰진다
    - 테스트로부터 외부 세계 보호
        - 일부 의존성은 실제로 부수 효과가 발생한다
            - 테스트 더블을 사용하면 외부에 있는 시스템을 테스트로부터 보호할 수 있다
    - 외부로부터 테스트 보호
        - 외부 세계가 비결정적일 수도 있다
        - 이 경우 테스트를 신뢰하기 어렵다
        - 테스트 더블을 사용하면 항상 동일하게 결정적 방식으로 작동하도록 설정할 수 있다

#### 테스트 단순화

- 의존성 자체에서 많은 매개 변수를 필요로 하거나, 의존성이 또 다른 하위 의존성을 많이 가지거나 할 수도 있다
- 하위 의존성에서 원하는 부수 효과가 발생했는지 검증해야 할 수도 있다
- 이런 경우 테스트 코드가 너무 불어날 수 있으며 수많은 구현 세부 정보와 밀접하게 연결될 수 있다

- 테스트 더블을 사용하면 실제 의존성을 설정하거나 하위 종속성에서 무언가를 검증할 필요가 없다
- 또한 테스트를 더욱 빠르게 실행할 수 있다

- 하지만 테스트 더블을 설정하는 것이 의존성을 실제로 사용하는 것보다 복잡한 경우도 있으므로 경우에 따라 적합한 선택을 해야한다
- 또한 테스트 더블을 사용하면 구현 세부 정보와 더 연관되는 경우도 있다

#### 테스트로부터 외부 세계 보호

- 의존성이 부수 효과를 실제로 일으킨다면 문제가 될 수 있다
    - 사용자에게 이상한 값이 보인다
    - 모니터링 및 로깅에 영향을 줄 수 있다
- 실제 의존성 대신 테스트 더블을 사용하면 테스트로부터 외부 세계를 보호할 수 있다

#### 외부로부터 테스트 보호

- 의존성이 비결정적인 동작을 하는 경우가 있다
- 이 경우 테스트 결과를 신뢰하기 어렵다
- 테스트 더블을 사용하면 이 동작을 결정적으로 만들 수 있다

### 10.4.2 목

- 멤버 함수에 대한 호출만 기록하고 아무런 동작도 하지 않는다
    - 이때 호출된 인수도 기록한다
- 즉, 함수를 호출하는지 검증하기 위해 목을 사용할 수 있다
- 목은 **부수 효과를 일으키는 의존성**을 시뮬레이션 하는데 가장 유용하다

- 목은 테스트로부터 외부 세계를 보호할 수 있지만 테스트가 비현실적이고 중요한 버그를 잡지 못할 위험이 있다

### 10.4.3 스텁

- 스텁은 함수가 호출되면 미리 정해 놓은 값을 반환한다
- 테스트 대상 코드가 의존하는 코드로부터 어떤 값을 받아야 하는 경우 그 의존성을 시뮬레이션하는 데 유용하다

- 외부로부터 테스트를 보호할 때 유용하다
    - 비결정적인 상황을 결정적이게 만들 수 있다

- 목과 스텁에는 차이가 있지만 일상적으로 목은 둘 다 지칭한다

### 10.4.4 목과 스텁은 문제가 될 수 있다

- 목과 스텁은 몇 가지 문제를 일으킬 수 있다
    - 목이나 스텁이 실제 의존성과 다르게 동작하도록 설정되는 경우 테스트는 실제적이지 않다
    - 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다

#### 목과 스텁은 실제적이지 않은 테스트를 만들 수 있다

- 개발자가 목 객체나 스텁을 만들 때 어떻게 동작할지 결정해야 한다
    - 이때 실제 동작과 다를 수 있다
- 잘못 설정한 경우 테스트는 통과하고 모든 것이 잘 작동한다고 착각하지만 코드가 실제로 실행되면 부정확하게 동작하거나 버그가 발생할 수 있다

- 실제 코드에 버그가 있어도 테스트에서 목을 잘못 사용하면 테스트는 통과하고 버그는 드러나지 않을 수 있다

- 테스트 코드를 작성하는 개발자는 목이 어떻게 동작할지 결정해야 하는데, 실제 의존성이 어떻게 동작하는지 이해하지 못하면 목을 설정할 때 실수를 할 가능성이 크다

- 스텁의 경우에도 마찬가지다
    - 이 값이 의존성 코드가 실제로 반환하는 값인지 아무런 검증을 하지 않는다

#### 목과 스텁을 사용하면 테스트가 구현 세부 정보에 유착될 수 있다

- 목과 스텁을 사용하면 테스트가 구현 세부 사항과 결합되어 리팩터링에도 테스트가 실패할 수 있다
- 테스트는 구현 세부 사항에 구애받지 않아야 하지만 리팩터링에 문제가 있는 것인지, 목이나 스텁에 문제가 있는 것인지 구분하기 어렵다

- 필자 왈
    - 목이나 스텁은 최소한으로 사용하는 것이 최선이다
    - 가능한 대안이 없다면 그래도 목이나 스텁을 써서 테스트를 작성하는게 없는 것보다 낫다
    - 개인적으론 실제 의존성이나 페이크를 사용하는 것을 권장한다

### 10.4.5 페이크

- 페이크는 클래스 또는 인터페이스의 대체 구현체로 테스트에서 안전하게 사용할 수 있다
- 실제 의존성의 공개 API를 정확하게 시뮬레이션하지만 구현은 일반적으로 단순하다

- 페이크는 코드 계약이 실제 의존성과 동일하다
    - 따라서 실제 의존성에 대한 코드를 유지보수 하는 팀이 페이크 코드도 유지보수 해야한다

- 페이크는 실제 의존성의 인터페이스의 모든 기능을 구현하는 것 외에도 테스트를 위한 몇몇 함수들을 추가적으로 구현할 수도 있다

- 자신의 팀이 특정 클래스나 인터페이스에 대한 코드를 관리하고 있고, 실제 코드를 테스트에 사용하는 것이 적합하지 않다면 페이크를 구현하는 것이 좋다
- 페이크가 존재한다면 목이나 스텁보다는 페이크를 사용하는 것이 더 낫다

#### 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다

- 페이크는 실제 의존성과 동일하게 동작하고, 코드 계약 또한 같기 때문에 더 정확하게 테스트할 수 있다
- 테스트를 하는 이유는 코드에 버그가 있으면 테스트가 실패하고, 이를 작성자가 인지하도록 하는 것이다

#### 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다

- 테스트가 페이크를 사용하는 경우 내부 구현 세부 사항 대신 그로 인한 결과를 확인한다
- 즉, 최종적인 결과를 확인하기에 구현 세부 사항과 관련해서 훨씬 독립적이다

### 10.4.6 목에 대한 의견

- 목 찬성론자(mockist)
    - 런던 학파
    - 의존성을 실제로 사용하는 것을 피해야 하고 대신 목을 사용해야 한다고 주장
    - 상호작용을 테스트 -> **어떻게**
- 고전주의자(classicist)
    - 디트로이트 학파
    - 목과 스텁은 최소한으로 사용하고 의존성을 실제로 사용하는 것을 최우선
    - 실제 의존성을 사용하는 것이 가능하지 않을 때, 페이크를 사용하는 것을 선호
    - 목과 스텁은 실제 의존성이나 페이크를 사용할 수 없을 때 최후의 수단으로 사용
    - 결과 상태와 의존성을 테스트 -> 최종 결과가 **무엇인지**
    - 필자는 이를 선호

- 목 사용을 지지하는 주장
    - 단위 테스트가 더욱 격리된다
    - 테스트 코드 작성이 더 쉬워진다

- 목 사용에 반대하는 입장
    - 목은 코드 호출은 검증하지만 실제로 호출이 유효한지는 검증하지 않는다
        - 코드에 문제가 있어도 테스트는 통과할 수 있다
    - 구현 세부 사항에 대해 더 독립적인 테스트를 할 수 있다
        - 어떻게 이를 달성하는 지에 대해서는 관심을 갖지 않는다

## 10.5 테스트 철학으로부터 신중하게 선택하라

- 테스트에 대한 다양한 철학이 있다
    - 자신이 옳다고 생각하는 바를 여러 철학에서 신중하게 선택하면 된다

- TDD
- BDD
- ATDD(수용 테스트 주도 개발, Acceptance test-driven development)