# 3주차 (9장 ~ 마지막)

# 9장 코드를 재사용하고 일반화할 수 있도록 하라

- 동일한 문제를 이전에 해결했다면 그 방법을 쓰는 것이 시간 절약에 도움이 된다.
- 코드를 재사용할 수 있도록 구조화해서 작성하는 법은 중요하다.
- 추상화 계층을 만들고 코드를 모듈화해서 느슨한 결합을 하는 코드를 짜자

## 안전하게 재사용할 수 있는 코드 작성 방법

- 가정을 주의하라. 가정은 코드 재사용 시 버그를 초래할 수 있다.
    - 해결책
        - 최대한 불필요한 가정을 피해라 (섣부른 최적화)
        - 가정이 필요하면 강제적으로 해라
            - 가정이 깨지지 않게 만들어라
            - 오류 전달 기술을 사용해라
- 전역 상태를 주의하라. 전역상태는 코드를 취약하게 만들고 재사용하기도 어렵게 만든다.
    - 해결책
        - 프로그램의 서로 다른 부분간에 상태를 공유해야할 경우 공유상태에 의존성 주입하라
        - 상위 수준의 코드에서 기본 반환 값을 적절하게 사용하라.
            - 기본 반환값을 제공하려면 두 가지 가정이 필요
                - 어떤 기본값이 더 합리적인가
                - 상위 계층의 코드는 기본값을 받든지 명시적으로 설정된 값을 받든지 상관하지 않는다.
            - 낮은 층위의 코드 기본 반환값은 재사용성을 해칠 수 있다.

## 다양한 문제를 해결하기 위해 일반화된 코드를 작성하는 방법

- 함수의 매개변수를 주목하라. 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다.
    - 해결책
        - 함수는 필요한 것만 매개변수로 받도록 하라
    - 10가지 항목을 캡슐화하는 클래스가 있고 그중 8개를 필요로 하는 함수가 있다면 캡슐화 객체 전체를 함수에 전달하는 것이 합리적이다.
        - 모듈성을 해칠수 있기 때문
- 제네릭(혹은 템플릿)의 사용을 고려하라. 특정 유형에 의존하면 일반화를 제한한다.
    - 해결책
        - 제네릭을 사용하라.
            - T를 사용하면 다른 객체나, 타입으로도 커버할 수 있는 코드를 짜게된다.

# 10장 단위 테스트의 원칙

- 단위 테스트는 상대적으로 격리된 방식으로 진행되어야 한다.

## 단위 테스트의 기본 사항

- 테스트 중인 코드(실제 코드)와 테스트 코드로 나뉜다.
- 테스트 케이스는 준비 / 실행 / 단언 의 세 요소로 이루어진다. (given / when / then)
- 테스트 러너는 테스트 코드를 실행하는 파일이다.

## 좋은 단위 테스트가 되기 위한 조건

- 훼손의 정확한 감지
    - 두 가지 역할
        - 코드에 대한 초기 신뢰를 준다.
        - 미래의 훼손을 막아준다. → 회귀테스트
    - 실제로 훼손된 경우에만 테스트가 실패해야한다.
- 세부 구현 사항에 독립적
    - 기능적 변화와 리팩터링 정도의 변경이 있을 수 있지만 이것에 독립적이어야한다.
    - 기능 변경과 리팩터링을 같이 하지 마라
- 잘 설명되는 실패
    - 어떤 것때문에 어떤 것이 망가졌는지 잘 알려줘야한다.
- 이해할 수 있는 테스트 코드
    - 테스트의 어느 부분에 영향을 미치고 있는지, 테스트코드에 대한 수정이 필요한지에 대한 여부를 우리는 알고있어야 한다.
    - 한번에 너무 많은 것을 테스트 하거나 너무 많은 공유 테스트 설정을 하는 것이 이해를 어렵게 만든다.
    - 일부 개발자들은 테스트를 코드에 대한 사용 설명서로 인식하기 때문
- 쉽고 빠르게 실행
    - 코드를 병합할 때마다 검사를 수행하게 된다. 짧고 빠르게 실행될 수록 좋다.
- 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라.
    - 퍼블릭 API에 집중하면 세부사항은 상관없이 결과만 집중하게 된다.
    - 중요한 동작이 퍼블릭 API 외부에 있을 수 있다.
        - 설정을 수행하고 원하는 부수 효과를 확인하기 위해 테스트가 공용 API의 일부가 아닌 종속성과 상호작용해야 하는 경우가 많다.

## 테스트 더블

- 테스트 더블을 사용해야 하는 이유
    - 테스트 단순화
        - 하위 모듈을 신경쓰지 않아도 되고, 더 빠르게 실행 가능하다.
    - 테스트로부터 외부 세계 보호
        - 돈뽑는 테스트를 하는데 실제 돈이 뽑히면 안된다.
        - 사용자는 이상하고 혼란스러운 값을 볼 수 있다.
        - 모니터링 및 로깅에 영향을 미칠 수 있다.
    - 외부로부터 테스트 보호
        - 외부 변경요소로부터 실패하는 것을 막는다.
- 목 (Mock)
    - 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떤 일도 수행하지 않는다.
    - 테스트 대상 코드가 의존성을 통해 제공되는 함수를 호출하는지 검증하기 위해 목 사용 가능
    - 테스트 대상 코드에서 부수 효과를 일으키는 의존성을 시뮬레이션하는 데 가장 유용하다.
- 스텁 (Stub)
    - 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 한다.
    - 객체 자체를 모킹하는 것이 아닌 해당 함수만 스터빙한다.
- 목과 스텁은 문제가 될 수 있다.
    - 목과 스텁이 실제 의존성과 다른 방식으로 동작하게 된다면 테스트는 실제적이지 않다.
    - 구현 세부사항과 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.
- 페이크 (Fake)
    - 외부시스템과 통신하는 대신 페이크 내의 멤버 변수에 상태를 저장한다.
    - 실제 의존성에 대한 코드 계약이 변경되면 페이크의 코드 계약도 동일하게 변경되어야 한다.
    - 페이크로 인해 실질적인 테스트가 이루어질 수 있다.
    - 구현 세부 정보로부터 테스트 분리 가능
- 목에 대한 의견
    - 런던파와 고전파가 있다.

## 테스트 철학

- 테스트 철학과 방법론들
    - TDD(테스트 주도 개발)
    - BDD(행동 주도 개발)
    - ATDD(수용 테스트 주도 개발)
- 효과적인 방법으로 진행해라.

# 11장 단위 테스트의 실제

## 코드의 모든 동작을 효과적이고 신뢰성 있게 테스트하기

### 기능 뿐만 아니라 동작을 시험하기

- 함수당 하나의 테스트 케이스만 있으면 적절하지 않은 경우가 많다.
- 해결책: 각 동작을 테스트 하는데 집중하라.
- 모든 동작이 테스트되었는지 거듭 확인하라.
- 오류 시나리오를 잊지마라.

### 테스트만을 위해 퍼블릭으로 만들지 마라

- 클래스 외부로 빼지 마라.
- 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다.
- 해결책: 퍼블릭 API를 통해 테스트하라.
- 해결책: 코드를 더 작은 단위로 분할하라

### 한번에 하나의 동작만 테스트 하자

- 여러 동작을 한번에 테스트하면 테스트가 잘 안될 수 있다.
- 너무 길면 이해하기가 어려운 코드가 될 수 있다.
- 해결책: 각 동작은 자체 테스트 케이스에서 테스트하라.
- 매개변수를 사용한 테스트

### 공유 설정을 적절하게 사용하라.

- 반복되는 작업은 BeforeAll, AfterEach 등을 사용해서 코드 수를 줄이자.
- 상태공유와 설정공유측면에서 사용할 수 있다.
- 상태 공유는 문제가 될 수 있다.
    - 해결책: 상태를 공유하지 않거나 초기화하라
- 설정 공유는 문제가될 수 있다.
    - 해결책: 중요한 설정은 테스트케이스 내에서 정의하라

## 이해하기 쉽고 실패가 잘 설명되는 테스트 코드의 작성

### 적절한 어서션 확인자를 사용하라.

- 어서션 확인자(assertion matcher)는 테스트 통과 여부를 최종적으로 결정하기 위한 테스트 케이스 내의 코드이다.
- 부적합한 확인자는 테스트 실패를 잘 설명하지 못할 수 있다.
    - 해결책: 적절한 확인자를 사용해라.

## 의존성 주입을 사용해 테스트가 용이한 코드의 작성

### 테스트 용이성을 위해 의존성 주입을 사용하라.

- 하드 코딩된 의존성은 테스트를 불가능하게 할 수 있다.
    - 해결책: 의존성 주입을 사용하라.
-