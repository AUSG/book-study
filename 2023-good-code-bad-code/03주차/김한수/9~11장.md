# 9~11

# 9. 코드를 재사용하고 일반화할 수 있도록 하라

- 가정을 주의하라
  - 가정은 코드 재사용 시 위험이 생길 수 있다.
    - getAllImages() 함수에서 다수의 데이터 중 하나만 반환 (하나만 존재한다는 가정)
  - 불필요한 가정을 피하라
  - 가정이 필요하면 강제적으로 하라
    - 컴파일 시 가정이 깨지면 오류 발생하고록 하기
    - 오류 전달

## 요약

- 하위 문제로 분할하고 재사용할 수 있게 하라
- 가정은 코드를 종종 더 취약하고 재사용하기 어렵게 만든다.
  - 가정을 하는 경우의 이점이 비용보다 큰지 확인하라
  - 가정을 해야할 경우 그 가정이 코드의 적절한 계층에 대해 이루어지는 것인지 확인하고 가능하다면 가정을 강제적으로 적용하라.
- 전역상태를 피하라
  - 전역 상태를 사용하는 ㅁ건 특히 비용이 많이 발생하는 가정을 하는 것이 된다.
  - → 재사용하기에 전혀 안전하지 않다.

# 10. 단위 테스트의 원칙

- 단위 테스트는 사실 정확한 정의가 없다.
  - 단위테스트는 상대적으로 격리된 방식으로 코드의 구별되는 단위를 테스트하는 것.
  - 여기서 코드의 단위는 정확희 의미하는 바가 다양함.
- **사실 정확한 정의가 없다고 큰 문제가 되는 것은 아님 그러니 이것에 집착하지 않는 것이 좋음**
  - 궁극적으로 중요한 것은 코드를 잘 테스트하고 이 작업을 유지보수할 수 있는 방법으로 수행하는 것이다

## 좋은 단위 테스트 코드는 어떻게 작성할 수 있는가?

좋은 단위 테스트가 가져야할 다음 5가지 주요 기능을 정의한다.

- `훼손의 정확한 감지`
  - 코드가 훼손되면 테스트가 실패한다. 그리고 테스트는 코드가 실제로 훼손된 경우에만 실패해야 한다.
  - `코드에 대한 초기 신뢰를 줌`
    - 코드 훼손 시 테스트 실패를 통한 안정성
  - `미래의 훼손 방지`
    - 회귀 탐지
    - `회귀`(regression) : 코드 변경으로 인해 잘 돌아가던 기능이 작동하지 않는 것
- `세부 구현 사항에 독립적`
  - 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는 것이 이상적이다.
  - 테스트 내구성
- `잘 설명되는 실패`
  - 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명해야 한다.
- `이해할 수 있는 테스트 코드`
  - 다른 개발자들이 테스트 코드가 정확히 무엇을 테스트하기 위한 것이고 테스트가 어떻게 수행되는지 이해할 수 있어야 한다
- `쉽고 빠르게 실행`
  - 개발자는 일상 작업 중에 단위 테스트를 자주 실행한다.
  - 단위 테스트가 느리거나 실행이 어려우면 개발 시간이 낭비된다.

### 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

`퍼블릭 API를 사용한 테스트` 는 단위 테스트와 관련하여 매우 일반적인 조언이다.

- 이는 세부 사항이 아닌 코드 사용자가 궁극적으로 신경 쓸 동작에 집중하게 한다.
- 하지만 예외의 경우도 있다.
  - 중요한 동작이 퍼블릭 API가 아닌 경우는 테스트 해야함.
    - e.g. 캐싱 처리, 서버와 상호작용, DB 접근
- `Public API만을 이용해 테스트하라` 와 `실행 세부 사항을 테스트하지 말라` 는 둘 다 훌륭한 조언이지만, 테스트를 어떻게 할지 안내하는 원칙일 뿐이다.
  - 궁극적으로 중요한 것은 코드의 모든 중요한 동작을 제대로 테스트하는 것이고
  - 퍼블릭 API만으로 이게 불가능할 수도 있다.

## 테스트 더블

테스트를 위해 의존성 대안으로 사용되는 걸 통틀어 `테스트 더블(test double)`이라고 부른다

- mock, stub, fake 등
- 테스트 더블을 사용하는 이유
  - `테스트 단순화`
    - 일부 의존성은 테스트에 사용하기 까다롭고 힘들다 → 이걸 개선
  - `테스트로부터 외부 세계 보호`
    - 일부 의존성은 실제 부수 효과를 발생시킴 → 이걸 방어
  - `외부로부터 테스트 보호`
    - 외부 세계는 비결정적일 수 있음.
    - e.g. 데이터베이스에서 데이터 읽기는 조회 시점에 따라 데이터가 다를 수 있음

- 기능 구현과 리팩토링을 동시에 하지 말라

## 목(mock)

- `목(mock)`은 함수가 호출될 때 인수에 제공되는 값을 기록한다
- 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떤 한 일도 수행하지 않는다.
- 테스트 대상 코드가 의존성을 통해 제공되는 함수를 호출하는지 검증하기 위해 목을 사용할 수 있다.
- 따라서 목은 테스트대상 코드에서 부수 효과를 일으키는 의존성을 시뮬레이션하는 데 가장 유용하다.

## 스텁(stub)

- `스텁(stub)`은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 한다.
- 스텁은 테스트 대상 코드가 의존하는 코드로부터 어떤 값을 받아야 하는 경우 그 의존성을 시뮬레이션하는 데 유용하다.
- **목과 스텁 사이에는 분명한 차이가 있지만, 개발자들이 일상적으로 목이라고 말할 때는 둘 다 지칭한다.**

## 목과 스텁은 문제가 될 수 있다

- `목과 스텁의 주요 단점`
  - 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다.
  - 구현 세부 사항와 테스트가 밀접하게 결합하여 리팩터링이 어려워질 수 있다.

## 페이크(fake)

- 페이크는 외부 의존성의 공개 API를 새로 구현한다.
  - 단 실제 통신하는 대신 페크 내의 멤버 변수에 상태를 저장한다
  - 보다 실질적인 테스트 가능
  - 세부 정보로부터 테스트 분리

# 11. 단위 테스트의 실제

- 기능뿐만 아니라 동작을 시험하라.
  - 한 함수가 여러 동작을 수행할 수 있다.
  - 실제 비즈니스 플로우 테스트
  - 함수 이름을 테스트 목록에 넣기보다는 함수가 수행하는 모든 동작으로 목록을 채우는 것이 좋다.

## 모든 동작이 테스트되었는지 거듭 확인하라

다음 질문 중 어느 하나에 대한 대답이 “예”라면 모든 행동이 테스트되고 있지 못하다는 것을 의미한다.

- 삭제해도 여전히 컴파일되거나 테스트가 통과하는 코드 라인이 있는가?
- if 문의 참 거짓 논리를 반대로 해도 테스트가 통과하는가?
- 논리 연산자나 산술 연산자를 다른 것으로 대체해도 테스트가 통과하는가?
- 상숫값이나 하드 코딩된 값을 변경해도 테스트가 통과하는가?

## 테스트 관련 지침

기능을 변경한 경우 적어도 하나의 테스트 케이스가 실패해야 한다. 그렇지 않다면 모든 행동이 테스트되는 것이 아니다.

- 예외도 있다
  - 방어적으로 프로그래밍 오류를 검사하는 경우

- `테스트만을 위해 프라이빗 함수를 퍼블릭으로 만들지 말라`
  - 퍼블릭 API를 통해서 테스트하라
  - 복잡하거나 많은 논리를 포함하고 있어 테스트하기 어렵다면 코드를 더 작은 단위로 분할하라
- `프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많다`
  - 세부사항이라서
- `한 번에 하나의 동작만 테스트하라`
  - 여러 동작을 한꺼번에 테스트하면 테스트가 제대로 안 될 수 있다
    - 테스트 이름도 길어지므로 이해하기 쉬운 테스트 코드에서 점점 멀어진다
    - 보통 여러 동작을 한꺼번에 테스트하면 무언가 변경됐다는 것만 알려주지 정확히 무엇이 변경됐는지를 알려주진 않는다
  - 각 동작은 자체 테스트 케이스에서 테스트하라

## 적절한 어서션 확인자를 사용하라

- 어서션 확인자는 실패 이유를 설명하는 메시지를 생성한다.
- 따라서 가장 적절한 어서션 확인자를 선택하는 것이 중요하다.

## 골든 테스트

- `골든 테스트(golden test)`
  - 특성화 테스트(characterization test)라고도 하며 일반적으로 주어진 입력 집합에 대해 코드가 생성한 출력을 스냅샷으로 저장한 것을 기반으로 한다.
    - 테스트 수행 후 코드가 생성한 출력이 다르면 테스트는 실패한다
  - 이 테스트는 아무것도 변경되지 않았음을 확인하는 데는 유용하지만 테스트가 실패한 경우 실패 원인을 파악하기 어려울 수 잇다.
  - 이 테스트들은 또한 어떤 경우에는 믿을 수 없을 정도로 취약하고 신뢰하기 어렵다.

## 요약

- 각 함수를 테스트하다보면 테스트가 충분히 되지 못하기 쉽다.
  - 보통은 모든 중요한 행동을 파악하고 각각의 테스트 케이스를 작성하는 것이 더 효과적이다.
- 결과적으로 중요한 동작을 테스트해야 한다.
  - 프라이빗 함수를 테스트하는 것은 거의 대부분 결과적으로 중요한 사항을 테스트하는 것이 아니다.
- 한 번에 한 가지씩만 테스트하면 테스트 실패의 이유를 더 잘 알 수 있고 테스트 코드를 이해하기가 더 쉽다.
- 테스트 설정 공유는 양날의 검이 될 수 있다.
  - 코드 반복과 비용이 큰 설정을 피할 수 있지만 부적절하게 사용할 경우 효과적이지 못하거나 신뢰할 수 없는 결과를 초래할 수 있다.
- 의존성 주입을 사용하면 테스트 용이성이 상당히 향상될 수 있다.
- 단위 테스트는 개발자들이 가장 자주 다루는 테스트 수준이지만 이것만이 유일한 테스트는 아니다.
  - 높은 품질의 소프트웨어를 작성하고 유지하려면 여러 가지 테스트 기술을 함께 사용해야할 때가 많다. e.g. e2e 테스트
