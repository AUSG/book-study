# 9. 코드를 재사용하고 일반화할 수 있게 하라

## 가정을 주의하라

### 가정을 하는 코드란?

> 크롤링을 하는 함수가 이미지가 포함된 섹션이 나올때까지 문서 내의 섹션을 반복해서 확인하고 해당 섹션의 이미지를 반환하다고 하자. 이는 이미지가 포함된 섹션이 하나만 있다고 가정한 것이다. 이러면 조금 더 이미지를 빨리 찾을 수도 있지만 초래할 버그가 더욱 크다. 하이 리스크 로우 리턴이다.

### 해결책

1. 가정을 하지 마라
2. 가정을 강제적으로 하라 ⇒ 가정이 깨지면 오류를 리턴하거나 컴파일이 되지 않게 하라

## 전역 상태를 주의하라

전역으로 선언하면 모든 콘텍스트에 영향을 미치기 때문에 재사용하지 않을 것이라고 가정함. ⇒ 가정은 나빠

### 해결책

의존성 주입을 사용하라

## 기본값 반환을 적절하게 사용하라

default값을 적절히 반환해라. 단 너무 낮은 계층에서 사용하면 재사용이 힘들 수 있음.

낮은 계층에서는 null 등을 반환하고 상위 계층에서 이를 이용하여 기본값을 반환하도록 하자

## 필요한 매개변수만 받기

예를 들어 `setFontColor`함수에서 매개변수로 color뿐 아니라 다른 Font정보도 받는다면 좋지 않음.

재사용할 때 Color뿐만 아니라 다른 정보도 필요하기 때문.

## generic, template

특정 유형에 대해서만 사용할 수 있는 함수는 재사용하기 쉽지 않다.

generic, template를 사용하자

질문. generic 너무 유연하게 코드를 작성하면 오히려 코드 복잡도가 증가하고 예상하기 힘든 오류를 초래할 수 있을 것 같은데 다들 generic을 얼마나 사용하시나요? 예전에 Golang 무슨 컨퍼런스에서 비슷한 이유로 empty interface 사용을 자제하라는 말을 들었었는데 생각나서 여쭤봅니다.

# 10. 단위 테스트

## 좋은 단위 테스트

1. 훼손의 정확한 감지
2. 세부 구현 사항에 독립적
3. 잘 설명되는 실패
4. 이해할 수 있는 테스트 코드
5. 쉽고 빠르게 실행

> 기능변경과 리팩토링 같이 하지 않기

## test double

mock, stub 등을 사용해서 더욱 격리된 환경에서 테스트하는 것.

### test double이 필요한 이유

1. 테스트 단순화
2. 테스트로부터 외부 세계 보호 (은행의 경우 mock 안 쓰면 테스트코드로 실제 돈이 인출될 수도)
3. 외부로부터 테스트 보호 (은행의 경우 계좌 잔액이 바뀔 때마다 테스트케이스가 변해서 혼동)

### mock

클래스나 인터페이스를 시물레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않음

### stub

함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션한다.

> mock과 stub은 실제적이지 않은 테스트를 만들 수도 있고구현 세부 정보를 리팩토링하면 테스트코드가 고장날 수 있다.

### fake

클래스(혹은 인터페이스)의 대체 구현체로 테스트에서 안전하게 사용될 수 있다.

BankAccount에 의존성이 있는 코드에 대해 테스트를 진행한다면 FakeBankAccount를 만들어 사용하는 식.

# 11. 단위 테스트의 실제

1. 함수당 하나의 테스트 케이스만 있으면 부족할 때가 많다. ⇒ 모든 동작이 테스트되었는지 거듭 확인하기
2. 테스트만을 위해 퍼블릭으로 만들지 말자 ⇒ 프라이빗 함수를 테스트하는 것은 바람직하지 않을 때가 많음. 더욱 상위 레벨에서 public 함수를 테스트하던가(ex. api) 코드를 더 작은 단위로 분할해서 테스트해라.
3. 한 번에 하나의 동작만 테스트해라
4. 공유 설정은 문제가 될 수 있다. ⇒ 중요한 설정은 테스트 케이스 내에서 해라
5. 적절한 어서션 확인자를 사용하라
6. DI 사용
