# 좋은 코드 나쁜 코드

> [1주차] 2023-08-27 ~ 2023-09-01 <br>
> 작성일 2023-09-01

## Chapter 1. 코드 품질

### 고품질 코드
- 좀 더 신뢰할 수 있고, 유지보수가 쉬우며, 버그가 적은 소프트웨어를 생산하는 코드
- 좋은 소프트웨어인지 그렇지 않은지는 그 모든 작은 결정들이 모여서 이루어진다.

### 고품질 코드가 달성해야 할 네 가지 목표
1. 코드는 작동해야 한다. <br>
   (코드를 작성하는 이유는 문제를 해결하기 위함)
2. 코드는 작동이 멈추면 안 된다. <br>
   (변화하는 환경과 요구 사항에도 불구하고 계속 작동하는 코드를 만드는 것은 어려운 일)
3. 코드는 변경된 요구 사항에 적응할 수 있어야 한다.
4. 코드는 이미 존재하는 기능을 중복 구현해서는 안 된다. <br>
    (시간과 노력을 절약, 버그 가능성을 줄여줌, 기존 전문지식을 활용, 코드 이해가 쉬움)

### 코드 품질의 핵심 요소
1. 코드는 읽기 쉬워야 한다.
2. 코드는 예측 가능해야 한다.
3. 코드를 오용하기 어렵게 만들라.
4. 코드를 모듈화 하라.
5. 코드를 재사용 가능하고 일반화할 수 있게 작성하라.
6. 테스트가 용이한 코드를 작성하고, 제대로 테스트하라. <br>
    (단위 테스트, 통합 테스트, E2E 테스트)
    (테스트는 코드를 작성하는 모든 단계에서 고려할 것. 다 작성하고 고려 X)

### 고품질 코드 작성을 일정을 지연시키는가?
- 일반적으로 고품질 코드를 작성하는 것이 중장기적으로는 개발 시간을 단축해준다.
- 서두르지 않으면 더 빠르다.


## Chapter 2. 추상화 계층
- 코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며
- 코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다.

### 널값 및 의사코드 규약

### 왜 추상화 계층을 만드는가?
- 코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업이다.
- 사용하는 레이어에서는 추상화된 하위 계층이 보이지 않아 복잡해 보이지 않게 된다.
- 즉, 비록 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다.
- 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위험에도 불구하고 계층을 얇게 만다는 것이 좋다.

### 추상화 계층 및 코드 품질의 핵심 요소
- 코드 가독성
- 코드 모듈화
- 코드 재사용성 및 일반화
- 테스트 용이성 및 적절한 테스트

### 코드의 계층
- API 및 구현 세부 사항
- 함수
- 클래스
    - 줄 수 : 너무 큰 클래스를 작성하지 않도록 주의해야 한다.
    - 응집력 : 한 클래스 내의 모든 요소들이 얼마나 잘 속해있는지
        - 순차적 응집력, 기능적 응집력
    - 관심사의 분리
    - 응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.

### 예제 설명
- 의존성 주입, 팩토리 함수 사용
- 하나의 인터페이스 및 단일 구형
    - 퍼블릭 API를 매우 명확하게 보여 준다.
    - 한가지 구현만 필요하다고 잘못 추측한 것일 수 있다.
    - 테스트를 쉽게 할 수 있다.
    - 같은 클래스로 두 가지 하위 문제를 해결할 수 있다. -> 일반화

## Chapter 3. 다른 개발자와 코드 계약
- 코드베이스는 계속 변하고 일반적으로 여러 개발자에 의해 변경된다.

### 자신의 코드와 다른 개발자의 코드
- 다른 개발자의 코드를 재사용하는데, 여기서 중요한 점은 요구 사항이 항상 변한다는 점이다.
    - 우선순위 변경, 새로운 기능 추가, 새로운 기술 환경으로 옮겨야하는 등
- 다른 개발자들이 활발하게 코드를 변경하더라도 코드의 품질이 유지되려면 코드가 튼튼하고 사용하기 쉬워야 한다.
- 고품질 코드를 작성할 때 가장 중요한 고려 사항 중 하나는 다른 개발자가 변경하거나 코드와 상호작용할 때 발생할 수 있는 문제는 없는지, 또 발생한다면 그 문제를 어떻게 완화할 수 있을지를 이해하고 선제적으로 조치하는 것이다.
- 오용이 불가능하게 만드는 방식으로 코드를 작성할 수도 있다.

### 코드 작성 시, 다음 세 가지를 고려하는 것이 유용하다.

1. 자신에게 분명하다고, 명백하다고 해서 다른 사람에게도 분명한 것은 아니다.
    - 이것을 항상 고려하고 코드에 아래를 설명하는 것이 유용하다.
        - 어떻게 사용되어야 하는지
        - 무엇을 하는지
        - 왜 그 일을 하고 있는지
- 그렇다고 주석문을 많이 작성해야 한다는 의미는 아니다.
- 코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.

2. 다른 개발자는 무의식 중에 여러분의 코드를 망가뜨릴 수 있다.
3. 시간이 지남에 따라 자신의 코드를 기억하지 못한다.

### 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?
- 클래스, 메서드 **이름 확인**
- 데이터 유형 확인
- 문서 읽기 : 주석문, 공식 코드 내 문서, 외부 문서(테크 스펙 등)
- 직접 물어보기
- 코드를 살펴보는 것

### 코드 계약
- 선결 조건 precondition
- 사후 조건 postcondition
- 불변 사항 invariant
- 계약을 준수하도록 하기 위한 방법이지만 신뢰할만한 방법은 아니다.
- 보통 더 나은 접근법은 명백한 항목으로 계약의 내용을 전달하는 것이다.

### 계약의 세부 조항
- 세부 조항에 너무 의존하지 말라. 

### 체크 및 어서션: 계약 조건을 확인하기 위한 방법
- 일반적으로 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법이다.
- 이것이 가능하지 않을 때, 체크나 어서션을 사용하여 실행 시간에 계약을 확인할 수 있다.
- 체크
    - 전제 조건 검사
    - 사후 상태 검사
- 어서션 assertion
    - 코드 계약을 준수하도록 강제하기 위한 방법
    - 컴파일 타임에 제외된다는 점에서 체크와 차이점이 있음

## Chapter 4. 오류

### 복구 가능성
- 오류에는 크게 두 가지 종류가 있다 : 복구 가능 vs 불가능
- 복구 가능한 오류
    - 예) 네트워크 오류, 중요하지 않은 작업 오류
- 복구할 수 없는 오류
    - 오류를 복구할 수 있는 방법이 없다면, 유일하게 코드가 할 수 있는 합리적인 방법은 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화하는 것이다.
    - 신속한 실패, 요란한 실패!
- 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.
- 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라.

### 견고성 VS 실패 => 실패!!
- 실패 : 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.
- 견고성 : 오류를 처리하고 계속 진행한다.
- 오류가 있더라도 처리하고 계속 진행하면 더 견고한 코드라고 볼 수 있지만, 오류가 감지되지 않고 이상한 일이 발생하기 시작한다는 의미가 될 수 있다.
- 견고성보다는 실패가 많은 경우에 있어 최선일 수 있다.
- 신속하게 실패하기
    - 실패한 자리에서 바로 알리기
- 요란하게 실패하기
    - 크게, 상위 계층에 도달하도록 실패 알리기
    - 에러를 복구할 수 없는 경우에는 요란하게 실패하는 겻이 바람직하다.
- 복구 가능성의 범위
- 오류를 숨기지 않음
    - 오류를 숨기는 것은 바람직하지 않을 때가 많으며
    - 오류가 발생했다는 신호를 보내는 것이 바람직하다.

### 복구할 수 없는 오류의 전달
- 명시적 방법
    - 코드 계약의 명확한 부분. 호출하는 쪽에서는 오류가 발생할 수 있음을 인지한다.
- 암시적 방법
    - 코드 계약의 세부 조항을 통해 오류에 대한 설명이 제공되거나 전혀 설명이 없을 수도 있다.
    - 오류가 발생할 수 있다는 것을 호출하는 쪽에서 반드시 인지하는 것은 아니다.
    - 복구할 수 없는 오류에 대해서는 암시적 오류 전달 기법을 사용해야 한다.
- 비검사 예외를 발생 
- 프로그램이 패닉이 되도록
- 체크나 어서션의 사용

### 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달
- 비검사 예외를 사용해야 한다는 주장
- 명시적 기법을 사용해야 한다는 주장
- 필자의 의견: 명시적 방식을 사용하라
    - 잠재적으로 복구할 수 있는 오류에 대해서는 명시적인 기법이 사용되어야 한다.

### 컴파일러 경고를 무시하지 말라
- 컴파일러 경고는 종종 코드에 문제가 있을 때 이에 대해 표시해준다.
- 이 경고에 주의를 기울이는 것이 바람직하다.

## Chapter 5. 가독성 높은 코드를 작성하라

### 서술형 명칭 사용
- 서술적이지 않은 이름은 코드를 읽기 어렵게 만든다.
- 주석문으로 서술적인 이름을 대체할 수 없다.
- 서술적인 이름 짓기

### 주석문의 적절한 사용
- 적절한 사용
    - 코드가 무엇을 하는지 설명
    - 코드가 왜 그 일을 하는지 설명
    - 사용 지침 등 기타 정보 제공
- 중복된 주석문은 유해할 수 있다.
- 주석문으로 가독성 높은 코드를 대체할 수 없다.
- 주석문은 코드의 이유를 설명하는 데 유용하다.
- 주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다.

### 코드 줄 수를 고정하지 말라
- 간결하지만 이해하기 어려운 코드는 피하라
- 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라.
- 이것은 종종 가치 있는 절충이다.

### 일관된 코딩 스타일을 고수하라
- 일관적이지 않은 코딩 스타일은 혼종을 일으킬 수 있다.
- 스타일 가이드를 채택하고 따르라
    - 언어의 특정 기능 사용
    - 코드 들여쓰기
    - 패키지 및 디렉터리 구조화
    - 코드 문서화 방법

### 깊이 중첩된 코드를 피하라
- 깊이 중첩된 코드는 읽기 어려울 수 있다.
- 중첩을 최소화하기 위한 구조 변경
- 중첩은 너무 많은 일을 한 결과물이다.
- 더 작은 함수로 분리하여 중첩을 없애라.

### 함수 호출도 가독성이 있어야 한다
- 매개변수는 이해하기 어려울 수 있다.
- 명명된 매개변수를 사용
- 서술적 유형 사용
- 때로는 훌륭한 해결책이 없다.

### 설명되지 않은 값을 사용하지 말라
- 설명되지 않는 계수, 횟수, 문자열 등
- 설명되지 않은 값은 혼란스러울 수 있다.
- 잘 명명된 상수를 사용하라
- 잘 명명된 함수를 사용하라

### 익명함수를 적절하게 사용하라
- 익명 함수는 간단한 로직에 좋다
- 익명 함수는 가독성이 떨어질 수 있다.
- 대신 명명 함수를 사용하라
- 익명 함수가 길면 문제가 될 수 있다.
- 긴 익명 함수를 여러 개의 명명 함수로 나누라

### 프로그래밍 언어의 새로운 기능을 적절하게 사용하라
- 새 기능은 코드를 개선할 수 있다.
- 불분명한 기능은 혼동을 일으킬 수 있다.
- 작업에 가장 적합한 도구를 사용하라.