# 1. 코드 품질

>   좋은 코드가 좋은 소프트웨어를 만들기 위한 유일한 조건은 당연히 아니지만, 중요한 조건 가운데 하나다.



## 1.1. 코드는 어떻게 소프트웨어가 되는가

-   코드 베이스
-   코드 제출
-   코드 검토 ( 코드 리뷰 )
-   제출전 검사 ( pre commit )
-   배포
-   프로덕션



## 1.2. 코드 품질의 목표

>   안전하고, 실제로 작동하고, 고장나지 않고, 예측 가능한 행동을 해야한다.

1.   작동해야 한다.
2.   작동이 멈춰서는 안된다.
3.   변화하는 요구사항에 적응해야한다.
4.   이미 존재하는 기능을 또다시 구현해서는 안된다.



### 1.2.1. 코드는 작동해야한다

-   너무나 당연함
-   목표에 부합하는 방식으로 동작하는 것을 "작동한다."라고 표현 할 수 있다.



### 1.2.2. 코드는 작동을 멈춰서는 안된다

>   주의하지 않으면 주변상황에 의해 동작이 멈출 수도 있다.

-   변화하는 환경과 요구 사항에도 불구하고 계속 작동하는 코드를 만드는 것은 훨씬 더 어렵다.
-   코드가 계속 작동하도록 보장하는 것은 소프트웨어 엔지니어가 직면하는 큰 과제 중 하나이며, 모든 단계에서 고려해야 할 사항이다.



### 1.2.3 코드는 변경된 요구 사항에 적응할 수 있어야 한다

-   시나리오 A : 요구 사항이 어떻게 변할지 정확히 예측하고, 이 모든 변화에 맞추기 위해 노력해서 기한에 못 맞추는 경우
-   시나리오 B : 요구사항이 변할 수 있다는 것을 무시하고, 코드를 작성한 후 다음 변화에 맞추기 어려워지는 경우

둘 다 너무 극단의 케이스임. 위 케이스에서 적절히 중간 지점을 맞춰야 함.



### 1.2.4 코드는 이미 존재하는 기능을 중복 구현해서는 안된다

-   기존 해결책이 존재한다면 그것을 사용하자
    -   시간과 노력을 줄여줌
    -   버그 가능성을 줄여줌
    -   기존 전문지식을 활용 가능
    -   코드가 이해하기 쉬움



## 1.3 코드 품질의 핵심 요소

### 1.3.1 코드는 읽기 쉬워야 한다

>   코드는 읽는데 쓰여지는 시간이 쓰는데 쓰여지는 시간보다 훨씬 길다

-   코드의 가독성이 낮으면 다른 사람이 그 코드를 이해하는데 오랜 시간을 들여야한다
-   이를 통해 잘못된 이해나 몇가지 세부사항을 놓칠 수 있어 버그를 만들게 된다.
-   가독성을 높이자



### 1.3.2 코드는 예측 가능해야 한다

>   도움이 되거나 똑똑한 일을 수행하는 코드를 작성할 때, 아무리 좋은 의도를 가져도 예상을 벗어난 동작은 위험을 가진다.

-   코드가 예상을 벗어나는 일을 한다면, 그 코드를 사용하는 개발자는 그 상황을 알지 못하거나 대처할 생각을 하지 못할 것이다.
-   예측 불가능한 동작을 하는 코드를 작성하지 않도록 노력해야 한다.



### 1.3.3 코드를 오용하기 어렵게 만들어라

-   코드를 오용하기 어렵거나 불가능하게 만들면 코드가 잘 작동할 뿐만 아니라 계속해서 잘 작동할 가능성을 높일 수 있다.



### 1.3.4 코드를 모듈화하라

-   코드를 외부에 의존하지 않고 실행할 수 있는 모듈로 나누는 것이 이로울 때가 많다.
-   두 개의 인접한 모듈은 잘 정의된 인터페이스를 통해 소통하게 하면 변화하는 요구 사항에 더 쉽게 적응할 수 있는 코드를 작성하는데 도움이 된다.
-   모듈화된 시스템은 일반적으로 이해하기 쉽고 추론하기 쉬움
    -   기능이 관리 가능한 단위로 나누어지고, 기능 단위 간 상호작용이 잘 정의되고 문서화되기 때문



### 1.3.5 코드를 재사용 가능하고 일반화할 수 있게 작성하라

-   재사용성 
    -   어떤 문제를 해결하기 위한 무언가가 다른 상황에도 사용할 수 있음
-   일반화성
    -   개념적으로 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음
-   모듈화된 코드는 재사용성과 일반화성을 가짐.



### 1.3.6 테스트가 용이한 코드를 작성하고 제대로 테스트하라

-   테스트는 버그와 제대로 동작하지 않는 코드가 코드 베이스에 머지되는 상황을 막아줌
-   테스트
    -   단위 테스트
        -   개별 함수나 클래스와 같은 작은 단위의 테스트
    -   통합 테스트
        -   여러 구성 요소, 모듈, 하위 시스템으로 구성된 테스트
    -   E2E 테스트
        -   처음부터 끝까지 전체 소프트웨어 시스템에서 작동의 흐름을 테스트

-   테스트 용이성
    -   코드의 테스트 용이성이 낮으면 코드를 제대로 테스트하는 것이 불가능할 수 있음
    -   코드를 작성하면서 테스트 용이성도 고려하자



## 1.4 고품질 코드 작성은 일정을 지연시키는가?

-   처음에는 빨라보이지만, 느리게 가는게 제대로 가는 것.



## 요약

-   좋은 소프트웨어를 만들려면 고품질 코드를 작성해야한다
-   실제 서비스 환경에서 실행되는 소프트웨어가 되기 전에 코드는 일반적으로 여러 단계의 검사와 테스트를 통과해야 한다.
-   버그나 제대로 동작하지 않는 기능이 사용자에게 제공되거나 비즈니스에 중요한 시스템에서 실행되는 것을 이러한 검사를 통해 막을 수 있다.
-   테스트는 코드를 작성하는 모든 단계에서 고려하는 것이 좋다. 코드를 다 작성하고 나서 고려하는 것이 아니다.
-   고품질 코드를 작성하면 처음에는 시간이 오래 걸리지만, 중장기적으로는 개발시간이 단축되는 경우가 많다.



# 2.추상화 계층

>   코드를 잘 작성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다.



## 2.1 널 값 및 의사 코드 규약

-   널 안전성을 지원하는 언어가 많아지고 있다.
-   이 책의 코드는 널 안전성을 지원하는 의사 코드 규약을 가진다.



## 2.2 왜 추상화 계층을 만드는가?

-   HTTP 메시지 전송 예제
    -   알아야 할 것
        -   문자열 메시지 보내기
        -   HTTP 연결 얻기
        -   HTTP 연결 닫기
    -   몰라도 되는 것
        -   HTTP 세션 확립
        -   TCP 연결 확립
        -   등..

위와 같이 알아야 할 것과 몰라도 되는 것을 분리함.



### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소

-   깨끗하고 뚜렷한 추상화 계층을 확립하면, 1장에서 언급한 4가지 ( 가독성, 모듈화, 재사용성 및 일반화성, 테스트 용이성 ) 을 지키면서 코드를 작성 가능



## 2.3 코드의 계층

>   추상화 계층을 생성하는 방법은 서로 다른 단위로 분할하여 단위 간의 의존관계를 보여주는 의존성 그래프를 생성하는 것

그 단위는 다음과 같음

-   함수
-   클래스
-   인터페이스
-   패키지, 네임스페이스, 모듈



### 2.3.1 API 및 구현 세부 사항

-   코드를 호출할 때 볼 수 있는 내용
    -   퍼블릭 클래스, 인터페이스 및 함수
    -   이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
    -   코드 호출 시 코드를 올바르게 사용하기 위해 알아야하는 추가 정보
-   코드를 호출할 때 볼 수 없는 내용
    -   구현 세부 사항



### 2.3.2 함수

-   어떤 로직을 함수로 구현하면 대부분 유익하다.
-   함수에 포함된 코드가 하나의 잘 써진 짧은 문장으로 읽혀지만 매우 이상적임.
-   너무 많은 작업을 하는 함수는 private 함수등으로 분리하여 가독성을 높이자.



### 2.3.3 클래스

-   라인 수

    -   300줄 이상의 클래스는 분리해야한다는 것은 많은 경우에 사실
    -   하지만 이러한 규칙을 모든 경우에 사용하기 어려워서 실제로 사용하기에는 제한적임

-   응집력

    -   한 클래스내에 요소들이 얼마나 잘 속해 있는지를 보여주는 척도
    -   순차적 응집력
        -   한 요소의 출력이 다른 요소의 입력으로 필요할 때 발생
    -   기능적 응집력
        -   몇 가지 요소들이 모여서 하나의 일을 해내야 할 때 발생

-   관심사의 분리

    -   시스템이 각각 별개의 문제를 다루는 개별 구성요소로 나뉘어야 함

    

클래스도 동일하게 가독성, 모듈화, 재사용성 및 일반화성, 테스트 용이성 을 고려해야한다.

-   의존성 주입등의 패턴을 활용하여, 관심사를 분리할 수 있는 대상들을 의존성으로 분리하여 가독성, 모듈화, 재사용성 및 일반화성, 테스트 용이성를 높일 수 있음



### 2.3.4 인터페이스

-   계층 사이를뚜렷이 구분하고, 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한가지 접근법

    -   인터페이스를 통해 어떤 함수를 외부로 노출할 것인지를 결정하는 것.

-   하나의 구현이 있지만 인터페이스를 쓸지 말지 고려하는 것은 팀에서 결정해야 함

    -   몇몇 소프트웨어 공학에서는 이 상황에서도 쓰는 것을 권장함
        -   퍼블릭 API를 매우 명확히 보여줌
        -   한가지 구현만 필요하다고 잘못 추측한 것일 수 있음
        -   테스트를 쉽게할 수 있음
        -   같은 클래스로 두 가지 하위 문제를 해결할 수 있음

    -   하지만 단점도 있음
        -   더 많은 작업이 필요함
        -   코드가 복잡해질 수 있음



### 2.3.5 층이 너무 얇아질 때

-   반복적으로 사용하는 코드로 인해 코드 양의 증가가 발생
-   로직의 이해를 위해 파일이나 클래스를 따라 갈 때 더 많은 노력 필요
-   인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는데 더 많은 노력 필요



너무 많은 계층을 남용하는 결과를 가져오더라도 계층을 여러 개로 나누는 것이 한 계층안에 모든 코드를 집어넣는 것보다는 낫다



## 2.4 마이크로서비스는 어떤가?

-   마이크로 서비스를 사용할 때 코드 구조를 만들고 코드에 추상화 계층을 만드는 것이 중요하지 않다는 주장을 들을 수 있다.
    -   하지만 한가지를 위한 일에도 많은 하위 항목이 존재함
    -   이러한 것을 해결하기 위해 올바른 추상화 및 코드 계층을 만드는 것은 여전히 중요함



# 3. 다른 개발자와 코드 계약

## 3.1 자신의 코드와 다른 개발자의 코드

-   자신에게 분명하다고해서 다른 사람에게도 분명한 것은 아니다
-   다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있음
    -   무언가 문제가 생겼을 때 코드 컴파일이 중지되거나 테스트가 실패하도록 만드는 것
-   시간이 지남에 따라 자신의 코드를 기억하지 못함



## 3.2 여러분이 작성한 코드의 사용법을 다른사람들은 어떻게 아는가?

-   이름 확인
-   데이터 유형 확인
-   문서 읽기
-   직접 물어보기
-   코드를 살펴보는 것



위 방법들로 해결하는 방법은 효과적이지 못함. 다른 사람들이 구현 세부 사항을 알아서 분석하기를 기대하는 자세는 좋지 않음



## 3.3 코드 계약

>   계약에 의한 프로그래밍 => 이전 절에서 논의한 것을 공식화하는 방법

-   선결 조건
    -   코드를 호출하기 전 사실이어야 하는 것
-   사후 조건
    -   코드를 호출한 뒤에 사실이어야 하는 것
-   불변 사항
    -   코드가 호출되기 전 후로 변하지 않아야 하는 것



## 3.3.1 계약의 세부 조항

-   계약의 명확한 부분
    -   함수와 클래스 이름
    -   인자 유형
    -   반환 유형
    -   검사 예외
-   세부 조항
    -   주석문과 문서
    -   비검사 예외

세부 조항을 읽지않는 경우가 매우 많으며, 읽더라도 대충 훑어보기 때문에 잘못 이해할 수 있음.



## 3.3.2 세부 조항에 너무 의존하지 말라

-   세부 조항은 사람들이 집중하지 않는 경우가 많음. 이것을 코드의 계약 조건으로 명시하여 해결하는 것이 좋음.

-   올바르게 사용하기 위해 세부조항에 의존하기 보다는 잘못된 일을 아예 못하게 하는 것



## 3.4 체크 및 어서션

컴파일러를 통한 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사(체크 및 어서션)을 사용 가능



### 3.4.1 체크

-   전제 조건 검사
    -   입력 인수가 올바르거나, 초기화가 수행되었거나 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인
-   사후 상태 검사
    -   반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인

체크에서 주의점

-   테스트하기 불분명한 상황에서만 확인 중인 조건이 위반된다면, 코드가 배포되고 사용자가 사용하기 전까지 버그가 노출되지 않을 수 있음
-   체크가 잘 작동해서 실패가 명백함에도 알아차리지 못하는 상황. => 로그들을 신경쓰지 않는 경우..



### 3.4.2 어서션

-   언어 차원에서 지원하는 코드 계약을 준수하기 위한 방법
-   배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외 => 코드가 실 서비스 환경에서 실패를 명백히 보여주지 못할 수 있음



# 4. 오류





## 4.1 복구 가능성

-   소프트웨어에서 특정 오류가 발생한 경우 복구할 수 있는 현실적인 방법이 존재하는지 생각해야 하는 경우가 많음



### 4.1.1 복구 가능한 오류

-   네트워크 오류
-   중요하지 않은 작업 오류

위와 같은 오류들은 시스템을 전체 정지하는 것 보단 적절히 핸들링하는 것이 나음.



### 4.1.2 복구할 수 없는 오류

오류가 발생하고 시스템이 오류를 복구할 수 있는 합리적인 방법이 없을때가 있음

-   코드와 함께 추가되어야 하는 리소스가 없다
-   어떤 코드가 다른 코드를 잘못 사용한다



### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알때가 많다

오류 상황을 처리할때는 다른 코드가 자신이 작성한 코드를 호출하는 것과 관련해 다음과 같은 상황을 고려해야 함

-   오류로부터 복구하기를 호출하는 쪽에서 원하는가?
-   오류를 처리할 필요가 있다는 것을 호출하는 쪽에서 어떻게 알 수 있을까?



### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라

-   호출하는쪽에서 validation 같은 것을 하는 것을 알아야하는 것은 옳지 않음
-   하지만 함수를 호출하는 쪽에서 오류가 발생할 수 있음을 인지할 수 있게 해야 함



## 4.2 견고성 vs 실패

오류가 발생할 때, 다음 중 하나를 선택해야 한다.

-   실패 , 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈춤
-   오류를 처리하고 계속 진행



### 4.2.1 신속하게 실패해라

-   stacktrace를 잘 확인할 수 있도록 빠르게 실패하자.
-   아니면 찾기 힘듦..



### 4.2.2 요란하게 실패해라

-   실패할 때 요란하게 실패하면 그것을 인지하기 쉬워짐



### 4.2.3 복구 가능성의 범위

-   가장 요란하게 실패하는 것은 프로그램이 뻗는 것이지만, 그것보다는 적당한 타협을 해서 모니터링 및 로깅을 강화하는 것이 중요



### 4.2.4 오류를 숨기지 않음

-   전체 소프트웨어의 동작을 멈추지 않도록 하기 위해 코드의 독립적이거나 중요하지 않은 부분을 분리하면 견고한 시스템을 구축할 수 있음
    -   이것은 조심스럽게, 조금씩, 상당히 높은 계층에서 진행되어야 함.
-   낮은 계층에서 오류가 발생함에도 계속 진행하면 의도대로 동작하지 않을 수 있음.
    -   ex) 기본 값 반환, 널 객체 패턴, 아무것도 하지 않음



## 4.3 오류 전달 방법

-   명시적 방법
    -   Checked exception 처럼 코드를 사용하는 곳에서 인지하도록 강제적으로 조치하는 방법
    -   널 값이 가능한 반환 유형
    -   리절트 반환 유형
    -   아웃컴 반환 유형
-   암시적 방법
    -   Unchecked exception을 통해 호출하는 쪽에서 모르게 하는 방법. 이것은 계약 세부 사항이라 인지하라는 보장이 없음
    -   프로미스 또는 퓨처
        -   프로미스가 암묵적인 이유
            -   catch를 사용하지 않으면 무시되기 때문
        -   명시적으로하려면 리절트 유형의 프로미스를 반환하게 해야 함
    -   매직 값 반환



## 4.4 복구할 수 없는 오류의 전달

-   비검사 예외를 발생 시킴
-   프로그램이 패닉이 되도록 함
-   체크나 어서션 사용



## 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달

-   비검사 예외를 사용해야한다는 주장
-   명시적 기법을 사용해야한다는 주장
-   필자는 명시적 기법을 사용해야한다고 하지만, 결국 팀의 의견을 따르는 것이 중요. 각자 다른 방식을 택하게 되면 문제가 발생할 수 있음.



## 4.6 컴파일러 경고를 무시하지 말라

-   컴파일러는 종종 문제가 있을 때 경고를 줌. 그것을 무시하지 말자.



# 5. 가독성 높은 코드를 작성하라



## 5.1 서술형 명칭 사용

-   서술적이지 않은 이름은 코드를 읽기 어렵게 만든다
-   주석문으로 서술적인 이름을 대체할 수 없다

-   결국 해결책은 서술적인 이름 짓기임
    -   변수, 함수를 떼어서 봐도 별도 설명없이 자명함
    -   코드를 따로 떼어보면 더 의미가 있도록 해야 함



## 5.2 주석문의 적절한 사용

-   중복된 주석문은 유해할 수 있다
-   주석문으로 가독성 높은 코드를 대체할 수 없다
-   주석문은 코드의 이유를 설명하는 데 유용하다
-   주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다



## 5.3 코드 줄 수를 고정하지 말아라

-   코드 줄 수가 적으면 일반적으로 좋음
-   하지만 다음과 같은 사항을 확실하게 하는 것이 코드 줄 수를 제한하는 것보다 좋음
    -   이해하기 쉬움
    -   오해하기 어려움
    -   실수로 작동이 안되게 만들기 어려움

-   간결하지만 이해하기 어려운 코드는 피해야 함 ( 비트 연산등으로 복잡한 한 줄 짜리 코드.. )
-   더 많은 줄이 필요하더라도 가독성 높은 코드를 작성



## 5.4 일관된 스타일을 고수하라

-   일관적이지 않은 코딩 스타일은 혼동을 일으킬 수 있음
-   스타일 가이드를 채택하고 따르라
    -   일관적인 스타일을 통해 가독성을 높이고 버그를 예방하는데 도움을 줄 수 있음



## 5.5 깊이 중첩된 코드를 피하라

-   깊이 중첩된 코드는 읽기 어려울 수 있음
-   중첩을 최소화하기 위한 방법을 사용하라
    -   ex) early return 
-   중첩은 너무 많은 일을 한 결과물이다.
    -   더 작은 함수로 분리하라



## 5.6 함수 호출도 가독성이 있어야 한다

-   매개변수는 이해하기 어려울 수 있다
    -   명명된 매개변수를 사용하라
    -   서술적 유형 ( Class, Enum 등으로 int, boolean 대체 )

-   때로는 해결책이 없을 수도 있음



## 5.7 설명되지 않은 값을 사용하지 말라

-   설명되지 않은 값은 혼란스러울 수 있음
    -   잘 명명화된 상수를 사용하라
    -   잘 명명화된 함수를 사용하라



## 5.8 익명 함수를 적절하게 사용하라

-   익명 함수는 간단한 로직에 좋다
-   익명 함수는 가독성이 떨어질 수 있음
    -   대신 명명화된 함수를 사용하라
-   익명 함수가 길면 문제가 될 수 있음
    -   긴 익명함수를 짧은 여러 개의 명명된 함수로 나누어라



## 5.9 프로그래밍 언어의 새로운 기능을 적절히 사용하라

-   새 기능은 코드를 개선할 수 있다
-   불분명한 기능은 혼동을 일으킬 수 있다
-   작업에 가장 적합한 도구를 사용하라