<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

- [4. 오류](#4-)
    * [4.1 복구 가능성](#41--)
        + [4.1.1 복구 가능한 오류](#411---)
        + [4.1.2 복구할 수 없는 오류](#412----)
        + [4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다](#413---------)
        + [4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라](#414--------)
    * [4.2 견고성 vs 실패](#42--vs-)
        + [4.2.1 신속하게 실패하라](#421--)
        + [4.2.2 요란하게 실패하라](#422--)
        + [4.2.3 복구 가능성의 범위](#423---)
        + [4.2.4 오류를 숨기지 않음](#424---)
            - [기본값 반환](#-)
            - [널 객체 패턴](#--)
            - [아무것도 하지 않음](#---1)
    * [4.3 오류 전달 방법](#43---)
        + [4.3.1 요약: 예외](#431--)
        + [4.3.2 명시적 방법 : 검사 예외](#432-----)
        + [4.3.3 암시적 방법 : 비검사 예외](#433-----)
        + [4.3.4 명시적 방법 : 널 값이 가능한 반환 유형](#434--------)
        + [4.3.5 명시적 방법 : 리절트 반환 유형](#435------)
        + [4.3.6 명시적 방법 : 아웃컴 반환 유형](#436------)
        + [4.3.7 암시적 방법 : 프로미스 또는 퓨처](#437------)
        + [4.3.8 암시적 방법 : 매직값 반환](#438-----)
    * [4.4 복구할 수 없는 오류의 전달](#44-----)
    * [4.5 호출하는 쪽에서 복구하기를 원할수도 있는 오류의 전달](#45-------)
        + [4.5.1 비검사 예외를 사용해야 한다는 주장](#451-----)
            - [코드 구조 개선](#---2)
            - [개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함](#------)
        + [4.5.2 명시적 기법을 사용해야 한다는 주장](#452-----)
            - [매끄러운 오류 처리](#---3)
            - [실수로 오류를 무시할 수 없다](#----)
            - [개발자가 무엇을 할 것인지에 대해서 실용적이어야 함](#-------1)
        + [4.5.3 필자의 의견: 명시적 방식을 사용하라](#453-----)
    * [4.6 컴파일러 경고를 무시하지 말라](#46----)

<!-- TOC end -->

# 4. 오류

- 오류는 불가피하다
- 오류 사례를 신중하게 생각하지 않고는 견고하고 신뢰성 높은 코드를 작성할 수 없다.


- 오류를 다음과 같이 구분하면 유용하다
    - 작동을 계속할 수 있는 오류
    - 작동을 계속할 합리적인 방법이 없는 오류


- 오류를 어떻게 전달하고 처리해야 하는지는 많은 소프트웨어 엔지니어와 프로그래밍 언어 설계자들의 의견이 갈린다

## 4.1 복구 가능성

### 4.1.1 복구 가능한 오류

- 많은 소프트웨어 오류는 치명적이지 않다.
- 또한 오류가 발생하더라도 사용자는 알아채지 못하도록 적절하게 처리한다면 작동을 계속할 수 있는 합리적인 방법이 있따.


- 잘못된 사용자 입력이 대표적인 예시이며 그 외에 아래와 같은 것들이 있다
    - 네트워크 오류
    - 즁요하지 않은 작업의 오류


- 일반적으로 시스템 외부에 의해 야기되는 오류는 적절하게 처리하기 위해 노력해야 한다.
    - 이러한 오류는 일어날 것이라고 적극적으로 예상해야 하는 오류이기 때문이다.


- 낮은 층위의 코드에서 오류를 복구하려고 하는 것은 장점이 별로 없다
- 오류 처리 방법을 알고 있는 더 높은 층위의 코드로 오류를 전송해야 하는 것이 더 좋을 때가 많다.

### 4.1.2 복구할 수 없는 오류

- 오류가 발생했지만 시스템이 오류를 복구할 수 있는 합리적인 방법이 없을 때가 있다
- 이러한 현상은 프로그래밍 오류 때문에 발생할 때가 많다
    - 한 코드가 다른 코드를 잘못 사용하는 경우
    - 코드와 함께 추가되어야 하는 리소스가 없는 경우


- 오류를 복구할 수 없다면, 유일하게 코드가 할 수 있는 것은 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화하는 것이다
    - 신속한 실패(failing fast) 또는 요란한 실패(failing loudly)와 관련있다

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다

- 대부분의 오류는 한 코드가 다른 코드를 호출할 때 발생한다.
- 따라서 오류 상황을 처리할 때 다음을 고려해야 한다.
    - 오류로부터 복구하기를 호출하는 쪽에서 원하는가?
    - 만약 그렇다면 오류를 처리할 필요가 있다는 것을 호출하는 쪽에서는 어떻게 알 수 있을까?


- **간결한 추상화 계층**을 만들고자 한다면 일반적으로 코드의 잠재적 호출자에 대한 가정을 가능한 한 하지 않는 것이 좋다.
- 함수를 작성하거나 수정하는 시점에 오류로부터 복구할 수 있는지, 혹은 복구해야 하는지를 항상 알 수 있는 것이 아니기 때문이다.


- 이 함수가 어떻게 사용되며, 어디서 호출되는지 알지 못한다면 오류를 복구할 수 있는지 알 수 없다.


- 어떤 함수가 유효하지 않은 입력에 대해서 복구할 수 있는지 여부는 함수를 호출하는 코드만이 알 수 있다.
- 따라서 복구가 아예 불가능하지 않다면 함수의 호출자는 오류를 복구하기 원한다고 가정해야 한다.


- 일반적으로 다음 중 하나라도 해당되면 인자에 의해 발생하는 오류는 호출하는 쪽에서 복구하고자 하는 것으로 간주해야 한다.
    - 함수가 어디서 호출될지, 호출 시 제공되는 값이 어디서 올지 정확한(완전한) 지식이 없다
    - 코드가 미래에 재사용될 가능성이 아주 희박하다
        - 이는 코드 호출에 대한 가정이 의미가 없어질 수 있음을 의미한다.


- 이에 대한 유일한 예외는 특정 입력이 무효라는 점이 코드 계약을 통해 명확하고, 호출자가 호출 전에 입력을 검증하는 쉽고 분명한 방법을 가지고 있는 경우다.


- 자신의 코드가 어떻게 사용되어야 하는지가 스스로에겐 명백해보일 수 있지만 다른 사람들에게는 그렇지 않을 수도 있다는 점을 항상 명심해야 한다.

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라

- 호출 시 오류가 발생할 수 있다는 사실을 사전에 알 수 있는 실질적인 방법이 없는 경우가 많다


- 호출자는 하위 문제에 대한 전문 지식이 없기 때문에 오류가 발생할 수 있다는 생각조차 못할 수도 있고, 알고 있더라도 이 시점에서 오류가 발생할 것이라 예상하지 못할 수도 있따.


- 따라서 호출자가 이 함수는 오류가 발생할 수 있다는 것을 확실하게 인지하도록 해야 한다.

## 4.2 견고성 vs 실패

- 오류가 발생할 때 다음 중 하나를 선택해야 한다
    - 실패
        - 더 높은 계층이 오류를 처리하거나 시스템을 중단한다
    - 오류를 처리하고 계속 진행한다


- 오류가 있더라도 처리하고 계속 진행한다면 견고하다고 볼 수도 있지만 오히려 오류가 감지되지 않고 이상한 일이 발생하기 시작한다는 것일 수도 있다

### 4.2.1 신속하게 실패하라

- 신속하게 실패하기(failing fast)는 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것이다.


- 복구할 수 있는 오류는 호출자가 오류로부터 안전하게 복구할 수 있는 기회를 최대한으로 제공해야 한다.
- 복구할 수 없는 오류의 경우 개발자가 문제를 빠르게 파악하고 해결할 수 있는 기회를 최대한 갖도록 하는 것이다.


- 문제가 발생하자 마자 실패나 오류를 보여주지 않으면 문제가 발생할 때 디버그하기 어려울 뿐만 아니라 코드가 제대로 작동하지 않아 잠재적인 문제를 일으킬 수 있다

### 4.2.2 요란하게 실패하라

- 버그의 존재를 모르면 고칠 수 있는 방법이 없다.


- 요란한 실패(failing loudly)는 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다


- 가장 명백한 방법은 예외를 발생해 프로그램을 중단시키는 것이다.
- 또 다른 방법은 오류 메시지를 기록하는 것이다.
    - 이는 개발자가 얼마나 부지런하게 로그를 확인하는 지에 달려있다.
    - 또한 로그에 방해되는 메시지가 얼마나 있는지에 달려있다.


- 코드가 빠르고 요란하게 실패하면 개발 도중, 테스트 도중에 버그가 발견될 가능성이 크다

### 4.2.3 복구 가능성의 범위

- 복구할 수 있는 또는 복구할 수 없는 범위는 달라질 수 있다.
- 서버가 사용자의 요청을 처리하는 경우 오류는 해당 요청 범위 내에서 복구할 수 없지만 서버 전체적으로는 복구할 수 있다.


- 일반적으론 소프트웨어를 견고하게 작성하는 것이 좋다.
- 하지만 오류를 알아차리지 못한 채 시스템이 동작하면 안되기 때문에 요란하게 실패해야 한다.


- 가장 요란하게 실패하는 것은 프로그램이 중단되는 것이지만 이는 소프트웨어를 견고하지 않게 만든다.


- 그에 대한 대안은 프로그래밍 오류를 기록하고 모니터링하는 것이다
    - 상세 오류 정보를 기록해 디버깅할 수 있또록 한다
    - 오류 발생률이 높아지면 개발자에게 알림 메시지를 보낸다


- 더 높은 계층으로 신호를 보내는 대신 모든 유형의 오류를 기록하는 것은 극도로 주의해야 한다
- 프로그램에는 오류를 기록하기에 적당한 장소가 있다


- 오류를 전달하지 않고 기록만 하면 오류가 숨겨져 문제가 발생할 수 있다.

### 4.2.4 오류를 숨기지 않음

- 전체 소프트웨어의 동작을 멈추지 않기 위해서 코드의 독립적이거나 중요하지 않은 부분을 분리하면 견고한 시스템을 구축할 수 있다.
    - 이 과정은 조심스럽게, 조금씩, 상당히 높은 계층에서 이루어져야 한다.
    - 독립적이지 않거나 중요하거나 낮은 계층에서 오류가 발생했는데도 불구하고 계속 진행하면 소프트웨어가 의도하지 않은 대로 동작할 수도 있다.


- 오류를 숨기면 훨씬 더 단순해지고 번거로운 오류 처리를 피할 수 있다.
- 하지만 오류를 숨기는 것은 복구할 수 있는 오류, 복구 불가능한 오류 모두에 문제를 일으킨다.
    - 복구할 수 있는 오류를 숨기면 복구할 수 있는 기회를 없애는 것이다
        - 또한 잘못된 일이 일어났음을 전혀 인지하지 못한다
    - 복구할 수 없는 오류를 숨기면 개발팀이 오류를 발견하지 못할 수도 있다
    - 오류가 발생하지 않으면 호출자는 정상적으로 동작했다고 가정한다.
        - 하지만 실제 코드는 제대로 동작하지 않았기에 문제가 발생할 수 있다.


- 오류를 숨기는 여러 가지 기술이 있다.
- 이 중 일부는 특정 상황에서 유용한 경우도 있지만 오류 처리에 있어서는 일반적으로 모두 바람직하지 않다.

#### 기본값 반환

- 오류가 발생해 원하는 값을 반환할 수 없는 경우 기본값을 반환할 수 있다.
    - 이는 간단하고 쉬운 해결책으로 보인다.


- 하지만 기본값의 문제점은 오류가 발생한다는 사실을 계속 숨긴다는 것이다.
    - 모든 것이 정상으로 보인다.


- 또한 실제 값이 기본값인 경우와 구분할 수 없다.


- 코드에 기본값을 두는 것이 유용할 때도 있지만 오류 처리에 있어서는 대부분 부적합하다.

#### 널 객체 패턴

- 널 객체는 기본값과 유사하지만 더 복잡한 객체를 다룬다.
- 이러한 객체는 실제 반환값처럼 보이지만 아무것도 하지 않거나 의미 없는 기본값을 반환한다.


- 널 객체 패턴의 대표적인 예는 빈 리스트다.
- 이 경우에도 오류가 발생했을 때 빈 리스트를 반환하면 버그가 생기기 쉽다.


- 널 객체 패턴은 유용한 경우가 종종 있지만 오류 처리에 사용하는 것은 바람직하지 않다.

#### 아무것도 하지 않음

- 또 다른 방법은 오류가 발생했다는 신호를 보내지 않는 것이다.
- 호출자는 의도한대로 동작했다고 가정하기에 바람직하지 않다.
- 호출자가 갖고 있는 정신 모델과 코드의 실제 수행이 다르면 버그가 생길 수 있다.


- 또 다른 문제는 오류를 적극적으로억제하는 코드다.


- 오류를 기록하면 조금은 낫지만 여전히 바람직하지 않다.
- 호출하는 쪽에 오류를 숨기고 있어서 문제가 생길 수 있다.

## 4.3 오류 전달 방법

- 오류가 발생하면 일반적으로 더 높은 계층으로 오류를 알려야 한다.
- 복구할 수 없는 오류
    - 더 높은 계층에서 실행을 중지하고, 오류를 기록하거나 프로그램 전체를 종료
- 복구가 가능한 오류
    - 즉시 호출하는 쪽에 오류를 알려 정상적으로 처리할 수 있도록 한다.


- 명시적 방법
    - 호출자가 오류가 발생할 수 있음을 인지할 수밖에 없도록 한다.
    - 어떻게 처리할지는 호출자에게 달려있다.
    - 어떤 선택을 하든 적극적인 선택의 결과다.
    - 오류 발생 가능성이 코드 계약의 명확한 부분에 나와있다.
- 암시적 방법
    - 호출자에게 오류를 알리지만 호출자는 오류를 신경쓰지 않아도 된다.
    - 오류 발생 가능성을 알기 위해서는 문서나 코드를 읽는 등의 적극적인 노력이 필요하다.
    - 문서에 오류가 나와있으면 이는 코드 계약의 세부 조항이다.
    - 문서에 없을 수도 있다.


- 명시적, 암시적은 오류가 요란하기 실패할지, 조용하게 실패할지에 대한 이야기가 아니다
- 호출자가 알아야 할 경우를 인지하게끔 하거나 할 수 있는 것이 없는 상황에서 이런 상황을 처리해야 하는 부담에서 벗어나도록 하는 것이다.

### 4.3.1 요약: 예외

- 많은 프로그래밍 언어는 예외라는 개념을 가지고 있다.
- 오류나 예외적인 상황을 전달하기 위한 방법으로 고안되었다.


- 예외는 일반적으로 충분한 기능을 가진 클래스로 구현된다.
- 개발자는 자신만의 맞춤형 예외를 만들 수 있다.


- 자바는 검사 예외(checked exeception)과 비검사 예외(unchecked exception) 모두 지원한다.
- 대부분의 언어는 비검사 예외만 가지고 있다.

### 4.3.2 명시적 방법 : 검사 예외

- 컴파일러는 검사 예외에 대해 호출하는 쪽에서 예외를 인지하도록 강제적으로 조치한다.
- 따라서 호출자는 예외 처리를 하는 코드를 작성하거나 예외 발생을 선언해야 한다.
- 따라서 명시적인 방법이다.

### 4.3.3 암시적 방법 : 비검사 예외

- 비검사 예외를 사용하면 다른 개발자가 코드가 이 예외를 발생시킬 수 있다는 사실을 전혀 모를 수 있다.
- 이 경우 이에 대해 문서화를 하는 것이 바람직하지만 문서화를 까먹을 수도 있다.
- 또한 문서는 코드 계약의 세부 조항이다.
    - 세부 조항은 신뢰할만한 망법이 아닐 때가 많다.
- 즉, 암시적으로 알리는 방법이다.

### 4.3.4 명시적 방법 : 널 값이 가능한 반환 유형

- 특정값을 계산하거나 얻는 것이 불가능할 때 널값을 반환하는 것은 효과적이고 간단하다.
- 만약 언어가 널 안정성을 지원하는 경우 호출자는 강제적으로 이를 인지하고 처리할 수밖에 없다.
    - 정확히는 사실은 아니다.
    - 널이 아닌 값으로 타입 변환을 할 수 있으며 이 또한 적극적인 결정이다.
- 따라서 명시적인 방법이다.


- 널 안정성을 지원하지 않는 언어는 옵셔널과 같은 반환 유형을 사용하는 것이 좋다.

### 4.3.5 명시적 방법 : 리절트 반환 유형

- 널값이나 옵셔널 타입의 문제는 오류 정보를 전달할 수 없다는 것이다.
- 이러한 경우 리절트(result) 유형을 사용하면 좋다.


- 언어 중에서 이러한 유형을 지원하는 경우도 있고 직접 만들어야 하는 경우도 있다.
    - 후자의 경우 사용하는 것이 조금 번거로울 수도 있다.


- 언어 자체에서 지원하지 않는다면 이것이 제대로 사용될지 여부는 다른 개발자가 이 유형에 얼마나 익숙한지에 달려있다.


- 만약 언어가 지원하거나 개발자들이 리절트 타입에 익숙하다면 이는 오류가 발생할 수 있다는 점을 분명히 하는 것이므로 명시적인 방법이다.

### 4.3.6 명시적 방법 : 아웃컴 반환 유형

- 어떤 함수는 값을 반환하지 않고 어떤 동작을 수행한다.
- 해당 동작을 수행하는 동안 오류가 발생할 수 있으므로 이를 알리기 위해 어떤 값을 반환해야 할 수도 있다.
- 만약 아웃컴 반환 유형을 반환할 때 호출자가 강제적으로 반환값을 확인해야 한다면 이는 오류를 알리는 명백한 방법이다.


- 간단한 경우이 불리언 변수를 사용할 수 있지만 상황이 더 복잡하면 더 정교한 아웃컴 유형을 사용하는 것이 더 적절할 수도 있다.
    - 클래스 혹은 열거형


- 아웃컴 반환 유형의 문제점 중 하나는 호출자가 반환값을 무시하거나 반환값이 존재한다는 사실 조차 모를 수 있다는 점이다.
- 따라서 아웃컴 반환 유형은 오류를 알리는 명시적 방법으로는 한계가 있다.
- 이를 보완하기 위해 일부 언어는 함수의 반환값을 무시하면 컴파일러가 경고를 생성하도록 표시할 수 있다.

### 4.3.7 암시적 방법 : 프로미스 또는 퓨처

- 비동기적으로 실행하는 코드를 작성할 때 프로미스(promise)나 퓨처(future)를 반환하는 함수를 작성하는 것이 일반적이다.
- 많은 언어에서 프로미스나 퓨처에서 오류 상태도 전달할 수 있다.


- 하지만 프로미스나 퓨처를 사용할 떄 오류 처리를 강제로 해야 하는 것은 아니다.
- 해당 함수에 대해 잘 알지 못하면 오류 처리 코드를 추가로 작성해야 한다는 사실조차도 모를 수도 있다.
- 따라서 암시적인 방법에 해당한다.


- `catch()` 함수로 예외 처리하지 않으면 오류가 무시되거나 상위 수준의 오류 처리 코드에 의해 포착될 것이다.
    - 언어나 설정에 따라 다르다.


- 즉, 프로미스나 퓨처는 비동기 함수로부터 값을 반환하는 좋은 타입이지만 호출자는 잠재적인 오류 시나리오를 완전히 알 수 없기 때문에 암시적이다.
- 이에 대한 대안으로 리절트 유형의 프로미스를 반환하는 것도 가능하지만 꽤나 코드가 복잡해진다.

### 4.3.8 암시적 방법 : 매직값 반환

- 매직값은 함수의 정상적인 반환 유형에 해당하지만 특별한 의미를 가지는 값이다.
- 매직값이 반환될 수 있다는 사실을 알기 위해서는 문자나 코드를 읽어야 한다.
- 따라서 이는 암시적이다.


- 매직값은 오류를 알리는 좋은 방법이 아니다.

## 4.4 복구할 수 없는 오류의 전달

- 복구할 가능성이 없는 오류가 발생하면 신속하게, 요란하게 실패하는 것이 최선이다.
- 이를 달성할 수 있는 여러 가지 방법이 있다.
    - 비검사 예외를 발생
    - 프로그램이 패닉(panic)이 되도록
    - 체크나 어서션 사요


- 암시적인 기술을 사용하면 오류 시나리오를 확인하거나 처리하기 위한 코드를 호출 체인의 모든 상위 호출자가 다 작성할 필요가 없다
- 복구할 수 없는 오류의 경우 이는 합리적이다
    - 전달밖에 할 수 있는 것이 없기 때문이다.

## 4.5 호출하는 쪽에서 복구하기를 원할수도 있는 오류의 전달

- 복구하기를 원할 수도 있는 오류를 전달할 때 일치된 의견이 없다
- 비검사 예외와 명시적 오류 전달 기법 간에 많은 논쟁이 있고 두 측면 모두 타당한 주장과 반론이 있다.


- 다만 팀이 정의한 컨벤션 혹은 철학이 가장 중요하다.

### 4.5.1 비검사 예외를 사용해야 한다는 주장

#### 코드 구조 개선

- 대부분의 오류 처리는 상위 계층에서 이루어진다.
- 따라서 비검사 예외를 사용하면 중간 계층은 오류 처리를 할 필요가 없으므로 코드 구조를 개선할 수 있다.
- 중간 계층은 원한다면 예외 중 일부를 처리할 수도 있다.


- 이 방법의 장점은 오류를 처리하는 로직이 코드 전체에 퍼지지 않고 별도로 몇 개의 계층에만 있다는 점이다.

#### 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함

- 일부 개발자들은 너무 많은 명시적 오류 전달을 접하면 결국 개발자가 잘못된 일을 하기 쉬워진다는 주장이다.
    - 예외를 포착해도 무시하거나 널이 가능한 유형을 확인하지 않고 널이 불가능한 유형으로 타입 변환을 한다거나 등등


- 또한 하위 함수가 예외를 던지게 되면 위에 존재하는 수 많은 상위 계층의 코드까지 수정해야 할 수도 있다.
    - 이는 작업의 양이 너무 많으므로 오류를 숨겨버릴 수도 있다.


- 즉, 번거로운 작업 대신 개발자는 편의를 도모하고 잘못된 작업을 하고 싶은 마음이 들 수도 있다.
- 결국 핵심은 이 문제에 대해서 실용적으로 접근해야 한다는 것이다.

### 4.5.2 명시적 기법을 사용해야 한다는 주장

#### 매끄러운 오류 처리

- 비검사 예외를 사용하면 모든 오류를 매끄럽게 처리할 수 있는 단일 계층을 갖기가 어렵다


- 호출하는 쪽에 잠재적 오류를 강제적으로 인식하면 이러한 오류를 더 매끄럽게 처리할 가능성이 커진다.
- 암시적인 방식을 사용하면 개발자는 오류가 발생할 수 있다는 것도 모르는데 어떻게 이를 잘 처리할 수 있을까?

#### 실수로 오류를 무시할 수 없다

- 실제로 오류를 처리해야 하는 경우도 더러 존재한다.
    - 명시적인 오류 전달 방식을 사용해도 여전히 개발자는 바람직하지 않게 처리할 수도 있다.
        - 하지만 이는 적극적인 노력이자 선택이고 눈에 띈다.
        - 따라서 이러한 잘못을 사전에 차단할 가능성이 높아진다.
        - 즉, 기본적으로 혹은 실수로 그런 일이 발생하지 않는다.
    - 하지만 비검사 예외를 사용하면 적극적인 의사 결정이 들어갈 여지는 줄어들고 대신 기본적으로 잘못된 일이 일어나기 쉽다.
        - 특정 오류가 발생할 수 있다는 사실을 완전히 알지 못하기 때문이다.

#### 개발자가 무엇을 할 것인지에 대해서 실용적이어야 함

- 개발자가 오류 처리를 너무 많이 해야해서 잘못된 선택을 한다는 주장은 비검사 예외를 반박하는 데도 적용될 수 있다.


- 비검사 예외는 문서화가 제대로 된다는 보장이 없으며 되지 않는 경우가 더 많다.
- 즉, 어떤 코드가 어떤 예외를 발생시킬 수 있는지 확실하게 알 수 없다는 것을 의미한다.
- 따라서 알지 못하는 예외가 던져지는 상황이 여러 번 발생하면 코드를 뒤지면서 예외를 찾는 것에 지쳐 모든 종류를 다 잡아버리는 결정을 할 수도 있다.
    - 이는 바람직하지 않다.


- 즉, 어떤 방법을 사용해도 개발자는 잘못된 방법을 택할 수도 있다.
    - 비검사 예외를 사용하든 명시적 방법을 사용하든 문제가 있을 수 있다.
    - 진짜 문제는 개발자들이 일을 허술하게 하고 이를 걸러낼 강력한 방법이 없다는 것이다.

### 4.5.3 필자의 의견: 명시적 방식을 사용하라

- 필자 : 복구하기를 원할 수도 있는 오류에 대해 비검사 예외를 사용하지 않는 것이 좋다
    - 비검사 예외는 완전히 문서화되는 경우가 드물다
    - 명시적 방법에 여러 단점이 존재하긴 하지만 비검사 예외로 인한 버그가 더 치명적이다
    - 따라서 개인적으로 명시적인 방법을 선호한다.

## 4.6 컴파일러 경고를 무시하지 말라

- 코드가 잘못되거나 오용되었을 때 컴파일러 오류가 일어나도록 하는 여러 기술을 살펴봤다.
- 또한 컴파일러는 경고 메시지도 출력하는데 이러한 경고에 귀를 기울이면 조기에 오류를 제거할 수 있다.


- 컴파일러 경고를 오류로 여기고 컴파일을 막는 설정은 너무 엄격해보일 수 있지만 실제로는 그에 따라 행동하도록 강제하기 때문에 매우 유용하다.


- 경고는 종종 코드에 문제가 있다는 신호 혹은 심각한 버그를 나타내므로 잘 조치하는 것이 좋다.
