<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

- [5. 가독성 높은 코드를 작성하라](#5----)
    * [5.1 서술형 명칭 사용](#51---)
        + [5.1.1 서술적이지 않은 이름은 코드를 읽기 어렵게 만든다](#511-------)
        + [5.1.2 주석문으로 서술적인 이름을 대체할 수 없다](#512------)
        + [5.1.3 해결책: 서술적인 이름 짓기](#513----)
    * [5.2 주석문의 적절한 사용](#52---)
        + [5.2.1 중복된 주석은 유해할 수 있다](#521-----)
        + [5.2.2 주석문으로 가독성 높은 코드를 대체할 수 없다](#522-------)
        + [5.2.3 주석문은 코드의 이유를 설명하는 데 유용하다](#523------)
        + [5.2.4 주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다](#524---------)
    * [5.3 코드 줄 수를 고정하지 말라](#53-----)
        + [5.3.1 간결하지만 이해하기 어려운 코드는 피해라](#531-----)
        + [5.3.2 해결책: 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라](#532---------)
    * [5.4 일관된 코딩 스타일을 고수하라](#54----)
        + [5.4.1 일관적이지 않은 코딩 스타일은 혼동을 일으킬 수 있다](#541--------)
        + [5.4.2 해결책 : 스타일 가이드를 채택하고 따르라](#542------)
    * [5.5. 깊이 중첩된 코드를 피하라](#55----)
        + [5.5.1 깊이 중첩된 코드는 읽기 어려울 수 있다](#551-------)
        + [5.5.2 해결책 : 중첩을 최소화하기 위한 구조로 변경](#552-------)
        + [5.5.3 중첩은 너무 많은 일을 한 결과물이다](#553------)
        + [5.5.4 해결책 : 더 작은 함수로 분리](#554------)
    * [5.6 함수 호출도 가독성이 있어야 한다](#56-----)
        + [5.6.1 매개변수는 이해하기 어려울 수 있다](#561-----)
        + [5.6.2 해결책: 명명된 매개변수 사용](#562----)
        + [5.6.3 해결책: 서술적 유형 사용](#563----)
        + [5.6.4 때로는 훌룡한 해결책이 없다](#564----)
        + [5.6.5 IDE는 어떤가?](#565-ide-)
    * [5.7 설명되지 않은 것을 사용하지 말라](#57-----)
        + [5.7.1 설명되지 않은 값은 혼란스러울 수 있다](#571------)
        + [5.7.2 해결책 : 잘 명명된 상수를 사용하라](#572------)
        + [5.7.3 해결책 : 잘 명명된 함수를 사용하라](#573------)
            - [공급자 함수](#-)
            - [헬퍼 함수](#--1)
    * [5.8 익명 함수를 적절하게 사용하라](#58----)
        + [5.8.1 익명 함수는 간단한 로직에 좋다](#581-----)
        + [5.8.2 익명 함수는 가독성이 떨어질 수 있다](#582------)
        + [5.8.3 해결책 : 대신 명명 함수를 사용하라](#583------)
        + [5.8.4 익명 함수가 길면 문제가 될 수 있다](#584-------)
        + [5.8.5 해결책 : 긴 익명 함수를 여러 개의 명명 함수로 나누라](#585----------)
    * [5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라](#59------)
        + [5.9.1 새로운 기능은 코드를 개선할 수 있다](#591------)
        + [5.9.2 불분명한 기능은 혼동을 일으킬 수 있다](#592------)
        + [5.9.3 작업에 가장 적합한 도구를 사용하라](#593-----)

<!-- TOC end -->

# 5. 가독성 높은 코드를 작성하라

- 가독성은 본질적으로 주관적인 것이다.
- 따라서 가독성이 정확히 무엇을 의미하는지 확실하게 정의하기 어렵다.


- 가독성의 핵심은 개발자가 코드의 기능을 보고 빠르고 정확하게 이해할 수 있는 것이다
- 즉, 다른 사람 관점에서 코드가 혼란스럽거나 잘못 해석될 여지가 없는지 상상하고 공감해야 할 때가 많다.

## 5.1 서술형 명칭 사용

- 적절히 이름을 붙임으로써 그것이 스스로 설명되도록 만들 수 있다.
- 이를 잘 이용하면 읽기 쉬운 코드를 작성할 수 있다.

### 5.1.1 서술적이지 않은 이름은 코드를 읽기 어렵게 만든다

### 5.1.2 주석문으로 서술적인 이름을 대체할 수 없다

- 코드가 읽기 어렵다면 주석문이나 문서를 추가할 수 있다
- 하지만 다음과 같은 단점을 가진다.
    - 코드가 더 복잡해진다.
    - 주석문과 문서의 유지 보수가 필요하다.
    - 코드를 읽을 때 주석을 찾기 위해 스크롤해야 한다.
    - 다른 파일에 존재하면 여러 파일을 왔다갔다 해야한다.


- 주석문이 코드 사용 방법을 이해하는데 도움을 줄 수 있다.
- 하지만 서술적인 이름을 붙이는 대신 주석문을 사용해서는 안 된다.

### 5.1.3 해결책: 서술적인 이름 짓기

- 서술적인 이름을 사용하면 별도로 코드를 설명할 필요가 없어진다.
- 즉, 주석문을 사용한 것보다 덜 지저분하며 주석문을 관리할 필요도 사라진다.

## 5.2 주석문의 적절한 사용

- 주석문이나 문서는 다음과 같은 목적을 수행할 수 있다.
    - 코드가 무엇을 하는지 설명
    - 코드가 왜 그 일을 하는지 설명
    - 사용 지침 등 기타 정보 제공


- 하위 수준의 경우 주석문은 가독성을 높이기 위한 효과적인 방법이 아니다.
    - 서술적인 이름으로 잘 작성된 코드는 그 자체로 자신이 무엇을 하는지 설명한다.
    - 만약 하위 수준의 주석문이 많다면 코드 자체의 가독성이 떨어진다는 신호다.
- 클래스와 같이 큰 단위의 경우 높은 수준에서의 주석문은 유용하다.


- 하지만 코드가 왜 그 일을 하는지 이유나 배경을 설명하는 주석문은 유용하다.
- 코드만으론 이를 명확히 알 수 없기 때문이다.

### 5.2.1 중복된 주석은 유해할 수 있다

- 코드 자체로 설명이 되는 코드에 주석을 다는건 추가적인 정보는 없이 코드를 지저분하게 만들고 유지 보수 작업만 늘린다.

### 5.2.2 주석문으로 가독성 높은 코드를 대체할 수 없다

- 코드 자체가 설명이 되도록 작성하면 주석문을 사용하는 것보다 더 좋다.
    - 잘 명명된 헬퍼 함수를 사용하자.

### 5.2.3 주석문은 코드의 이유를 설명하는 데 유용하다

- 코드가 그 일을 왜 수행하는지는 코드 자체로 설명하기 어렵다.
- 특정 코드를 이해하거나 작업할 때 안전하게 수정하기 위해서 배경 상황이나 지식이 필요하다면 주석문은 매우 유용하다.


- 즉, 코드만으로 그렇게 하는 이유가 분명하지 않을 때 주석문을 사용하여 설명한다.
- 이는 코드를 약간 지저분하게 만들지만 얻는 이점이 더 크다.

### 5.2.4 주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다

- 상위 수준에 대한 간략한 문서는 빠르게 내용을 파악할 수 있어서 도움이 된다.


- 예를 들면 다음과 같다.
    - 클래스가 수행하는 작업 혹은 다른 개발자가 알고 있어야 할 중요한 세부 사항을 개괄적으로 설명
    - 함수의 입력 매개변수 혹은 기능에 대한 설명
    - 함수의 반환값의 의미에 대한 설명


- 문서도 중요하지만 대부분 개발자는 문서를 읽지 않는다는 사실에 현실적으로 대처해야 한다.
- 즉, 문서나 주석문에 너무 많이 의존하지 않는 것이 바람직하다.

## 5.3 코드 줄 수를 고정하지 말라

- 일반적으로 코드 줄 수는 적을수록 좋다.
- 코드가 너무 길면 코드가 지나치게 복잡하거나 기존 코드를 재사용하지 않는다는 신호일 수도 있다.
- 또한 읽어야 하는 코드 양이 증가하므로 인지 부하가 증가할 수 있다.


- 코드 줄 수는 유용한 지침이긴 하지만 반드시 지켜야 할 엄격한 규칙은 아니다.
- 우리가 정말 신경써야 할 것들은 다음이다.
    - 이해하기 쉽다.
    - 오해하기 어렵다.
    - 실수로 작동이 안 되게 만들기 어렵다.

### 5.3.1 간결하지만 이해하기 어려운 코드는 피해라

- 코드가 간결하지만 많은 가정과 복잡성을 지니고 있는 경우 다음과 같은 문제가 있다.
    - 다른 개발자는 간결한 코드에서 모든 세부 사항과 가정을 도출하기 위해 많은 시간을 들여야 한다.
        - 이 과정에서 오해하거나 실수할 가능성도 높아진다.
    - 이런 가정은 다른 코드에서의 가정과 일치해야 한다.
        - 차라리 가정을 하위 문제로 만들어 SSOT로 재사용하는 것이 더 좋다.

### 5.3.2 해결책: 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라

- 코드의 줄 수가 늘어나더라도 가정과 세부 사항이 누구에게나 더 명백해진다면 그렇게 하는 것이 좋다.

## 5.4 일관된 코딩 스타일을 고수하라

### 5.4.1 일관적이지 않은 코딩 스타일은 혼동을 일으킬 수 있다

- 일관되지 않은 코딩 스타일은 코드에 오해를 불러일으킬 수 있다.
    - 코드를 읽을 때 코딩 스타일에 종종 의존한다.

### 5.4.2 해결책 : 스타일 가이드를 채택하고 따르라

- 일관된 코딩 스타일을 따라 코드를 작성하면 가독성이 좋아지고 버그를 예방하는데 도움이 된다.
- 서로 오해할 위험이 줄어들고, 버그가 줄어들고, 혼란스러운 코드를 이해하는데 낭비되는 시간이 줄어든다.

## 5.5. 깊이 중첩된 코드를 피하라

### 5.5.1 깊이 중첩된 코드는 읽기 어려울 수 있다

- 중첩이 깊어지면 가독성이 떨어지므로 중첩을 최소화하도록 코드를 작성하는 것이 좋다.

### 5.5.2 해결책 : 중첩을 최소화하기 위한 구조로 변경

- 중첩된 모든 블럭에 반환문이 있다면 중첩을 해제하는 것이 쉽다.
- 그렇지 않다면 대게 함수가 너무 많은 일을 하고 있다는 신호다.

### 5.5.3 중첩은 너무 많은 일을 한 결과물이다

- 함수가 너무 많은 일을 하고 있다면 더 작은 함수로 나누어 중첩을 최소화할 수 있다.

### 5.5.4 해결책 : 더 작은 함수로 분리

- 하나의 함수가 너무 많은 일을 하면 추상화 계층이 나빠진다.
- 함수가 너무 많은 일을 하고 있다면 더 작은 함수로 나누어 중첩을 최소화할 수 있다.

## 5.6 함수 호출도 가독성이 있어야 한다

- 함수의 이름이 잘 지어졌더라도 함수의 인수가 무엇을 위한 것이고, 무슨 역할을 하는지 명확하지 않다면 함수 호출 자체가 이해되지 않을 수 있다.


- 인수가 많아지면 이해하기 어려워진다.
- 만약 인수가 너무 많다면 추상화 계층을 적절하게 정의하지 않았거나 코드가 충분히 모듈화되지 않은 것일 수도 있다.

### 5.6.1 매개변수는 이해하기 어려울 수 있다

- 인수가 명확하지 않으면 함수 호출 코드를 볼 때마다 들어가서 확인해봐야 한다.
- 즉, 코드가 무슨 일을 하는지 알기 위해서 다른 파일이나 많은 코드를 읽어봐야 한다면 그 코드는 가독성이 떨어지는 것이다.

### 5.6.2 해결책: 명명된 매개변수 사용

- 명명된 매개변수는 위치가 아니라 이름으로 매개변수를 찾는다.
- 이는 함수 정의를 확인하지 않고도 함수에 대한 호출을 쉽게 이해할 수 있게 해준다.


- 언어에서 지원하지 않더라도 객체 구조 분호와 같은 기능을 활용하면 이를 흉내낼 수 있다.

### 5.6.3 해결책: 서술적 유형 사용

- 명명된 매개변수 지원 여부와 상관 없이 더 서술적인 유형을 사용하면 도움이 된다.
    - 열거형
    - 클래스

### 5.6.4 때로는 훌룡한 해결책이 없다

- 떄로는 적절한 방법이 없을 수도 있다.
- 인라인 주석문도 가독성을 높여주는 하나의 방법이지만 실수에 대한 부담, 유지보수에 대한 부담이 있다.
    - 무엇보다 주석이 틀릴 위험이 있다.

### 5.6.5 IDE는 어떤가?

- IDE는 함수 매개변수를 보여줘 편하다.
- 하지만 여러 다른 도구들은 이런 기능이 없으므로 의존하지 않는 것이 좋다.
    - 병합 도구, 코드 리뷰 등등

## 5.7 설명되지 않은 것을 사용하지 말라

- 하드 코드로 작성된 값이 필요할 때가 있다.
    - 계수, 조정 가능한 파라미터 값, 템플릿을 나타내는 문자열


- 하드 코드에는 값이 무엇인지, 무엇을 의미하는지 정보가 포함된다.
- 이때 무엇을 의미하는지를 잘 전달할 필요가 있다.

### 5.7.1 설명되지 않은 값은 혼란스러울 수 있다

- 설명이 없는 값은 왜 그 값이 거기에 있는지, 무슨 일을 하는지 알 수 없어 코드의 가독성을 떨어트린다.
- 즉, 그 값이 무엇을 의미하는지 명확하게 해주는 것이 중요하다.

### 5.7.2 해결책 : 잘 명명된 상수를 사용하라

- 가장 쉬운 해결책 중 하나는 상수를 정의하고 상수의 이름을 통해 값을 설명하는 것이다.

### 5.7.3 해결책 : 잘 명명된 함수를 사용하라

- 또 다른 방법은 잘 명명된 함수를 사용하는 것이다.
    - 상수를 반환하는 공급자 함수(provider function)
    - 변환을 수행하는 헬퍼 함수(helper function)

#### 공급자 함수

- 개념적으로 상수를 사용하는 것과 동일하다.
- 방식만 다르다.

#### 헬퍼 함수

- 변환을 하위 문제로 만들어 이 문제를 해결하는 함수를 만든다.
- 이 함수를 호출하는 입장에서는 계수와 같은 값의 존재를 알 필요가 없다. 구현 세부 사항이다.


- 상수나 함수를 통해 값을 표현하는 것은 추가 작업이 거의 필요없으면서 가독성을 크게 높일 수 있다.
- 또한 이러한 값이나 함수가 다른 곳에서 재사용될 것 같다면 유틸리티 클래스로 빼는 것도 방법이다.

## 5.8 익명 함수를 적절하게 사용하라

- 익명 함수(anonymous funtion)은 이름이 없는 함수다.


- 대부분의 주류 프로그래밍 언어는 익명 함수를 지원한다.
- 간단하고 자명한 것에 익명 함수를 사용하면 가독성을 높여주지만, 복잡하거나 자명하지 않은 것 혹은 재사용해야 하는 것에 사용하면 문제가 될 수 있다.

### 5.8.1 익명 함수는 간단한 로직에 좋다

- 간단한 로직에 익명 함수를 사용하면 편하다.
- 명명 함수를 정의하려면 보일러 플레이트 코드가 많아지며 오히려 가독성이 더 떨어진다고 생각할 수도 있다.
    - 간단한 문제의 경우
    - 명명 함수를 사용하면 재사용 관점에서 유용할 때도 있다.

### 5.8.2 익명 함수는 가독성이 떨어질 수 있다

- 함수의 이름은 많은 정보를 전달한다.
- 익명 함수는 이름이 없기 때문에 내용이 자명하지 않다면 오히려 가독성이 떨어진다.

### 5.8.3 해결책 : 대신 명명 함수를 사용하라

- 복잡한 로직에 대해서 익명 함수가 아니라 명명 함수를 사용하면 이름을 통해 가독성을 높일 수 있다.
- 또한 상위 수준에서 하위 함수를 호출함으로써 추상화 수준을 맞추는 데도 도움이 된다.


- 익명 함수 대신 명명 함수를 사용했을 때의 단점은 더 많은 코드를 작성해야 한다는 것이다.
- 즉, 간단하고 자명한 논리에는 익명함수를, 그렇지 않은 곳에는 명명 함수를 사용해야 한다.

### 5.8.4 익명 함수가 길면 문제가 될 수 있다

- 익명 함수가 두세 줄 이상으로 늘어날 때 여러 개의 명명 함수로 분리하면 가독성이 좋아진다.

### 5.8.5 해결책 : 긴 익명 함수를 여러 개의 명명 함수로 나누라

- 익명 함수가 길어지고 복잡해지면, 로직을 더 작은 단위의 명명 함수로 나눠야 한다.

## 5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라

- 새로운 기능으로 인해 코드의 가독성이 높아지거나 코드가 더 견고해지는 경우가 종종 있다.

### 5.9.1 새로운 기능은 코드를 개선할 수 있다

- 무언가를 직접 만드는 대신 언어에서 제공하는 기능을 사용하면 코드가 최적화되어 효율적이고 버그가 없을 가능성이 커진다.

### 5.9.2 불분명한 기능은 혼동을 일으킬 수 있다

- 언어가 제공하는 기능이 확실한 이점이 있더라도 해당 기능이 다른 개발잗에게 얼마나 잘 알려져있는지 고려할 필요가 있다.
- 궁극적으로 누가 유지보수 할지에 대한 고민이 필요하다.

### 5.9.3 작업에 가장 적합한 도구를 사용하라

- 새로운 기능 추가는 다 이유가 있다.
- 새로운 기능은 단지 새로워서가 아니라 작접에 적합한 도구이기 때문에 사용한다는 것을 분명히 해야 한다.