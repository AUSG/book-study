<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

- [3. 다른 개발자와 코드 계약](#3----)
    * [3.1 자신의 코드와 다른 개발자의 코드](#31-----)
        + [3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다](#311--------)
        + [3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다](#312--------)
        + [3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다](#313------)
    * [3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?](#32--------)
        + [3.2.1 이름 확인](#321--)
        + [3.2.2 데이터 유형 확인](#322---)
        + [3.2.3 문서 읽기](#323--)
        + [3.2.4 직접 물어보기](#324--)
        + [3.2.5 코드를 살펴보는 것](#325---)
    * [3.3 코드 계약](#33--)
        + [3.3.1 계약의 세부 조항](#331---)
        + [3.3.2 세부 조항에 너무 의존하지 말라](#332-----)
            - [세부 조항을 제거하는 방법](#---)
    * [3.4 체크 및 어서션](#34---)
        + [3.4.1 체크](#341-)
        + [3.4.2 어서션](#342-)

<!-- TOC end -->

# 3. 다른 개발자와 코드 계약

- 자신이 작성한 코드를 다른 사람이 작업해야 하고, 다른 사람이 작성한 코드를 자신이 다뤄야 할 때가 있다.

## 3.1 자신의 코드와 다른 개발자의 코드

- 하위 문제를 잘 해결하고, 적절하게 추상화했다면 전혀 생각지 못한 완전히 다른 문제에서도 이 코드가 재사용될 수도 있다.


- 요구사항은 항상 변한다. 1년은 커녕 몇 달이 지나도 동일할 가능성은 거의 없다.


- 고품질의 코드를 작성하기 위해서는 항상 다른 개발자가 변경하거나 코드와 상호작용 할 때 발생할 수 있는 문제는 없는지 고려해야 한다.
- 만약 그런 문제가 발생한다면 그 문제를 어떻게 완화할 수 있을지를 이해하고 선제적으로 조치해야 한다.


- 다른 개발자를 고려하지 않고서는 고품질의 코드를 작성할 수 없다.


- 코드를 작성할 때 다음 세 가지를 고려하면 좋다.

### 3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다

- 우리는 어떤 문제를 해결할 때 많은 시간 동안 그 문제를 생각한다.
- 하지만 다른 개발자가 해당 코드를 만났을 때는 그렇지 않다. 아직 시간을 충분히 갖지 못한 상태다.
- 코드를 작성할 당시에는 당연해 보였던 것들이 그들에게는 그렇지 않다.


- 이런 점을 항상 고려하고 코드가 다음을 잘 설명하고 있는지 확인해야 한다.
    - 어떻게 사용되어야 하는지
    - 무엇을 하는지
    - 왜 그것을 하는지


- 주석문을 많이 쓰라는 것이 아니다.
- 코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.

### 3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다

- 우리의 코드는 독립적으로 존재하지 않는다.
- 끊임없이 변화하는 코드 위에 놓여져있으며, 우리의 코드를 기반으로 하는 코드 또한 끊임없이 작성된다.


- 다른 개발자가 우리의 코드를 접할 때는 사전 지식이 없을 수도 있다.
- 의도치 않게 코드가 작동하지 않게 하거나 오용하는 방식으로 코드를 추가하거나 수정할 수도 있다.


- 이를 방지하기 위해서는 무언가 문제가 있을 때 코드 컴파일이 실패하거나 테스트가 실패하도록 만들어야 한다.
- 이런 노력은 결국 고품질의 코드 작성과 관련된 수많은 고려 사항들이 궁극적으로 이루어지도록 한다.

### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다

- 1~2년 전에 작성한 코드를 다시 들여다보는 일은 다른 사람이 작성한 코드를 보는 것과 크게 다르지 않다.
- 즉, 지금까지 말한 '다른 사람'에는 결국 '나'도 포함된다.


- 따라서 배경지식이 없어도 이해하기 쉽고 버그가 생기기 어려운 코드를 작성하는 것은 다른 사람에게 호의를 베푸는 것이기도 하지만 미래의 자신에게도 도움이 되는 일이다.

## 3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

- 다른 개발자의 우리의 코드를 사용하기 위해서는 우리의 코드를 어떻게 사용하는지, 무슨 일을 하는지 파악해야 한다.
- 다른 개발자가 이를 알기 위해서 할 수 있는 일은 다음과 같다.
    - 함수, 클래스, 열거형 등의 이름을 살펴본다
    - 함수와 생성자의 매개변수 유형, 반환값의 유형 같은 데이터 유형을 살펴본다
    - 함수/클래스 수준의 문서나 주석문을 읽어본다
    - 물어본다
    - 구현 코드를 읽는다


- 이 중 처음 세 가지만이 실제로 사용할만 하다.
- 이름과 데이터 유형을 확인하는 것이 문서를 읽는 것보다 더 믿을만 하다.

### 3.2.1 이름 확인

- 이름을 살펴보는 것은 하위 문제를 해결할 코드를 찾기 위한 편리하고 빠른 방법이다.
- 따라서 자신의 코드를 잘 전달하는 방법 중 하나는 이름을 잘 짓는 것이다

### 3.2.2 데이터 유형 확인

- 제대로만 한다면 데이터 유형을 확인하는 것도 매우 신뢰할 만한 방법이다.
- 특히 컴파일이 필요한 정적 유형의 언어는 잘못 사용하면 컴파일이 되지 않는다.
- 따라서 이런 언어로 코드를 작성하는 것은 코드를 오용하거나 오작동할 수 없도록 하기 위한 좋은 방법 중 하나다.

### 3.2.3 문서 읽기

- 코드에 대한 문서는 다음과 같이 다양한 형태로 존재할 수 있다.
    - 함수, 클래스 수준의 비공식적인 주석
    - 자바독과 같은 좀 더 공식적인 코드 내 문서
    - 외부 문서


- 이런 문서들은 모두 유용하지만 어느 정도까지만 신뢰할 수 있다.
- 그 이유는 다음과 같다.
    - 읽을 것이란 보장이 없다. 안 읽는 경우가 더 많다.
    - 잘못 해석할 수도 있다.
    - 문서가 최신이 아닐 수도 있다.

### 3.2.4 직접 물어보기

- 최근에 코드를 작성했다면 효과적일 수도 있다.
- 하지만 아래와 같은 이유로 신뢰하기 어려운 방법이다.
    - 코드를 많이 쓸수록 질문에 답하는데 더 많은 시간을 써야 한다
    - 코드 작성자가 휴가가면 물어볼 사람이 없다
    - 시간이 지나면 자기도 코드르 제대로 기억하지 못한다.
    - 코드를 작성한 사람이 회사를 떠날 수도 있다.

### 3.2.5 코드를 살펴보는 것

- 코드 사용에 대한 가장 확실한 답을 얻을 수 있는 방법은 코드를 뜯어서 구현 세부 사항을 확인하는 것이다.
- 하지만 이는 실용적이지도 않고 코드의 양이 많으면 효과를 보기 어렵다.


- 하나의 코드는 수 많은 코드에 의존하고 또 그 코드들은 다른 코드들에 의존하므로 읽어야 할 코드가 매우 많을 수도 있다.


- 개발자가 '내 코드의 사용 방법을 이해하고 싶으면 코드 안에서 어떻게 구현됐는지 읽어보면 되지 뭐'라는 자세를 가지면 상황이 더 나빠질 수도 있다.
- 이는 추상화 계층의 많은 이점을 부정하는 것이다.


- 추상화 계층을 만드는 이유는 개발자가 한 번에 몇 가지 개념만 처리하면 되도록 하는 것이다.
- 하위 문제를 어떻게 해결하는지 정확히 모르더라도 해당 해결책을 사용할 수 있어야 한다.

## 3.3 코드 계약

- 계약에 의한 프로그래밍(programming by contract)
- 계약에 의한 디자인(design by contract)
- 이 원칙은 앞에서 논의한 개념 중 일부를 공식화하는 원칙이다.
    - 서로 다른 코드 간의 상호작용을 계약처럼 여긴다.
    - 코드를 호출 할 때는 특정 조건을 만족시켜야 하고 호출되는 코드는 특정 조건에 맞는 동작을 수행하거나 그런 값을 반환한다.
- 이러한 것들이 계약에서 정의되므로 분명하지 않은 것이 없고 예상과 다르게 실행되는 것도 없다.


- 코드의 계약을 다음으로 나누면 좋다
    - 선결 조건(precondition)
        - 코드를 호출하기 전에 사실이어야 하는 것
        - 입력 or 상태
    - 사후 조건(postcondition)
        - 코드가 호출된 후에 사실이어야 하는 것
        - 출력 or 새로운 상태
    - 불변 사항(invariant)
        - 코드 호출 전, 후 비교했을 때 바뀌면 안되는 것


- 이러한 원칙을 신경쓰지 않았더라도 코드는 어떤 종류의 계약을 맺는 것이라 볼 수 있다.
- 특정 입력을 요구하고 특정 반환값이나 동작을 기대하기 때문이다.


- 개발자가 계약의 일부 혹은 모든 조건을 알지 못하면 계약에 문제가 생긴다.
- 즉, 코드를 작성할 때 계약의 내용은 무엇일지, 어떻게 하면 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지 생각해야 한다.

### 3.3.1 계약의 세부 조항

- 코드에서 계약을 정의할 때 명확한 부분과 세부 조항이 있다.


- 명확한 부분
    - 함수와 클래스 이름
    - 인자 유형
    - 반환 유형
    - 검사 예외(checked exception)
- 세부 조항
    - 주석문과 문서
    - 비검사 예외(unchecked exception)
        - 세부 조항에 나와있지 않을 수도 있다.
        - 몇 계층 아래에서 던져지는 예외를 까먹은 경우다


- 코드 조항에서 조건을 명백하는 것이 세부 조항을 사용하는 것보다 훨씬 낫다
- 문서화는 업데이트가 제때 되지 않기 때문에 세부 조항이 항상 정확한 것도 아니다.

### 3.3.2 세부 조항에 너무 의존하지 말라

- 코드를 사용할 때 모든 세부 조항을 다 알지 못할 가능성이 크다
- 따라서 코드 계약을 전달할 때 세부 조항을 사용하는 것은 별로 신뢰할 만한 방법이 아니다.
- 세부 사항에 너무 의존하면 오용하기 쉬운 취약한 코드가 될 가능성이 커지고 예상과 다르게 동작하기 쉽다.


- 세부 조항에 의존하는 것을 피할 수 없는 경우도 있다.
- 어떤 문제들은 항상 주의 사항이 있고 이를 설명할 필요가 있다.
- 또는 다른 사람이 작성한 저품질의 코드에 의존해야 할 때도 있다.


- 따라서 이런 경우 문서화된 세부 조항이 필요하고 다른 사람들이 이를 읽도록 해야 한다.
- 하지만 그럼에도 불구하고 읽지 않을 수도 있으며 문서 업데이트가 밀릴 수도 있다.


- 명확하지 않을 수도 있는 것을 문서화하는 것은 일반적으로 좋은 생각이지만 너무 많이 의존하지 않는 것이 최선이다.

#### 세부 조항을 제거하는 방법

- 다른 개발자가 코드를 올바르게 사용하기 위해 세부 조항에 의존하는 것보단 잘못된 일을 하는 것을 처음부터 불가능하게 하는 것이 좋다.
- 즉, 세부 조항에 있는 것을 불가능하게 만들거나 명백한 것으로 바꾸는 것이 좋다.


- 다르게 말하면 코드가 오용되거나 잘못 설정되면 컴파일조차 되지 않도록 하는 것이 좋다.


- 보통 상태(state)나 가변성(mutability)이 클래스 외부로 노출되는 것을 없앨 때가 많다.

## 3.4 체크 및 어서션

- 컴파일러로 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.
- 일반적으로 컴파일 타임 확인만큼 강력하진 않다.
    - 계약 위반에 대한 발견이 실제 문제를 재현하는 테스트 혹은 일으키는 사용자에 의존하기 때문이다.
    - 즉, 논리적으로 계약 위반을 불가능하게 만드는 컴파일 타임 확인과 대조적이다.


- 하지만 컴파일러를 사용해서 계약을 강제할 수 없는 상황이 종종 있다.
- 런타임 검사로 확인하는 것이 확인하지 않는 것보다 낫다

### 3.4.1 체크

- 체크(check)를 사용하는 것이다
- 이는 계약이 준수되었닌즈 확인하고 그렇지 않다면 실패를 유발하는 오류를 생성한다.
- 이 오류는 명백하기 때문에 놓치고 넘어가는 것이 불가능하다.
    - 이는 failing fast와도 관련이 있다.


- 체크는 검사하는 계약 조건에 따라서 다음과 같이 구분할 수 있다
    - 전제 조건 검사
        - 입력 인수 확인
        - 초기화 잘 되었는지 확인
        - 시스템이 유효한 상태에 있는지 확인
    - 사후 상태 검사
        - 반환값이 올바른지 확인
        - 코드 실행 후 시스템이 유효한 상태에 있는지 확인


- 이러한 방법은 유용하지만 오용을 불가능하게 만드는 것보다는 이상적이지는 않다.


- 체크를 올바르게 사용하는 것은 문제를 개발 또는 테스트 단계에서 발견하고 수정하는 것이다.
- 하지만 현실적으로 체크의 효과가 항상 보장되는 것은 아니다.
    - 배포 전에 이와 같은 문제가 테스트되지 않으면 실제 사용자가 사용하기 전까지 해당 문제가 발견되지 않을 수도 있다
    - 체크가 잘 작동해서 실패가 명백함에도 불구하고 아무도 알아차리지 못할 수도 있다.
        - 예외가 터지지 않고 로그에 기록되는 것일 수도 있다.
    - 이러한 문제는 필요 이상으로 자주 발생한다.


- 가능하다면 처음부터 세부 조항을 피하는 것이 바람직하다
- 체크가 많으면 세부 조항을 없애는 것을 고려해야 한다는 신호일 수도 있다.

### 3.4.2 어서션

- 많은 언어에서 어서션(assertion)을 언어 차원에서 지원한다.
- 이는 코드 계약을 준수하도록 강제하는 방법이라는 점에서 체크와 매우 유사하다.


- 어서션은 체크와 겅릐 같은 방식으로 동작한다.
- 하지만 어서션은 배포 필드 때 컴파일 시 제거된다.
- 즉, 서비스 환경에서 실패를 명백하게 보여주지 않는데 이러한 선택을 하는 이유는 다음과 같다.
    - 성능 향상
    - 코드 오류 발생률을 낮추기 위해
        - 고가용성이 더 중요한 경우


- 배포 빌드에 포함시킬 수 있는 방법도 있고 이렇게 하는 경우도 많다.
- 이 경우 체크와 어서션은 어떤 종류의 오류나 예외를 발생시킬 수 있는지에 대한 일부 세부 사항만 다를 뿐이다.


- 마찬가지로 코드 계약에 세부 조항이 있을 때 어서션을 사용하면 좋다.
- 그러나 애초에 세부 조항을 피하는 것이 가장 좋다
