# 좋은 코드 나쁜 코드

# 1. 코드 품질

## 이미 존재하는 기능을 중복 구현해서는 안 된다.

### 이미 구현된 코드를 재사용하면 좋은 점

- 시간과 노력을 절약
- 버그 가능성을 줄여줌
- 기존 전문지식을 활용
- 코드가 이해하기 쉬움

## 코드 품질의 핵심 요소

1. 읽기 쉬워야 함
2. 예측 가능해야 함
   피자를 주문했는데 칵테일을 주면 안됨(마르게리타피자 → 마르가리타 칵테일)
3. 오용하기 어려워야 함
   전원 소켓과 HDMI소켓이 다른 것처럼
4. 모듈화
   부품으로 나눠질 수 있는 장난감은 쉽게 재조립할 수 있지만 꿰매서 만든 장난감은 다시 만들기 어려움
5. 재사용가능하고 일반화할 수 있게
   드릴을 생각하자
6. testability한 코드를 작성하고 제대로 테스트하기

## 고품질 코드 작성은 일정을 지연…?

맞음. 하지만 당장은 지연시키더라도 유지보수할 때에 시간을 절약해줄 수 있음

# 2. 추상화 계층

## 왜 추상화계층?

문제가 복잡하더라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 복잡한 문제를 쉽게 다룸

### 추상화 계층 및 코드 품질의 핵심 요소

> - 가독성
>   상위 개념만 다뤄도 코드를 쉽게 이해할 수 있음
> - 모듈화
>   해당 계층 내만 조작하더라도 쉽게 구현을 변경할 수 있어짐
> - 재사용성 및 일반화성
>   하나의 해결책이 여러가지 상황의 하위문제 해결책으로 사용되기 쉬워짐
> - 테스트 용이성
>   하위문제에 대해 테스트해보기 쉬움

## 코드의 계층

미니 API라고 생각하면 이해하기 쉬움.
서비스를 구현한 뒤 모든 구현 세부 사항은 API 뒤에 감춤

### 함수

함수가 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적
함수가 하는 일은 `1. 단일 업무 수행` or `2. 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성`

> ex
> 소유자의 주소를 찾아 편지 한 통을 보내라.
> ⇒ `차량 소유자의 주소를 찾는다` + `주소를 찾은 경우 차량 소유자에게 편지를 보낸다.`

### 클래스

- number of liines : 한 클래스는 코드 300줄을 넘지 않기를 권장
- 응집력(cohesion) :
  - 순차적 응집력 : function1(function2(a)) 인 경우 function1과 function2는 서로 응집력이 있음
  - 기능적 응집력 : 몇가지 요소가 하나의 일을 성취하는 데 기여할 때 발생
- 관심사의 분리(separation of concerns) : 별개의 관심사(문제)를 다루는 개별 구성 요소로 분리되어야 함
  ex. 게임기와 TV. 신규 게임기가 나오면 게임기만 사면 되고 TV는 사지 않아도 됨

> ‘하나의 사항’을 어느 수준으로 정해야할 지 애매함. ㅇㅈ

주의 : 클래스가 하는 일이 하나의 문장으로 정리된다고 무조건 좋은 클래스가 아님. ‘코드품질의 핵심요소’를 만족해야함. 이런 경우 개선을 위해 여러 클래스로 나누고 DI를 사용하면 좋음

### 인터페이스

- Pros
  - 퍼블릭 API를 매우 명확하게 보여줄 수 있음
  - 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있음
  - 테스트를 쉽게 할 수 있음
  - 같은 클래스로 두 가지 하위 문제를 해결할 수 있음
- Cons
  - 더 많은 작업이 필요함
  - 코드가 복잡해질 수 있음

## 층을 나누는 기준

‘코드 품질의 핵심요소’를 기준으로 잘 정해야함.

애매하다면 많이 얇게 나누는 것이 뭉텅이로 있는 것보다는 낫다.

# 3. 코드 계약

> 다른 사람들이 어떻게 코드를 사용할지 코드가 무엇을 할 것으로 기대할 수 있는지에 대한 내용

자신의 코드를 남이 읽거나 내 코드를 남이 읽을 수 있기 때문에 아래 내용을 고려해야 함

- 자신에게 명백하다고 남에게도 명백한 것은 아님
- 다른 개발자는 무의식 중에 내 코드를 망가뜨릴 수 있음
- 시간이 지나면 나도 내 코드를 까먹음

## 계약 구성

> 계약의 명확한 부분

- 함수와 클래스 이름
- 인자 유형
- 반환 유형
- 검사 예외
  >

> 세부 조항

- 주석문과 문서
- 비검사 예외..? (예외사항을 문서에서 언급하지 않을 수도 있음)
  >

## 세부 조항에 너무 의존하지 않기

개발자들이 모두 주석을 꼼꼼히 읽는 것이 아니기 때문에 주석과 같은 세부조항에 지나치게 의존하면 안됨.

상태나 가변성이 클래스 외부로 노출되는 것을 없애는 등의 방식으로 주석없이 조건을 만족시킬 수 있음
⇒ 생성자, 프라이빗 함수를 사용한 상태변경, enum, hashmap등을 사용할 수 있음

## 체크

컴파일러를 이용해서 확인되지 않는 사항을 런타임을 통해 확인하는 방법

일반적으로 예외처리 등을 ‘체크’라고 하는 것 같음

## 어서션

체크와 비슷하지만 실제 배포를 위해 빌드할 때 보통 파일에서 제외됨

많은 언어에서 어서션을 지원함

> 체크와 어서션은 세부조항을 피할 수 없을 때 사용하면 좋지만 최대한 세부조항을 없애는 것이 바람직함

# 4. 오류

## 복구 가능성

- 복구 가능한 오류
  어플리케이션이 종료되지 않고 계속 실행상태가 유지될 수 있는 오류
  사용자 입장에서 해결할 수 있음
- 복구 불가능한 오류
  사용자입장에서는 해결할 수 없는 오류

## 호출하는 쪽에서 복구가능한 오류에 대해 인지해야 함

```jsx
function1{
	function2(value);
}
```

위와 같은 케이스에서 입력값의 문제때문에 function2에서 오류가 난다고 하면 function1에서 value가 잘못되었기때문에 오류가 발생한다는 사실을 알아야 복구가능한 오류로서 기능을 할 수 있음

## failing fast

오류가 난 지점과 최대한 가까운 지점에서 실패해야 오류를 찾기 쉬움

## failing loudly

오류가 발생했는데 아무도 모르고 넘어가는 상황을 막아야 함

## 오류 전달 방법

오류가 발생하면 상위 계층에 오류 발생 사실을 알려야 함

### 예외 처리

- 명시적 방법 : 검사 예외 (Exception)
  상위 계층에서 예외를 처리해주어야함
- 암시적 방법 : 비검사 예외 (RuntimeException)
  상위 계층에서 예외를 처리하지 않아도 됨

### 그 외의 명시적 방법

- NULL 반환
- result 반환
  오류가 발생한 이유도 전달
- 아웃컴 반환
  void 함수의 경우 bool을 리턴하게 해서 함수 실행의 성공/실패 여부를 반환하게 함
  `@CheckReturnValue` 등을 사용하여 상위 계층에서 반환값을 무시하지 못하도록 함

### 그 외 암시적 방법

- promise or future
  비동기로 실행하다 실패해도 다음 코드는 실행되므로 상위계층에서 모를 수 있음
- 매직값 반환
  사용자가 정의한 특정값을 실패로 처리 (ex. -1 반환)

### 오류를 어떻게 전달하면 바람직한가

정답 없음. 팀원들의 의견이 최우선시 되길 바람

# 5. 가독성 높은 코드를 작성하라

## 서술형 명칭 사용

- 서술적인 명명은 코드를 읽기 쉽게 만듦

## 주석문의 적절한 사용

- 주석은 코드가 `무엇`을 `왜` 하는지 설명하기 좋음
- 단, `무엇` 을 설명하기에는 가독성 좋은 코드가 더 좋을 수 있음
  상위 수준의 요약 정보를 제공하기에는 주석이 용이할 수 있음
- `왜` 를 설명하기에 주석이 용이할 수 있음

## 코드 줄 수를 고정하지 않기

- 간결하지만 이해하기 어려운 코드는 피해야 함
- 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하는 것이 바람직함

## 일관된 코딩 스타일 고수

- 스타일 가이드를 채택하고 따르는 것이 좋음 (https://google.github.io/styleguide/)

## 깊이 중첩된 코드를 피하기

- 중첩을 피하기 위해 논리를 재배치하는 것이 좋음
  ex. if { … } else { if { … } } 과 같은 구조인 경우 else를 없애는 등
- 중첩은 너무 많은 일을 한 결과물
  ⇒ 더 작은 함수로 분리하면 깔끔하게 정리할 수 있음

## 함수 호출도 가독성이 있어야 함

- 매개변수는 어려울 수 있음
  ⇒ 명명된 매개변수 사용
  ⇒ 명명된 매개변수를 지원하지 않는 경우 interface선언 후 매개변수로 해당 interface를 입력받음으로써 비슷한 효과를 가질 수 있음
  ⇒ 혹은 class, enum 등을 매개변수로 사용하는 등 함수를 더욱 서술적으로 선언할 수도 있음
- 모든 상황에서 정답이 있는 것은 아님.

## 설명되지 않은 값을 사용하지 않기

- 설명되지 않은 값은 나빠
- 잘 명명된 함수/변수 사용하기

## 익명 함수(anonymous function)의 적절한 사용

- 간단한 로직에서 효과적
- 가독성이 떨어질 수 있음

## 언어의 새로운 기능 적절히 사용

- 하지만 무분별한 사용은 좋지 않음. 작업에 가장 적합한 도구를 사용해야 함
