- [Chapter 4. 오류](#chapter-4-오류)
  - [4.1 복구 가능성](#41-복구-가능성)
    - [4.1.1 복구 가능한 오류](#411-복구-가능한-오류)
    - [4.1.2 복구할 수 없는 오류](#412-복구할-수-없는-오류)
    - [4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다](#413-호출하는-쪽에서만-오류-복구-가능-여부를-알-때가-많다)
    - [4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라](#414-호출하는-쪽에서-복구하고자-하는-오류에-대해-인지하도록-하라)
  - [4.2 견고성 vs 실패](#42-견고성-vs-실패)
    - [4.2.1 신속하게 실패하라](#421-신속하게-실패하라)
    - [4.2.2 요란하게 실패하라](#422-요란하게-실패하라)
    - [4.2.3 복구 가능성의 범위](#423-복구-가능성의-범위)
    - [4.2.4 오류를 숨기지 않음](#424-오류를-숨기지-않음)
  - [4.3 오류 전달 방법](#43-오류-전달-방법)
    - [4.3.1 요약: 예외](#431-요약-예외)
    - [4.3.2 명시적 방법: 검사 예외](#432-명시적-방법-검사-예외)
    - [4.3.3 암시적 방법: 비검사 예외](#433-암시적-방법-비검사-예외)
    - [4.3.4 명시적 방법: 널값이 가능한 반환 유형](#434-명시적-방법-널값이-가능한-반환-유형)
    - [4.3.5 명시적 방법: 리절트 반환 유형](#435-명시적-방법-리절트-반환-유형)
    - [4.3.6 명시적 방법: 아웃컴 반환 유형](#436-명시적-방법-아웃컴-반환-유형)
    - [4.3.7 암시적 방법: 프로미스 또는 퓨처](#437-암시적-방법-프로미스-또는-퓨처)
    - [4.3.8 암시적 방법: 매직값 반환](#438-암시적-방법-매직값-반환)
  - [4.4 복구할 수 없는 오류의 전달](#44-복구할-수-없는-오류의-전달)
  - [4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달](#45-호출하는-쪽에서-복구하기를-원할-수도-있는-오류의-전달)
    - [4.5.1 비검사 예외를 사용해야 한다는 주장](#451-비검사-예외를-사용해야-한다는-주장)
    - [4.5.2 명시적 기법을 사용해야 한다는 주장](#452-명시적-기법을-사용해야-한다는-주장)
    - [4.5.3 필자의 의견: 명시적 방식을 사용하라](#453-필자의-의견-명시적-방식을-사용하라)
  - [4.6 컴파일러 경로를 무시하지 말라](#46-컴파일러-경로를-무시하지-말라)

<br/>
<br/>

# Chapter 4. 오류
- 코드에서 불가피한 오류를 다루는 법을 알아본다.

## 4.1 복구 가능성
- 복구할 수 있는 오류와 복구할 수 없는 오류가 있다.

### 4.1.1 복구 가능한 오류
- 잘못된 사용자 입력, 네트워크 오류, 중요하지 않은 작업 오류는 복구 가능한 오류다.
- 일반적으로 시스템 외부의 무언가에 의해 일어나는 오류다.

### 4.1.2 복구할 수 없는 오류
- 코드와 함께 추가되어야 하는 리소스가 없거나 어떤 코드가 다른 코드를 잘못 사용하고 있을 때 복구할 수 없는 오류가 일어난다.

### 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다
- 대부분의 오류는 한 코드가 다른 코드를 호출할 때 발생한다.
- 오류로부터 복구하기를 호출하는 쪽에서 원하는가, 그 사실을 호출하는 쪽에서 어떻게 알 수 있을까를 고려해야 한다.

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라
- 함수에서 오류가 발생할 수 있다는 가능성을 호출하는 쪽에서 확실하게 인지하도록 해야 한다.

<br/>

## 4.2 견고성 vs 실패
- 오류가 발생할 때 다음 중 하나를 선택해야 한다.
  - 실패: 더 높은 코드 계층이 오류를 처리하게 하거나 전체 프로그램의 작동을 멈추게 한다.
  - 견고성: 오류를 처리하고 계속 진행한다.

### 4.2.1 신속하게 실패하라
- 코드가 잘못된 동작을 하기 시작하면 그 가까운 곳에서 오류를 알려야 한다.

### 4.2.2 요란하게 실패하라
- 오류가 발생하면 프로그램이 중단되게 한다.
- 오류 메시지를 기록한다.

### 4.2.3 복구 가능성의 범위
- 단일 요청 내에서 복구 할 수 있는 케이스와, 서버 차원에서 복구할 수 있는 케이스 등이 있을 수 있다.
- 오류가 전체 소프트웨어의 동작을 멈추지 않도록 하기 위해 코드의 독립적이거나 중요하지 않은 부분을 분리하면 좋다.

### 4.2.4 오류를 숨기지 않음
- 오류를 숨기는 것은 복구할 수 있는 오류와 복구할 수 없는 오류 모두에 문제를 일으키기에 바람직하지 않다.
- 기본값 반환: 오류가 발생한 사실을 숨기고 호출하는 쪽에서 모든 것이 정상인 것처럼 계속 진행한다.
- 널 객체 패턴: 널 객체는 실제 반환값처럼 보이지만 오류 처리에 사용하는 것은 바람직하지 않다.
- 아무것도 하지 않음: 오류가 발생했다는 신호를 아예 보내지 않는 것도 바람직하지 않다.

<br/>

## 4.3 오류 전달 방법
- 오류가 발생하면 일반적으로 더 높은 계층으로 오류를 알려야 한다.
- 명시적 방법: 코드를 직접 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수밖에 없도록 한다.
- 암시적 방법: 코드를 호출하는 쪽에 오류를 알리지만 호출하는 쪽에서 그 오류를 신경 쓰지 않아도 된다.

### 4.3.1 요약: 예외
- 예외는 일반적으로 충분한 기능을 가진 클래스로 구현된다.

### 4.3.2 명시적 방법: 검사 예외
- 함수는 검사 예외를 발생시킬 수 있음을 선언하고 (throw) 오류를 발생하면 검사 예외를 발생시킨다.
- 호출하는 쪽에서도 검사 예외가 발생하면 이를 파악하고 적절하게 처리해줄 수 있다. (try catch)

### 4.3.3 암시적 방법: 비검사 예외
- 코드 계약에 있어 세부 조항에 해당한다.
- 비검사 예외가 발생할 수 있음을 문서로 전달한다. 함수 정의부에서 비검사 예외가 발생할 수 있음을 정의하지 않고 실제 오류가 발생한 곳에서 예외를 발생시킨다.
- 함수를 호출하는 쪽은 예외를 확인하고 처리하지 않아도 된다.

### 4.3.4 명시적 방법: 널값이 가능한 반환 유형
- 널 안전성을 지원하는 상황에서 널값이 가능한 반환 유형을 사용해 명시적으로 오류를 전달할 수 있다.
- 널값이 가능한 반환 유형을 정의하고 호출하는 쪽에서 확인해볼 수 있다.

### 4.3.5 명시적 방법: 리절트 반환 유형
- 널값이나 옵셔널 타입을 반환할 때 문제 중 하나는 오류 정보를 전달할 수 없다는 것이다.
- result 유형을 통해 값을 얻을 수 없는 이유를 알려줄 수 있다.

### 4.3.6 명시적 방법: 아웃컴 반환 유형
- 어떤 일을 수행하고 그 동작의 결과 값을 반환하도록 설계할 수 있다.

### 4.3.7 암시적 방법: 프로미스 또는 퓨처
- promise나 future을 사용해 오류 상태를 전달해볼 수 있다.
- 일반적으로 오류 처리를 강제로 해야 하지 않고 세부 조항을 잘 알지 못하면 오류 처리 코드를 생략할 수 있기 때문에 암시적인 방법이다.
- result 유형의 프로미스를 반환하면 명시적인 방법이 된다. (하지만 코드가 복잡해진다)

### 4.3.8 암시적 방법: 매직값 반환
- magic value: 오류 코드; 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 부여하는 값
- 일반적으로 -1을 반환한다.

<br/>

## 4.4 복구할 수 없는 오류의 전달
- 일반적으로 복구할 가능성이 없는 오류가 발생하면 신속하고 요란하게 실패하는 것이 최상의 방법이다.
  - 비검사 예외 발생
  - 프로그램이 panic이 되도록
  - check나 assertion 사용

## 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달
- 정답은 없다.
- 비검사 예외와 명시적 오류 전달 기법 중 어느 것을 사용해야 하는지 논쟁이 있다.

### 4.5.1 비검사 예외를 사용해야 한다는 주장
- 코드 구조를 개선할 수 있기 때문에 비검사 예외를 사용해야 한다.
- 개발자가 너무 많은 명시적 오류 전달을 접하면 무시하기 시작한다. -> 실용적으로 접근해야 한다.

### 4.5.2 명시적 기법을 사용해야 한다는 주장
- 매끄러운 오류 처리가 가능하다.
- 실수로 오류를 무시할 수 없다.
- 문서화되지 않은 비검사 예외가 훨씬 실용적이지 않다.

### 4.5.3 필자의 의견: 명시적 방식을 사용하라
- 코드베이스 전반에 걸쳐 완전히 문서화 되는 경우가 드물다.
- 비검사 예외가 가져오는 리스크가 너무 크다.

<br/>

## 4.6 컴파일러 경로를 무시하지 말라
- 버그에 대한 조기 경고일 수 있기 때문에 무시하지 말아야 한다.