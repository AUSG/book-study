# 1~5

# 1. 코드 품질

- 고품질 코드를 작성하는 전형적인 이야기
- `코드 품질의 핵심 요소`
  - 읽기 쉬워야 한다.
  - 동작이 예측 가능해야 한다.
  - 구조적으로 코드를 오용하기 어렵게 만들라.
  - 모듈화하라
  - 재사용 가능하고 일반화할 수 있게 작성하라.
  - 테스트가 용이한 코드를 작성하고, 제대로 테스트 하라.
- `고품질 코드 작성은 일정을 지연시키는가?`
  - 단기적으로는 그렇다.
  - 하지만 수명이 긴 중요한 소프트웨어를 개발하고 있다면, 고품질 코드를 작성하는 것이 중장기적으로 개발 시간을 단축해준다.
  - 항상 트레이드 오프를 고려하라.
- 테스트는 코드를 작성하는 모든 단계에서 고려하는 것이 좋다.
  - 테스트 작성은 코드를 작성하고 난 후에 고려하는 것이 아니다.

# 2. 추상화 계층

- `추상화 계층 및 코드 품질의 핵심 요소`
  - `가독성`
    - 단일 클래스에 너무 많은 개념을 담지말고 인지적 부담과 오류 발생 가능성을 줄여라
  - `모듈화`
    - 하위 문제에 대한 해결책의 구현을 쉽게 교체할 수 있도록 하라
  - `재사용성 및 일반화성`
    - 누군가 내가 풀고 있는 하위 문제를 풀 가능성이 꽤 높다.
  - `테스트 용이성 및 적절한 테스트`
    - 로직이 여러 클래스로 나누어지면 각 부분을 적절하게 테스트하기가 훨씬 쉽다.

- `저품질 코드`
  - `코드를 읽을 수 없다.`
    - 어떤 개념이 하위 문제를 해결하는 데 필요한지 파악하는데 시간이 오래 걸린다.
  - `코드가 특별히 모듈화되어 있지 않다.`
    - 따라서 코드를 재구성하거나 수정하기 어렵다
  - `코드를 재사용할 수 없다.`
    - 중복코드가 난무한다
  - `코드를 일반화할 수 없다.`
    - 모듈화되어 있지 않은 경우 데이터 입력과 같이 쉽게 변하는 부분을 대체하기 어렵다
  - `코드를 제대로 테스트하기 어렵다.`

- `인터페이스`
  - 구현 함수가 하나만 있더라도 인터페이스를 정의하는 건 팀에서 결정할 사안이다. 팀바팀.
  - 그러나 이러한 접근 방식은 몇 가지 장점이 있다.
    - **퍼블릭 API를 매우 명확하게 보여준다.**
    - **mocking을 통해 코드를 쉽게 테스트할 수 있다**
    - **한 가지 구현만 필요하다고 해도 이는 당시에 잘못 추측한 것일 수 있다.**
    - **일반화의 가능성을 높인다**
      - 같은 클래스로 두 가지 하위 문제를 해결할 수 있다.
        - e.g. LinkedList 구현 클래스는 List, Queue 인터페이스를 모두 구현함
  - **단점도 존재한다**
    - 더 많은 작업이 필요하다
    - 코드가 복잡해질 수 있다.
  - 인터페이스를 남용하면 코드가 매우 이해하기 어렵고 수정이 어려워진다.
  - `결론은 이것 또한 트레이드오프`

- 코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다.
  - 너무 비대한 추상화 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않은 경우에는 남용의 위험에도 불구하고 계층을 얇게 만드는 것이 좋다.

# 3. 다른 개발자와 코드 계약

- **자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다**
- **다른 개발자는 무의식 중에 여러분의 코드를 망가뜨릴 수 있다.**
  - 테스트를 작성하라
- **시간이 지남에 따라 자신의 코드를 기억하지 못한다**

코드 사용 방법에 대한 가장 확실한 답을 얻을 수 있는 방법은 코드의 구현 세부 사항을 살펴보는 것이다.

- **하지만 이 접근법은 실용적이지도 않고 코드의 양이 많으면 효과를 얻기 힘들다.**
- 코드베이스에 작업하는 모든 개발자가 `내 코드의 사용 방법을 이해하고 싶으면 코드 안에서 어떻게 구현됐는지 읽어보면 되지 뭐` 라는 자세를 갖는다면 상황은 더 악화될 수 있다.

## 코드 계약

- **다른 사람들이 어떻게 코드를 사용할지, 그리고 코드가 무엇을 할 것으로 기대할 수 있는지에 대해 코드를 구조적으로 공식화하라.**
  - e.g. 생성자를 private으로 만들고 객체를 생성하는 create() 메서드를 따로 두어서 create() 메서드를 사용하도록 강제함. create() 메서드르 사용함으로 잘못된 데이터가 생성되는 것을 계약으로 방지

```kotlin
class UserSettings {
 // 생성자를 private으로
 private UserSettings() { ... } 
 
 // 객체를 생성하려면 create 메서드를 사용해야만 함
 static UserSettings? create(File location) {
  // ...
 }
}
```

## 체크 및 어서션

- 컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 `런타임 검사`를 사용할 수 있음
  - 이 책에선 이걸 `체크`라고 통칭함
  - 컴파일러를 사용하여 계약을 강제할 수 없는 경우 활용.
  - 테스트에 의존해야하지만 없는 것보단 나음.
  - 단순히 application code에 예외를 던지는 코드를 추가하는 방식
- 경우에 따라 코드 계약에서 세부 조항을 피할 수 없고, 이때는 계약이 준수되는지 확인하기 위해 체크를 추가하는 것이 좋음.
  - 하지만 가능하다면 처음부터 세부 조항을 피하는 것이 바람직.
  - 코드에 체크가 많이 있으면 세부 조항을 없애는 것에 대해 고려해봐야 한다는 신호일지도 모름.
- `코드베이스는 계속 변하고 여러 개발자에 의해 변경됨.`
  - 다른 개발자가 어떻게 코드를 해석하고 오용할 수 있을지 생각해보고, 이러한 가능성을 최소화하거나 오용이 불가능하도록 만드는 방식으로 코드를 작성하는 것이 유용함.
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어짐. 여기에는 명백한 항목이나 세부 조항과 같은 내용이 포함될 수 있음
  - `명백한 항목` : 함수와 클래스 이름, 인자 유형, 반환 유형, 검사 예외
  - `세부 조항` : 주석과 문서, 비검사 예외(unchecked exception)

- **코드 계약의 세부 조항은 다른 개발자에게 계약을 준수하도록 하기 위한 방법이지만 신뢰할만한 방법은 아님.**
  - **보통 더 나은 접근법은 명백한 항목으로 계약의 내용을 전달하는 것.**
- 일반적으로 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰도가 높음.
  - 하지만 이것이 불가능할 때 코드 레벨에서 체크나 어서션을 사용하여 실행 시간에 계약을 확인해 볼 수 있음.

# 4. 오류

## 복구 가능성

- **소프트웨어에서 특정 오류가 발생한 경우 복구할 수 있는 현실적인 방법이 존재하는지 생각해야 하는 경우가 많다.**

- `복구 가능한 오류` (일시적인 오류)
  - 네트워크 오류
  - 중요하지 않은 작업 오류
  - 이런 경우 사용자에게 적절한 오류 메시지를 보여주고 재시도하도록 유도하는 것이 더 나음.
- `복구 불가능한 오류` (영구적 오류)
  - 코드와 함께 추가되어야 하는 리소스가 없음 (not found, null pointer)
  - 어떤 코드가 다른 코드를 잘못 사용
  - 오류를 복구할 수 있는 방법이 없다면, 유일하게 코드가 할 수 있는 합리적인 방법은
    - 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화하는 것.
    - 이후 신속한 실패(failing fast)와 요란한(failing loudly)에 대해 살펴본다.

- `신속하게 실패하라.`
  - 그래야 stacktrace 지옥에 빠지지 않고 오류를 빨리 찾을 수 있다
- `요란하게 실패하라.`
  - 오류가 발생했는데도 불구하고 아무도 모르는 상황을 막아라

- `오류 전달 방법`
  - `명시적 오류`
    - checked exception
    - 코드를 직접 호출한 쪽에서 구조적으로 오류가 발생했음을 인지할 수 밖에 없도록 한다.
    - java에서는 Exception을 상속한 경우
    - error와 응답을 동시에 담는 Result라는 헬퍼 객체를 만들수도 있음.
  - `암시적 오류`
    - **코드를 호출하는 쪽에 오류를 알리지만, 호출하는 쪽에서 그 오류를 신경쓰지 않아도 된다.**
    - 오류가 발생할 수 있음을 알리기 위해 문서나 코드를 읽는 등의 적극적인 노력이 필요.
    - unchecked exception의 경우 어떤 오류가 발생할 수 있는지 주석에 명시하는 것이 권장된다.
    - java에서는 RuntimeException을 상속한 경우

- 팀원들이 오류 전달에 대한 철학을 동의하고 그것을 따르는 것이 바람직함.
  - 각기 다른 오류 처리 방식을 택하고 있다면 개발 시 오해와 실수가 생기기 딱 좋은 구조
  - 명시적 오류를 내보는 게 되도록이면 좋다.

# 5. 가독성 높은 코드를 작성하라

- `가독성은 주관적이다.`
  - 그러나 핵심은 개발자가 코드의 기능을 빠르고 정확하게 이해할 수 있도록 하는 것이다.

- `서술적 명칭을 사용하라`
  - 변수, 함수 및 클래스가 별도로 설명할 필요 없이 자명하도록 명칭을 작성하라
  - 코드를 따로 떼고 그 줄만 보아도 의미가 있도록 만들어라.
    - e.g. `team.containsPlayer(playerName)` ← Team 클래스를 확인하지 않아도 무슨 일을 하는지 알 수 있음

- `주석은 웬만하면 코드에서 명확히 할 수 없는 것들을 표현하라.`
  - 그 코드가 작성된 이유나 배경을 설명
- `주석문으로 가독성 높은 코드를 대체할 수 없다.`
- `주석은 매우매우 복잡한 동작을 요약하는데 유용할 수도 있다.`
  - **비트 연산과 같은 복잡한 최적화를 해야하는 경우에 말이다.**
- `스타일 가이드를 채택하고 따르라.`
  - 일관성있는 코딩 스타일이 중요하다.
  - **일관성은 혼동을 줄이고 신뢰를 준다.**
- `매개변수가 많으면 함수를 이해하기 어렵다.`
  - 이를 해결하기 위해서 파라미터 수를 줄이거나
  - named parameter를 사용하거나
  - 함수를 좀 더 서술적으로 기술하거나
    - 일급 객체 만들어서 표현력 올리기
  - **때로는 적절한 해결책이 없을 수 있다.**
    - 이럴 땐 주석을 활용할 수 있지만, 권장하진 않는다.
    - 관리되지 않은 주석은 주석이 없는 것보다 훨씬 나쁘다.
- `간단하고 자명한 것에 익명 함수를 사용하면 가독성이 올라간다.`
  - 그러나 복잡하고 자명하지 않은 경우 혹은 재사용해야 하는 것에 사용하면 문제가 된다.

- `코드 가독성이 떨어져 이해하기 어려울 때 문제점`
  - 다른 개발자가 코드를 이해하느라 시간을 허비한다.
  - 버그를 유발하는 오해
  - 잘 작동하던 코드가 다른 개발자가 수정한 후에 작동하지 않음.
- **코드의 가독성을 높이려면 다른 개발자의 입장을 공감하고, 그들이 코드를 읽을 때 어떻게 혼란스러워할지를 상상해보는 것이 필요하다.**
- **가독성이 좋은 코드를 작성하려면 언제나 상식을 적용하고 판단력을 사용하라.**
  - 너무나 다양한 시나리오가 있고 그 상황에 해당하는 어려움이 있음.
