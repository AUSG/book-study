# 6장~8장

# 6. 예측 가능한 코드를 작성하라

- `-1과 같은 매직값을 반환하지 마라.`
  - 매직값은 버그를 유발할 수 있다.
- `널 객체 패턴을 적절히 활용하라`
  - 빈 컬렉션을 반환하면 코드가 개선될 수도 있다
  - 하지만 빈 문자열을 반환하는 건 때때로 문제가 될 수 있다
  - 뭐가 됐든 좀 더 표현력을 올리고 예측가능하도록 도와주는 방안을 선택하라

## 사이드 이펙트를 피하라

- 단, 분명하고 의도적인 사이드 이펙트는 괜찮다. e.g. 화면에 경고 알림 표시 등
- 사이드이펙트를 일으키는 함수 이름에 해당 정보를 서술적으로 표현하고 그 함수를 사용하는 사용자의 가정을 깨뜨려라
- `입력 매개변수를 수정하는 것에 주의하라`
  - 불변을 유지하라(복사하기)
- `오해를 일으키는 함수는 작성하지 말라`
  - 중요한 입력값이 입력되지 않았다면 티를 내라

## 미래를 대비한 열거형 처리

- 미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다.
  - 미래에 추가될 열거값에 대한 처리가 명시적이지 않다면 의도치않은 버그가 발생할 수 있다.
  - 따라서 `모든 경우를 처리하는 스위치 문을 사용하라`
    - 스위치 문을 통해 열거값이 미래에 추가되더라도 큰 문제가 없도록 하라.
    - 혹은 명시적으로 처리되지 않은 열거값에 대해 에러가 발생하도록 하라.
- `default 사용에 주의하라`
  - 이는 위에 말해던 이유와 같다.
- `다른 프로젝트의 열거형에 의존하는 것은 위험할 수 있다.`
  - 다른 프로젝트에서 새로운 열거값을 추가할 가능성이 있고 이에 대한 대비가 되지 않는 상황이면 버그가 발생할 수 있다.

## 요약

- 다른 개발자가 작성하는 코드는 종종 우리가 작성하는 코드에 의존한다.
  - 다른 개발자가 우리 코드의 기능을 잘못 해석하거나 처리해야 하는 특수항 경우를 발견하지 못하면, 우리가 작성한 코드에 기반한 그 코드에서 버그가 발생할 가능성이 크다.
  - 코드를 호출하는 쪽에서 예상한대로 동작하기 위한 좋은 방법 중 하나는 중요한 세부 사항이 코드 계약의 명백한 부분에 포함되도록 하는 것이다.
- 우리가 사용하는 코드에 대해 허술하게 가정을 하면 예상을 벗어나는 또 다른 결과를 볼 수 있다.
  - 예를 들어 열거형에 추가되는 새 값을 예상하지 못한 경우
  - 의존해서 사용 중인 코드가 가정을 벗어날 경우, 코드 컴파일을 중지하거나 테스트가 실패하도록 하는 것이 중요
- 테스트만으로 예측을 벗어나는 코드의 문제를 해결할 순 없다. 다른 개발자가 코드를 잘못 해석하면 테스트해야 할 시나리오도 잘못 이해할 수 있다.

# 7. 코드를 오용하기 어렵게 만들라

- `방어적 디자인`(defensive design) 원칙은 소프트웨어 분야에서 API와 인터페이스가 `사용하기는 쉽고 오용하기는 어려워야 한다` 는 문장으로 이해되기도 하는데,
EUHM(easy to use and hard to misuse)이라고도 한다.

## 불변 객체로 만드는 것을 고려하라

- 가변 객체는 추론하기 어렵다
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있다.
- 가변 클래스는 오용하기 쉽다
- `객체를 생성할 때만 값을 할당하라`
- `불변성에 대한 디자인 패턴을 사용하라`
  - **빌더 패턴**
    - 빌더 패턴은 한 클래스를 두 개로 나누는 효과를 갖는다.
      - 값을 하나씩 설정할 수 있는 빌더 클래스
      - 빌더에 의해 작성된 불변적인 읽기 전용 클래스
  - **쓰기 시 복사 패턴(copy-on-write)**

## 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 깊은 가변성(deep mutability)을 주의하라. (참조값에 대한 주의)
- `방어적으로 복사하라`
  - 생성 시 필드 중 참조값을 가진 객체는 복사본을 만들어라
  - e.g. List<Object>
- `불변적 자료구조를 사용하라`
  - e.g. Java ImmutableList class

## 지나치게 일반적인 데이터 유형을 피하라

**정수나 리스트와 같은 유형으로 표현이 가능하다고 해서 그것이 반드시 좋은 방법은 아니다.**

**설명이 부족하고 허용하는 범위가 넓을수록 코드 오용은 쉬워진다.**

- e.g. List<Double> 을 위도 경도 표현에 활용하여 인덱스 접근하는 경우.
  - `이런 것 대신 좀 더 명확한 클래스를 감싸는 식으로 활용하라.`
- `패러다임은 퍼지기 쉽다`
  - List<Double>과 같이 오용하기 쉬운 코드를 남기면 이 코드를 사용하는 패러다임이 다른 코드에도 퍼지게 된다.
  - **어차피 단 하나의 함수에서 사용되기 때문에 코드베이스 전체에 해를 끼치지는 않을 것이라 생각하고 임시변통을 정당화할 수는 있지만, 이 코드가 다른 코드 전반에 퍼지는 경향이 있다는 것을 충분히 인지해야한다.**
    - 이건 다른 개발자들도 같은 방식으로 하지 않고는 이미 작성된 코드와 상호작용하기 어려워지기 때문이다.
    - 이런 일은 상당히 빨리, 광범위하게 확산될 수 있따.

## 페어 유형은 오용하기 쉽다

많은 프로그래밍 언어에는 페어(pair) 데이터 유형이 있다.

- Pair<Double, Double>은 무엇을 의미하는지 파악하기 쉽지 않다.
- `전용 유형을 사용하라`
  - 위도, 경도 표현을 위한 새로운 클래스 생성

## 시간 처리

**시간은 단순한 것처럼 보일지 모르지만, 실제로 시간을 나타내는 것은 상당히 까다롭다.**

## 정수로 시간을 나타내는 것은 문제가 될 수 있다

- 정수는 매우 일반적인 유형이기 때문에 시간을 나타내는 데 코드가 오용되기 쉽다
- `순간으로서의 시간인지, 양으로서의 시간인지 명확하게 표현하라.`
  - 적절한 자료구조 활용하기
  - 언어에서 제공하는 기능을 통해 양으로서의 시간과 순간으로서의 시간의 구분
    - e.g. Java.time Instant, Duration
- `단위를 명확히 표현하라.`
- `시간대(timezone) 처리 오류를 주의하라`

## 데이터에 대한 진실의 원천을 하나만 가져야 한다(SSOT)

- `SSOT` : Single Source of Truth
- `기본 데이터를 유일한 진실의 원천으로 사용하라`
  - 기본 데이터로 파생되는 데이터. 즉, 계산이 필요한 데이터는 기본 데이터를 활용하고 오용하기 어렵도록 하라
    - e.g. 생성자 밖에서 계산된 값을 넣는 게 아닌, 생성자 함수 내에서 값을 계산하기
- `하위 수준의 문제를 하나의 문제로 분할하고 이를 SSOT로 활용하라`
  - e.g. 직렬화, 역직렬화 시 같은 로직을 사용해야한다면, 예를들어 IntFormat 객체를 만들고 그 객체 안에 각 직렬화, 역직렬화 로직을 작성하라. (한 곳에 응집)
  - **운으로 이걸 맞추려고 하지 마라.**

# 8. 코드를 모듈화하라

모듈화의 주된 목적 중 하나는 변경과 재구성이 용이한 코드를 작성하는 것이다.

이후 요구 사항이 변경된다면, 코드베이스에서 그 요구 사항이나 기능과 관련된 부분만 수정하면 된다.

## 의존성 주입의 사용을 고려하라

- 하드 코드화된 의존성은 문제가 될 수 있다 (딱딱한 의존성)
- `의존성 주입 프레임워크를 사용하라`
  - 의존성을 주입하는 코드를 직접 작성하는 건 반복적이고 매우 힘들다.
  - 의존성 주입 프레임워크를 활용하면 이를 개선할 수 있다.
  - 하지만 주의해서 사용하지 않으면 파악하기 어려운 코드가 만들어질 수 있으니 주의하자.
- `정적 매달림(static cling)`
  - 정적인 함수를 많이 사용하면 단위 테스트에서 테스트 더블을 사용하기 어렵다.

## 가능한 경우 인터페이스에 의존하라

인터페이스를 사용하면 의존성 주입을 활용하기 쉽다.

- `구체적인 구현에 의존하면 적응성이 제한된다.`
  - 가능한 경우 인터페이스에 의존하라

## 클래스 상속에 주의하라

- **상속 대신 `합성`(composition)을 활용하라**
- `클래스 상속은 때때로 문제가 될 수 있다`
  - 부모 클래스의 함수 호출에서 오는 사이드이펙트 (호출이 막혀있지 않음)
- `상속은 추상화 계층에 방해가 될 수 있음`
  - 클래스 상속은 슈퍼클래스의 모든 기능을 상속하므로,
    원하는 것보다 더 많은 기능을 노출할 수도 있고 이로 인해 추상화 계층이 복잡해지고 구현 세부 정보가 드러날 수 있다.
- `상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다`
  - 클래스 상속은 상위 상속 구조를 바꾸기 어렵다.
  - e.g. 요구사항이 변경되어 IntFileReader 가 CsvFileHandler 대신 SemicolonFileHandler를 상속하도록 바꾸기

## 진정한 is-a 관계는 어떤가?

- 두 클래스가 is-a 관계를 맺고 있다면 상속이 타당할 수 있다
- 하지만 클래스 간 상속은 여전히 주의할 점이 있다.
  - `취약한 베이스 클래스 문제`
    - 슈퍼클래스가 수정되면 서브클래스에 사이드이펙트 발생 가능
  - `다이아몬드 문제`
    - 다중 상속에서 서로 동일한 함수를 갖고 있는 경우 충돌
  - `문제가 있는 계층 구조`
    - 많은 언어에서 단일 상속만 가능한데, 논리적으로 둘 이상의 클래스에 속할 때 머리가 아파온다.
    - 그냥 인터페이스 써라

## 클래스는 자신의 기능에만 집중해야 한다

모듈화의 핵심 목표는 요구 사항이 변경됐을 때 직접 관련된 부분만 수정하는 것이다.

단일 개념이 단일 클래스 내에 완전히 포함된 경우라면, 그 클래스만 수정하면 된다.

- `다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다`
  - 해당 함수가 여기 있는 것이 적절한지 항상 고민하고 적절한 위치로 이동시켜라
  - → **자신의 기능에만 충실한 클래스를 만들어라**
- `디미터의 법칙(The Law of Demeter, LoD)`
  - 한 객체가 다른 객체의 내용이나 구조에 대해 가능한 한 최대한으로 가정하지 않아야 한다.
  - 한 객체는 직접 관련된 객체와만 상호작용해야 하낟.
  - 클래스는 서로에 대한 어느 정도의 지식을 필요로 할 때도 있지만, 가능한 한 이것을 최소화하는 것이 코드 모듈화 유지, 적응성 그리고 유지관리성 개선 면에서 좋을 때가 많다.
- 관련 있는 데이터는 함께 캡슐화하라

## 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

- 반환 유형 너무 세부적인 내용을 유출하면 사용하는 측에서 해당 유형의 세부사항을 모두 파악하고 있어야 하기 때문에 작업하기 어려워진다.
- `추상화 계층에 적합한 유형을 반환하라`
  - 오용하기 어려운 유형으로! 명확하게!
  - 이 클래스를 사용하는 다른 개발자에게 노출되는 개념이 최소가 되도록 노력하라
  - e.g.
    - 요청이 성공하거나 다음 이유 중 하나로 인해 실패할 수 있다.
      - 사용자가 존재하지 않는다
      - 서버에 연결할 수 없는 등의 일시적인 오류가 발생했다.
    - 프로필 사진을 나타내는 데이터의 바이트
- `예외 처리 시에서도 세부 사항 유출하지 않도록 주의하기`
  - 추상화 계층에 적절한 예외를 만들라
  - 특정 구현에 종속된 예외 처리를 피하라
  - 예외에 구현 세부사항을 담지 말고 추상화해서 던져라
    - e.g. 텍스트 요약 기능을 제공하는 인터페이스 세부 구현에서 텍스트 예측 모델을 활용하는 경우를 예시로 텍스트 예측 오류 발생 시 세부사항 대신에 좀 더 추상화된 텍스트 요약 오류를 반환
