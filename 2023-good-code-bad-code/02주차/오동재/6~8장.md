# 6. 예측가능한 코드를 작성하라

## 매직값을 반환하지 마라

정상적인 값처럼 처리되기 때문에 상위코드에서 매직값을 인식하지 못하면 버그를 유발할 수 있고 버그가 발생한 위치를 찾기 어려움.

⇒ 널, 옵셔널, 오류 등을 반환하여 코드가 정상적으로 작동하지 못하도록 해라.

## 널 객체 패턴을 적절히 사용하라

> **_인터페이스는 구현하지만 아무 일도 하지 않는 객체_**

null 값을 체크하지 않아도 되기 때문에 코드가 깔끔해진다.

```java
// 널 객체 패턴 사용하지 않은 경우
Employee e = DB.getEmployee("Bob");
if (e != null && e.isTimeToPay(today)) {
    e.pay();
}
```

```java
// 널 객체 패턴 사용한 경우
Employee e = DB.getEmployee("Bob");
if (e.isTimeToPay(today)) {  // null 체크 삭제
    e.pay();
}
```

### 문자열에도 적용할 수 있지만 오류가 날 수도

문자열의 경우 null대신 “”를 반환함으로써 널 객체 패턴을 적용할 수 있다는 의견이 있다.

하지만 이는 문자열을 다룰 때 오류를 찾지 못하므로 문제가 발생할 수 있다.

### 복잡한 널 객체 패턴은 예상을 벗어날 수 있다.

## 예상치 못한 부수효과(side effect)를 피하라

> 부수효과 : 어떤 함수의 호출이 외부에 초래한 상태 변화

해당 함수 사용이 익숙치않다면 문제가 발생할 수 있음.

한 데이터에 대해서 멀티 스레딩으로 인해 문제가 발생할 수도 있음.

## 입력 매개변수를 수정하는 것에 주의하라

⇒ 변경하기 전에 복사하라

## 미래를 위해 enum 사용하기

하지만 미래에 추가될 수 있는 열것값을 암시적으로 처리하는 것은 위험하다.

```java
enum EMOTION {
	HAPPY,
	SAD
}

// 긍정적인 감정인지 판단하는 함수
Boolean isEmotionGood(EMOTION emotion){
	if (emotion == HAPPY){
		return true;
	}
	return false;
}

// 추후 enum 추가

enum EMTION{
	HAPPY,
	SAD,
	MOVED
}

// 이러면 감동받은 감정도 isEmotionGood 함수 사용시 부정적인 감정으로 인식
```

⇒ 모든 경우를 처리하는 스위치문을 사용하라

# 7. 코드를 오용하기 어렵게 만들라

코드가 오용하기 쉽게 작성되면 조만간 오용될 수 있고 그럼 소프트웨어가 올바르게 작동하지 않을 수 있다.

## 불변 객체 만들기

### 가변 객체의 문제점

- 추론하기 어려움
- 다중 스레드에서 문제가 발생할 수 있음.
  한 스레드가 객체를 읽는동안 다른 스레드가 객체를 수정하면 오류가 발생

⇒ 객체를 생성할 때만 값을 할당하자

⇒ 혹은 불변성에 대한 디자인 패턴을 사용.

1. 빌더 패턴
2. 쓰기 시 복사 패턴 (copy-on-write)

## 객체를 깊은 수준까지 불변적으로 만드는 것을 고려

> deep mutability(깊은 가변성)으로 인해 클래스가 실수로 가변될 수 있음

클래스 안에서 다른 클래스를 참조하고 있다면 참조하고 있는 클래스가 변경됐을 때 객체가 변할 수 있음

```java
class TextOptions{
	private final List<Font> fontFamily // List 객체를 참조중
}
// 객체 외부에서 fontFamily에 접근하여 수정할 수 있음
```

### 해결책

1. 방어적으로 복사하기

fontFamily를 객체 외부에 반환할 때 복사 후 반환하면 됨

```java
List<Font> getFontFamily(){
	return List.copyOf(fontFamily);
}
```

2. 불변적 자료구조 사용하기

ImmutableList 등 불변 자료구조 사용하기
js의 Immutable.js 등

## 지나치게 일반적인 데이터 유형 피하기

위치를 (x,y)로 나타낸다고 할 때, List<List<Double>>로 나타내면 데이터에 대한 설명이 없으면 x와 y의 순서가 바뀐다거나 많은 인자가 들어간다거나 오용되기 쉬움.

그리고 패러다임은 퍼지기 쉬움. 한 번 저렇게 설정하면 다른 함수에서 이를 입력할 때 등등 퍼지기 쉬움

pair자료형도 마찬가지. 순서의 의미를 명시하지않으면 오용하기 쉬움

### 해결책

전용 유형 사용

당장은 임시 데이터 유형을 사용하는 게 빠를 수 있지만 중장기적으로 보면 전용 유형ㅇ르 만들어 사용하는 게 좋음

```java
class LatLong{
	private final Double latitude;
	private final Double longitude;
}
// 위와 같은 느낌으로 좌표 객체 사용
```

## 시간 처리

### 문제들

1. 한 순간의 시간인가, 아니면 시간의 양인가?
2. 일치하지 않는 단위 (millisecond, second, microsecond)
3. 시간대 처리 오류

### 해결책

적절한 자료구조 사용하기

java.time같은 라이브러리에서 duration, instant라는 클래스를 제공.

⇒ 시간을 해당 자료구조로 표현함으로써 문제들을 해결할 수 있음.

## 데이터의 진실의 원천은 하나

### 데이터 종류

1. 기본 데이터(primary data) : 코드에서 제공해야 할 데이터
2. 파생 데이터(derived data) : 기본 데이터에 기반해서 코드가 계산할 수 있는 데이터

> 대변이 5달러이고 차변이 2달러이면 잔고는 3달러이다.

> 대변이 10달러이고 차변이 2달러인데 잔고가 3달러인 것은 모순이다.

### 해결책

기본 데이터를 사용하여 파생 데이터 쓰기.

```java
balance = credit-debit // 이렇게 쓰면 안되고

// 이렇게 쓰자
Double getBalance(){
	return credit - debit;
}
```

> 데이터 계산에 비용이 많이 드는 경우

lazily and cache

```java
// credit을 구하는 시간이 오래걸린다면

// 해당 함수에서는 credit을 구하고 저장한 후 리턴한다.
Double getCredit(){
	if (cachedCredit == null) {
		cachedCredit = /* 크레딧 구하는 로직 */;
		return cachedCredit
	}
}

Double getBalance(){
	return getCredit() - getDebit();
}
```

## 논리에 대한 진실의 원천을 하나만 가져야 한다

ex. 정제되지 않은 값을 인코딩/디코딩 하는 함수를 작성한다고 할 때, 두 함수의 로직이 같은 논리를 역으로 구현해야 함

### 해결책

인코딩과 디코딩을 재사용이 가능한 하나의 코드 계층으로 구현.
class 하나의 인코딩과 디코딩 함수를 구현하고 구분자, 진법 등 통일해야하는 내용은 상수로 지정하여 사용할 수 있다.

# 8. 코드를 모듈화하라

## 의존성 주입

하드코드화된 의존성은 의존하는 객체를 사용할 수 없는 경우 많은 것이 제한됨

⇒ 의존성 주입을 사용하자

## 인터페이스에 의존

구체적인 구현에 의존하면 적응성이 제한됨

> dependency inversion principle(의존성 역전 원리) : 구체적인 구현보다 추상화에 의존하는 것이 낫다.

## 클래스 상속의 문제

### 추상화 계층에 방해가 될 수 있음

상속하는 클래스의 모든 기능을 상속하기 때문에 원하는 것보다 더 많은 기능을 노출함

⇒ 구현 세부정보가 드러날 수 있음

### 적응성 높은 코드의 작성을 어렵게 만듦

상속을 사용하면 코드 수정이 어려울 수 있음

### 해결책

구성을 사용해라

## 클래스는 자신의 기능에만 집중

다른 클래스와 지나치게 연관되지 않고 자신의 기능에만 충실한 클래스 만들기

## 관련있는 데이터는 함께 캡슐화

- 캡슐화되지 않은 데이터는 취급이 어려울 수 있음

## 구현 세부 정보가 유출되지 않도록 하라

- return 혹은 예외처리 시 구현 세부 정보가 유출되지 않도록 하자

⇒ 추상화 계층에 적합한 유형을 만들자

계층별로 다르게 처리하도록 해야 함
