- [7. 코드를 오용하기 어렵게 만들라](#7----)
    - [7.1 불변 객체로 만드는 것을 고려하라](#71-----)
        - [7.1.1 가변 클래스는 오용하기 쉽다](#711----)
        - [7.1.2 해결책: 객체를 생성할 때만 값을 할당하라](#712------)
        - [7.1.3 해결책: 불변성에 대한 디자인 패턴을 사용하라](#713------)
            - [빌더 패턴](#-)
            - [쓰기 시 복사 패턴](#---)
        - [7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라](#72-------)
        - [7.2.1 깊은 가변성은 오용을 초래할 수 있다](#721------)
        - [7.2.2 해결책: 방어적으로 복사하라](#722---)
        - [7.2.3 해결책: 불변 자료구조를 사용하라](#723----)
    - [7.3 지나치게 일반적인 데이터 유형은 피하라](#73-----)
        - [7.3.1 지나치게 일반적인 유형은 오용될 수 있다](#731------)
            - [패러다임은 퍼지기 쉽다](#--)
        - [7.3.2 페어 유형은 오용하기 쉽다](#732----)
        - [7.3.3 해결책: 전용 유형 사용](#733----)
    - [7.4 시간 처리](#74--)
        - [7.4.1 정수로 시간을 나타내는 것은 문제가 될 수 있다](#741--------)
            - [한순간의 시간인가, 아니면 시간의 양인가?](#----)
            - [일치하지 않는 단위](#--)
            - [시간대 처리 오류](#--)
        - [7.4.2 해결책: 적절한 자료구조를 사용하라](#742----)
            - [양으로서의 시간과 순간으로서의 시간의 구분](#----)
            - [더 이상 단위에 대한 혼동이 없다](#-----)
            - [시간대 처리 개선](#--)
    - [7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다](#75-------)
        - [7.5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다](#751----------)
        - [7.5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라](#752-------)
            - [데이터 계산에 비용이 많이 드는 경우](#-----)
    - [7.6 논리에 대한 진실의 원천을 하나만 가져야 한다](#76-------)
        - [7.6.1 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다.](#761-----------)
        - [7.6.2 해결책: 진실의 원천은 단 하나만 있어야 한다](#762-------)

# 7. 코드를 오용하기 어렵게 만들라

- 비합리적이거나 애매한 가정에 기반해 코드가 작성되거나, 다른 개발자가 잘못된 일을 하는 것을 막지 못할 때 코드는 오용되기 쉽다.
- 코드를 잘못 사용할 수 있는 일반적인 경우는 다음과 같다.
    - 호출하는 쪽에서 잘못된 입력 제공
    - 다른 코드의 부수 효과
    - 정확한 시간이나 순서에 따라 함수를 호출하지 않음
    - 관련 코드에서 가정에 맞지 않게 수정이 이루어짐

- 설명서나 사용 지침이 도움이 될 수는 있지만 이는 세부 조항이라 전적으로 의존할 수는 없다
- 코드를 오용하기 어렵게 설계하고 작성하는 것이 중요하다.

- API : EUHM(easy to use and hard to misuse)

## 7.1 불변 객체로 만드는 것을 고려하라

- 가변 객체는 문제를 일으킬 수 있다
    - 가변 객체는 추론하기 어렵다
        - 객체가 여기저기 전달되면 객체가 어디서 어떻게 변경되는지 추적하기 어렵다
    - 가변 객체는 다중 스레드에서 문제가 생길 수 있다

- 객체를 불변으로 만드는 것이 항상 가능한 것도 아니고, 항상 옳은 것도 아니다
- 따라서 기본적으로 불변 객체를 만들되 필요한 곳에서만 가변적이게 하는 것이 바람직하다

### 7.1.1 가변 클래스는 오용하기 쉽다

- 가변 클래스는 오용하기 쉽다

### 7.1.2 해결책: 객체를 생성할 때만 값을 할당하라

- 모든 값이 객체 생성 시에 제공되고, 그 이후로 변경할 수 없게 하면 클래스를 불변으로 만들 수 있다
    - 그에 따라 오용도 방지할 수 있다

- 클래스 내에서 변수를 정의할 때 내부에서도 변경이 불가능하게 만들 수 있다
    - `const`, `final`, ...

- 만약 특정 값만 재정의하고 싶다면 쓰기 시 복사(copy-on-write) 패턴을 사용할 수 있다
- 만약 모든 옵션 값이 필요한 것이 아니라면 빌더 패턴이나 쓰기 시 복사 패턴을 활용하는 것이 좋다

### 7.1.3 해결책: 불변성에 대한 디자인 패턴을 사용하라

- 일부 값이 반드시 필요하지 않거나, 불변 객체의 가변적인 버전이 필요한 경우 빌더 패턴이나 쓰기 시 복사 패턴을 활용하면 좋다

#### 빌더 패턴

- 빌더 패턴은 클래스를 두 개로 나누는 효과를 갖는다
    - 값을 하나씩 설정할 수 있는 빌더 클래스
    - 빌더에 의해 작성된 불변적인 클래스

- 빌더 패턴을 사용할 때도 필수적인 값은 생성자를 통해 받는다
- 빌더 패턴은 값의 일부(또는 전체)가 선택 사항일 때 불변 객체를 만드는 좋은 방법이다

#### 쓰기 시 복사 패턴

- 일부 값만 수정하고 싶지만 불변성은 유지하고 싶을 때 쓰기 시 복사 패턴이 유용하다

### 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 깊은 가변성(deep mutability) 때문에 클래스가 실수로 가변이 될 수도 있다

### 7.2.1 깊은 가변성은 오용을 초래할 수 있다

- 내부적으로 참조(reference)를 가지고 있으면 문제가 될 수 있다
- 이러한 참조가 여러 곳에서 전달되면 추적하기 어려운 데이터 변경이 발생할 수 있다
- 따라서 애초에 불변으로 만들어 이러한 문제를 피하는 것이 좋다

### 7.2.2 해결책: 방어적으로 복사하라

- 클래스가 생성될 때, 게터 함수를 통해 반환할 때 복사본을 만든다
- 하지만 다음과 같은 문제가 있다
    - 복사하는 데 비용이 많이 들 수도 있다
    - 클래스 내부에서 발생하는 변경은 막아주지 못한다

### 7.2.3 해결책: 불변 자료구조를 사용하라

- 불변적인 자료 구조를 사용한다
- 이를 이용하면 복사본을 만들 필요가 없다

## 7.3 지나치게 일반적인 데이터 유형은 피하라

- 정수, 문자열, 리스트 등은 많은 것들을 나타낼 수 있다
- 데이터 유형 자체만으로는 무언가를 설명할 수 없고, 가질 수 있는 값에 대해서도 관대하다는 것을 의미한다.
- 설명이 부족하고 허용하는 범위가 넓을수록 코드 오용은 쉬워진다

### 7.3.1 지나치게 일반적인 유형은 오용될 수 있다

- 일반적인 유형을 사용해 특정 자료 구조를 표현했을 때 다음과 같은 문제가 생길 수 있다.
    - 유형 자체로는 아무 것도 알 수 없다
    - 개발자가 해당 자료 구조를 사용할 때 혼동하기 쉽다
    - 형식 안정성이 없다

- 즉, 코드 계약의 세부 조항에 대한 자세한 지식, 그리고 정확히 따르지 않으면 해당 자료 구조를 올바르게 사용할 수 없다
- 다른 개발자가 세부 조항에 의지하는 것은 신뢰할 만한 방법이 아니다

#### 패러다임은 퍼지기 쉽다

- 처음에는 이 함수에만 임시변통의 방법을 사용할 것이라고 생각하지만 이러한 것들은 퍼져나가기 쉽다
- 즉, 임시변통으로 작성된 코드는 다른 코드 전반에 퍼지는 경향이 있다

### 7.3.2 페어 유형은 오용하기 쉽다

- 이 또한 일반적이라 유형만으로 어떤 자료를 나타내는지 알 수 없고, 혼동하기 쉽다

### 7.3.3 해결책: 전용 유형 사용

- 전용 클래스를 정의하는 것은 많은 노력이 들어가는 것처럼 보이지만 실제론 그렇지 않고 코드의 가독성도 올려주고 버그의 가능성도 줄여준다
- 무언가 구체적인 것을 나타낼 때 적은 노력을 추가로 들여서 전용 유형을 정의하는 것이 더 나을 때가 많다. 코드가 훨씬 명확해지고 오용하기 어렵기 때문에 중장기적으로 보면 시간이 절약된다

## 7.4 시간 처리

- 시간을 나타내는 것은 까다롭다
    - 절대적인 시간, 상대적인 시간 모두 사용한다
    - 특정 시점이 아니라 시간의 양을 나타내는 경우도 있다
    - 표준 시간대, 써머 타임, 윤년, 윤초 등의 개념도 있다
- 시간을 다룰 때 코드를 잘못 사용하고 혼동을 일으킬 여지가 많다

### 7.4.1 정수로 시간을 나타내는 것은 문제가 될 수 있다

- 시간을 나타낼 때는 일반적으로 정수를 사용한다.
- 정수를 사용해 시각과 시간의 양을 모두 나타낸다
- 정수는 일반적인 유형이라 이를 사용하면 코드가 오용되기 쉽다

#### 한순간의 시간인가, 아니면 시간의 양인가?

- 정수만 보고 시각인지, 시간의 양인지 알기 어렵다

#### 일치하지 않는 단위

- 시간의 단위도 다양해 정수만으로는 어떤 단위인지 알기 어렵고 실수하기 쉽다.

#### 시간대 처리 오류

- 순간으로서의 시간은 보통 유닉스 시간 이후 지나간 초를 사용하는데 타임스탬프(timestamp)라고 부른다
- 날짜와 시간 사이에는 시간대라는 간극이 존재해 이를 잘 다루지 않으면 문제가 생길 수 있다.

### 7.4.2 해결책: 적절한 자료구조를 사용하라

- 결국 시간을 정수 하나로 나타내려니 문제가 생기는 것이므로 적절한 자료 구조를 사용하면 이를 해결할 수 있다.

#### 양으로서의 시간과 순간으로서의 시간의 구분

- 타임으로 순간인지, 시간의 양인지 구분한다

#### 더 이상 단위에 대한 혼동이 없다

- 단위가 유형 내에 캡슐화되면 단위가 헷갈릴 일도 없고 실수할 여지도 없다

#### 시간대 처리 개선

- 시간을 다루는 라이브러리는 날짜를 정확한 순간과 연결하지 않고 날짜를 나타낼 수 있는 방법을 제공한다.

## 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다

- 코드는 여러 데이터를 처리하는 경우가 많다.
    - 기본 데이터(primary data) : 코드에 필수적으로 제공해야 하는 데이터
    - 파생 데이터(derived data) : 기본 데이터에 기반해서 만들어낸 뎅티ㅓ

- 기본 데이터는 프로그램의 진실의 원천(source of truth)가 된다.
- 이는 상태를 추적하기 위해 저장되어야 하는 유일한 값이다

### 7.5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다

- 기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성할 때, 논리적으로 잘못된 상태가 발생할 수 있다
    - 기본 데이터와 파생 데이터 모두 저장하는 경우
- 논리적으로 잘못된 상태가 발생할 수 있는 코드를 작성하면 코드의 오용이 너무 쉬워진다

### 7.5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라

- 필요할 때에만 파생 데이터를 계산하는 것이 더 안전하다
- 데이터 모델이 논리적으로 잘못된 상태를 허용하는지에 대해 숙고해볼 만한 가치가 있다

#### 데이터 계산에 비용이 많이 드는 경우

- 파생된 값을 계산하는 데 많은 비용이 든다면 지연 평가를 사용하는 것도 좋은 방법이다

## 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다

- 진실의 원천(source of truth)는 코드에 포함된 논리에도 적용된다

### 7.6.1 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다.

- 어떠한 로직에 대한 진실의 원천이 여러 개 있으면 추후에 다른 개발자가 하나만 수정해버릴 수도 있다

### 7.6.2 해결책: 진실의 원천은 단 하나만 있어야 한다

- 로직에 대한 진실의 원천이 단 하나만 존재한다면 로직이 일부만 수정되는 문제를 피할 수 있다
- 두 개의 다른 코드가 수행하는 논리가 일치해야 할 때 그렇게 되도록 운에 맡겨서는 안 된다
- 다른 개발자는 코드가 내포하고 있는 가정을 인식하지 못할 수도 있다
- 중요한 논리에 대해 진실의 원천이 하나만 존재하도록 하면 코드가 훨씬 더 견고해진다

