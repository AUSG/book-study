- [6.1 매직값을 반환하지 말아야 한다](#61----)
    - [6.1.1 매직값은 버그를 유발할 수 있다](#611-----)
    - [6.1.2 해결책: 널, 옵셔널 또는 오류를 반환하라](#612------)
    - [6.1.3 때때로 매직값이 우연히 발생할 수 있다](#613------)
- [6.2 널 객체 패턴을 적절히 사용하라](#62-----)
    - [6.2.1. 빈 컬렉션을 반환하면 코드가 개선될 수 있다](#621-------)
    - [6.2.2 빈 문자열을 반환하는 것도 때때로 문제가 될 수 있다](#622---------)
    - [6.2.3 더 복잡한 널 객체는 예측을 벗어날 수 있다](#623--------)
    - [6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다](#624---------)
- [6.3 예상치 못한 부수 효과를 피하라](#63-----)
    - [6.3.1 분명하고 의도적인 부수 효과는 괜찮다](#631-----)
    - [6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다](#632--------)
    - [6.3.3 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라](#633--------)
- [6.4 입력 매개변수를 수정하는 것에 주의하라](#64-----)
    - [6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다](#641-------)
    - [6.4.2 해결책: 변경하기 전에 복사하라](#642----)
- [6.5 오해를 일으키는 함수는 작성하지 말라](#65-----)
    - [6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다](#651----------)
    - [6.5.2 해결책: 중요한 입력은 필수 항목으로 만들라](#652------)
- [6.6 미래를 대비한 열거형 처리](#66----)
    - [6.6.1 미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다](#661------------)
    - [6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라](#662-------)
    - [6.6.3 기본 케이스를 주의하라](#663---)
    - [6.6.4 주의 사항: 다른 프로젝트의 열거형에 의존](#664------)
- [6.7 이 모든 것을 테스트로 해결할 수는 없는가?](#67-------)

## 6.1 매직값을 반환하지 말아야 한다

- 개발자는 코드를 사용하는 방법에 대한 정신 모델을 구축한다.
- 실제 코드와 정신 모델이 일치하지 않으면 문제가 될 수 있다
- 따라서 예측 가능한 코드를 작성하는 것이 중요하다
    - 이는 무언가를 분명하게 하는 것일 때가 많다

### 6.1.1 매직값은 버그를 유발할 수 있다

- 매직값은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가진다
- 일반적인 값과 비슷하게 생겨 특별한 의미를 인지하지 못해 정상적인 반환값이라 오해하기 쉽다

- 과거에는 매직값을 반환하는데 어느 정도 합리적인 이유가 있었다
- 하지만 일반적으로 매직값을 반환하면 예측을 벗어날 위험이 있으므로 피하는 것이 좋다
- 또한, 단위 테스트 코드가 매직값이 문제가 되는 경우를 발견하지 못할 수도 있다
    - 매직값을 반환하는 경우는 특별한 경우이다
    - 특별한 경우를 예상하지 못한 경우 그에 대한 테스트도 없을 가능성이 크고 그에 따라 이를 잡는 단위 테스트가 없을 수도 있다

### 6.1.2 해결책: 널, 옵셔널 또는 오류를 반환하라

- 매직값 반환의 문제점은 호출하는 쪽에서 계약의 세부 조항을 알아야 한다는 것이다
- 이를 명백하게 만드는 방법은 널이 가능한 타입이나 옵셔널 값을 반환하는 것이다
- 다만, 값이 없는 이유를 명시적으로 전달하지 않으므로 이를 해결하려면 오류 전달 기법을 활용하는 것이 좋다

### 6.1.3 때때로 매직값이 우연히 발생할 수 있다

- 매직값은 정상적인 반환 유형을 가지므로 우연히 정상 상황에 반환될 수도 있다
- 매직값이 반환되지 않을 것이란 가정은 결국 함수가 어떻게 호출되고, 사용될 것인지에 대한 가정인 경우가 많다
    - 하지만 함수를 작성하는 입장에서 이를 완벽하게 예측하는 것은 불가능하다

- 매직값 대신 널이나 옵셔널, 또는 오류를 사용하면 호출자에게 이 함수는 특정 상황을 처리하지 못 할 수도 있다는 것을 명백하게 알릴 수 있다

## 6.2 널 객체 패턴을 적절히 사용하라

- 널 객체를 사용하면 널값으로 인해 다른 시스템에 문제를 일으키는 것을 피할 수 있다.
- 또한 호출 코드가 간단해지는 경우도 있다.
- 하지만 이를 부적절하게 사용하면 예측을 벗어나는 동작을 하거나 발견하기 어려운 미묘한 버그가 발생할 수도 있다

### 6.2.1. 빈 컬렉션을 반환하면 코드가 개선될 수 있다

- 값이 없는 경우와 값이 빈 경우를 구분할 필요가 없다면 널 대신 빈 컬렉션을 반환하는 것이 코드에 도움이 될 수도 있다

### 6.2.2 빈 문자열을 반환하는 것도 때때로 문제가 될 수 있다

#### 문자들의 모음으로서의 문자열

- 문자열이 특별한 의미를 가지지 않는다면 널 대신 빈 문자열을 반환해도 괜찮다.

#### ID로서의 문자열

- 만약 문자열이 특정한 의미를 가진다면 결국 그 값이 널이라는 것이 의미를 가지게 되므로 널 대신 빈 문자열을 반환하는 것을 주의해야 한다.

### 6.2.3 더 복잡한 널 객체는 예측을 벗어날 수 있다

- 복잡한 널 객체는 호출자에게 조금의 도움을 줄 수는 있지만 결국 예상을 벗어나는 동을 일으켜 더 큰 문제를 일으킬 수 있다
    - 널이 반환될 수 있다는 것은 큰 단서 중 하나다

### 6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다

- 널 객체 전용 인터페이스나 클래스를 정의하면 호출자가 널 객체인지를 확인할 수 있게 된다.
- 하지만 여전히 호출자가 이러한 사실을 모를 수도 있기 때문에 큰 개선은 아니다
- 따라서 널 객체는 예상을 벗어나는 동작을 할 가능성은 없는지 의식적으로 생각해봐야 한다.

## 6.3 예상치 못한 부수 효과를 피하라

- 부수 효과는 어떤 함수의 호출이 외부에 초래한 상태 변화를 의미한다
- 부수 효과는 없앨 수 없다. 일부 함수는 부수 효과가 필요하다
- 중요한 것은 호출자가 부수효과가 발생할 것을 예상할 수 있는지다.
- 클래스를 불변으로 만들면 부수효과의 가능성을 최소화할 수 있다
- 부수효과를 피할 수 없는 경우 이를 명백하게 만들어야 한다

### 6.3.1 분명하고 의도적인 부수 효과는 괜찮다

- 일부 함수는 부수 효과를 의도한다
    - 즉, 부수 효과가 발생하기를 기대한다
- 이러한 점이 명백하면 괜찮다.

### 6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다

#### 부수 효과는 비용이 많이 들 수 있다

- 호출자는 비용이 많이 들 것이라 예상하지 않았지만 실제 내부 동작에서 비용이 많이 들 수도 있다.

#### 호출한 쪽의 가정을 깨트리기

- 호출한 쪽에선 부수 효과가 없을 것이라 예상했지만 그렇지 않다면 문제가 될 수 있다.
- 만약, 이러한 부수 효과가 어쩔 수 없는 것이라면 이런 부수 효과가 발생한다는 사실을 호출자에게 확실하게 알려야 한다.

#### 다중 스레드 코드의 버그

- 다른 스레드가 공유 자원에 접근하는 경우 스레드에 의한 부수 효과가 발생할 수 있다.
- 하지만 이러한 사실이 명백하게 드러나지 않으면 다중 스레드 환경에서 문제가 될 수 있다.

### 6.3.3 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라

- 가장 좋은 방법은 부수 효과를 일으키지 않는 것이다.
- 하지만 그렇지 않다면 호출자가 부수 효과를 에상할 수 있게 해야 한다.
- 일반적으로 정보를 얻는 함수는 부수 효과를 일으키지 않을 것이라 에상한다.
    - 만약 그렇지 않다면 분리하거나, 드러내야 한다.

## 6.4 입력 매개변수를 수정하는 것에 주의하라

### 6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다

- 입력 매개변수에 전달된 객체는 호출 뒤에 재사용될 가능성이 크다
- 입력 매개변수를 수정하는 것은 부수 효과다
- 보통 입력 매개변수가 수정될 것이라 예상하지 않는다.

### 6.4.2 해결책: 변경하기 전에 복사하라

- 어쩔 수 없이 값을 변경해야 한다면 변경 전에 복사해서 써라
- 성능 상의 이유 등으로 입력 매개변수를 수정해야 한다면 이를 분명히 하는 것이 좋다

## 6.5 오해를 일으키는 함수는 작성하지 말라

- 코드 계약의 명백한 부분에 오해의 소지가 있다면 더 문제가 될 수도 있다.

### 6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다

- 매개변수가 없더라도 호출할 수 있고, 해당 매개변수가 없다면 아무 일도 하지 않는 함수는 오해의 소지가 있을 수 있다.
    - 함수를 호출하면 항상 어떠한 작업을 해줄 것이라 예상하고 있을 수 있다

### 6.5.2 해결책: 중요한 입력은 필수 항목으로 만들라

- 호출 쪽이 불편해지더라도 오해의 소지를 없애는 것이 바람직하다
- 함수에게 어떤 매개변수가 반드시 필요한 경우 필요하다고 명시하는 것이 더 안전하고, 명백하다.

## 6.6 미래를 대비한 열거형 처리

- 의존하는 코드에 부실한 가정을 해도 예상을 벗어나는 결과를 초래할 수 있다.

- 열거형이 간결한 추상화 계층을 막는다는 주장도 있다
- 다형성이 더 나은 방식이라 주장한다
    - 클래스 내에 동작을 캡슐화

- 열거형을 처리할 때 열거형에 더 많은 값이 추가될 수 있다는 사실을 기억해야 한다

### 6.6.1 미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다

- `else`나 `default` 문 등을 통해 미래에 추가될 수 있는 열거값을 암묵적으로 처리하면 문제가 될 수 있다

### 6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라

- 열거형을 다룰 때는 모든 열거형을 명시적으로 처리하는 것이 좋다
- 새로운 열거형이 추가되면 테스트나 컴파일이 실패되도록 하라

### 6.6.3 기본 케이스를 주의하라

- `default` 문 또한 암시적으로 새로운 값을 처리하므로 문제가 될 수 있다

#### 기본 케이스에서 예외 발생

- 일부 컴파일러는 모든 열거형이 `switch` 문에서 다루어지지 않으면 경고를 준다
- 이러한 계속 경고를 받으려면 `default`에서 예외를 던지지 말고 그 밖에서 던지는 것이 좋다

### 6.6.4 주의 사항: 다른 프로젝트의 열거형에 의존

- 다른 프로젝트의 열거형에 의존하는 경우 더 주의해야 한다

## 6.7 이 모든 것을 테스트로 해결할 수는 없는가?

- 테스트가 이러한 모든 문제를 잡아내므로 이런 노력은 시간 낭비라는 주장이 있다.
    - 하지만 이는 현실에서는 별로 효과가 없는 이상주의적인 주장이다

- 코드를 작성하는 시점에는 코드를 어떻게 테스트할지 제어할 수 있다
- 하지만 내 코드를 고치고, 사용하는 것은 결국 다른 개발자이고 이들이 오해하지 않도록 하기 위해서 예상을 벗어나지 않는 코드를 짜는 것이다
    - 어떤 개발자들은 테스트를 제대로 돌리지 않을 수도 있다
    - 테스트 코드가 실제 상황을 항상 정확하게 테스트하는 것은 아니다
        - 특히 목을 사용할 때 더 그런데, 목은 생각하는 바대로 프로그래밍 하므로 특정 상황을 에상하지 못하면 목과 실제 코드 사이의 괴리가 생길 수 있다
    - 어떤 코드들은 테스트 자체가 너무 어렵다

- 테스트는 매우 중요하다
- 하지만 직관적이지 않거나 예상을 벗어나는 코드를 테스트로 방지하기는 어렵다
