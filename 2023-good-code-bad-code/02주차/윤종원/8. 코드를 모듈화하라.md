- [8. 코드를 모듈화하라](#8--)
    - [8.1 의존성 주입의 사용을 고려하라](#81----)
        - [8.1.1 하드 코드화된 의존성은 문제가 될 수 있다](#811-------)
        - [8.1.2 해결책: 의존성 주입을 사용하라](#812----)
            - [의존성 주입 프레임워크](#--)
        - [8.1.3 의존성 주입을 염두에 두고 코드를 설계하라](#813------)
    - [8.2 인터페이스에 의존하라](#82--)
        - [8.2.1 구체적인 구현에 의존하면 적응성이 제한된다](#821-----)
        - [8.2.2 해결책: 가능한 경우 인터페이스에 의존하라](#822-----)
    - [8.3 클래스 상속을 주의하라](#83---)
        - [8.3.1 클래스 상속은 문제가 될 수 있다](#831------)
            - [상속은 추상화 계층에 방해가 될 수 있다](#------)
            - [상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다](#--------)
        - [8.3.2 해결책: 구성을 사용하라](#832---)
            - [더 간결한 추상화 계층](#---)
            - [적응성이 높은 코드](#--)
        - [8.3.3 진정한 is-a 관계는 어떤가?](#833--is-a--)
    - [8.4 클래스는 자신의 기능에만 집중해야 한다](#84-----)
        - [8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다](#841---------)
        - [8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들어라](#842------)
    - [8.5 관련있는 데이터는 함께 캡슐화하라](#85----)
        - [8.5.1 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다](#851-------)
        - [8.5.2 해결책: 관련된 데이터는 객체 또는 클래스로 그룹화하라](#852-------)
    - [8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라](#86--------)
        - [8.6.1 반환 유형에 구현 세부 사항이 유출될 경우 문제가 될 수 있다](#861-----------)
        - [8.6.2 해결책: 추상화 계층에 적합한 유형을 반환하라](#862------)
    - [8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라](#87---------)
        - [8.7.1 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다](#871-----------)
        - [8.7.2 해결책: 추상화 계층에 적절한 예외를 만들라](#872------)

# 8. 코드를 모듈화하라

- 요구사항이 어떻게 바뀌는지 정확히 예측하는 것은 시간 낭비다
    - 그렇게 할 수 없기 때문에
- 어떤 식으로 바뀔지 정도는 알 수 있다

- 모듈화의 주된 목적 중 하나는 코드가 향후에 어떻게 변경되거나 재구성될지 정확히 알지 못하는 상태에서 변경과 재구성이 용이한 코드를 작성하는 것이다
- 이를 위해서는 각가의 기능이 코드베이스의 서로 다른 부분에서 구현되어야 한다

## 8.1 의존성 주입의 사용을 고려하라

- 하위 문제에 대한 해결책이 항상 하나만 존재하는 것은 아니다
- 하위 문제를 재구성할 수 있는 방식으로 코드를 작성하면 도움이 된다
- 의존성 주입(depedency injection)은 이를 달성하는데 도움을 준다

### 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다

- 클래스가 특정 인터페이스에 의존하더라도 특정 클래스를 직접 생성하면 특정 구현에 대한 의존성이 하드코드로 되어있는 것이다.
    - 만약 해당 클래스의 생성자에 매개변수가 추가되는 경우 해당 클래스에 더욱 의존하게 된다.
    - 따라서 클래스가 사용될 수 있는 경우를 훨씬 더 제한한다
- 특정 구현에 의존하면 다른 구현으로 코드를 재설정할 수 없다

- 즉, 하드 코드화된 의존성은 클래스의 모듈화를 말고 다용도로 사용할 수 없게 만든다

### 8.1.2 해결책: 의존성 주입을 사용하라

- 의존성 주입을 잘 활용하면 클래스가 더 잘 모듈화되고 다용도로 쓰일 수 있다
- 하드 코드화된 종속성을 없앨 수 있다

- 팩토리 함수를 직접 작성하는 것에 대한 대안으로 의존성 주입 프레임워크(dependency injection framework)를 사용할 수도 있다.

#### 의존성 주입 프레임워크

- 의존성 주입은 클래스를 조금 더 변경에 유연하게 해주지만 생성 코드는 더 복잡해진다는 단점이 있다.
- 이를 위해 팩토리 함수를 작성할 수도 있지만 이 또한 많아지면 힘든 작업이다
- 의존성 주입 프레임워크를 사용하면 이러한 많은 작업을 자동으로 할 수 있다
- 의존성 주입 프레임워크를 사용하면 팩토리 함수의 반복적인 코드를 작성하느라 허우적대지 않고, 모듈화되고 다용도로 사용할 수 있는 코드를 만들 수 있다

- 물론 의존성 프레임워크가 항상 옳지는 않다
- 어떤 설정이 어떤 부분에 적용되는지 알기 어렵기 때문이다

### 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라

- 코드를 작성할 때 의존성 주입을 사용할 수 있다는 것을 의식적으로 고려하면 좋을 때가 있다
    - 나중에 의존성 주입을 하는 것이 거의 불가능한 경우도 있기 때문이다

- 정적 매달림(static cling) : 정적 함수나 변수에 과도하게 의존하는 것

- 인터페이스의 구현체가 여러 개가 아니더라도 의존성 주입은 여전히 유용하다
    - 전역 상태를 피하는데 도움이 된다
    - 테스트하기 쉬운 코드를 작성하게 해준다

## 8.2 인터페이스에 의존하라

- 인터페이스에 의존하면 어떤 구현 클래스라도 사용할 수 있으므로 코드가 훨씬 더 모듈화되고 적응성이 높아진다
- 클래스에 직접 의존하는 것보다는 인터페이스에 의존하는 것이 일반적으로 더 바람직하다

### 8.2.1 구체적인 구현에 의존하면 적응성이 제한된다

- 클래스를 주입받으면 의존성 주입의 이점은 얻을 수 있지만 이를 다른 클래스로 교체하는 것은 불가능하다

### 8.2.2 해결책: 가능한 경우 인터페이스에 의존하라

- 따라서 구체적인 구현 클래스가 아니라 인터페이스에 의존하면 적응성을 더 높일 수 있다
- 더 추상적인 인터페이스에 의존하면 대개의 경우 더 간결한 추상화 계층과 더 나은 모듈화를 달성할 수 있다

- 인터페이스를 잘 정의하고, 클래스가 인터페이스를 구현한다면 이는 다른 개발자에게 해당 인터페이스에 대해 다르게 구현한 클래스를 작성할 수 있다는 메시지를 던진다
- 인터페이스에 의존한다고 해서 더 많은 노력을 기울일 필요가 없으며, 코드는 상당히 모듈화되고 적응성이 높아진다

## 8.3 클래스 상속을 주의하라

- 클래스 상속은 쓸모가 있고, 때로는 적합하다
    - 특히 `is-a` 관계라면
- 하지만 단점이 있고 상속이 야기하는 문제가 치명적일 수 있다
- 상속 대신 구성(composition)을 사용하면 상속의 함정을 피하고, 모듈화와 내구성이 향상된 코드를 작성할 수 있다

### 8.3.1 클래스 상속은 문제가 될 수 있다

- 클래스 상속을 통해서는 슈퍼 클래스가 구현한 여러 개의 인터페이스 중 하나에만 의존하는 것이 불가능하다
- 상속의 주요한 특징 중 하나는 서브클래스가 슈퍼클래스에 의해 제공되는 모든 기능을 상속한다는 점이다

#### 상속은 추상화 계층에 방해가 될 수 있다

- 한 클래스가 다른 클래스를 확장하면 슈퍼클래스의 모든 기능을 상속한다
- 유용할 때도 있지만 원하는 것보다 많은 기능을 노출할 때가 더 많다
- 따라서 추상화 계층이 복잡해지고 구현 세부 정보가 드러날 수 있다

#### 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다

- 인터페이스는 추상화 계층을 제공하지만 클래스를 상속할 경우 이러한 추상화 계층을 활용하는데 어려움이 생길 수도 있다

### 8.3.2 해결책: 구성을 사용하라

- 상속을 하는 이유 중 하나는 일부 기능을 재사용하는 것이다
- 하지만 상속은 여러 단점을 가지고 있다
- 이에 대한 대안은 구성(compose)을 사용하는 것이다

- 상속 대신 구성을 사용하면 인터페이스를 활용할 수 있어 추상화 계층이 더 간결해지고 코드는 재설정하기 쉬워진다
- 인스턴스를 생성자를 통해 의존성 주입을 받을 수 있다
- 특정 기능을 재사용하고 싶은 경우 전달(forwarding)을 통해 해결할 수 있다

- 즉, 구성을 사용하면 코드를 재사용하면서 상속의 문제를 피할 수 있다

#### 더 간결한 추상화 계층

- 상속 대신 구성을 사용하면 전달이나 위임을 통해 명시적으로 노출하지 않는 이상 구현 클래스의 기능이 노출되지 않는다

#### 적응성이 높은 코드

- 인터페이스에 의존하면 의존성 주입을 통해 변경을 쉽게 처리할 수 있다

### 8.3.3 진정한 is-a 관계는 어떤가?

- 두 클래스가 진정으로 `is-a` 관계일 때도 상속이 좋지 않을 때도 있다
    - 취약한 베이스 클래스 문제
        - 슈퍼클래스가 수정되었을 때 서브클래스가 동작하지 않을 수도 있으므로 매번 주의가 필요하다
    - 다이아몬드 문제
        - 다중 상속을 지원하는 경우 함수가 충돌되었을 때 애매하다
    - 문제가 있는 계층 구조
        - 다중 상속을 지원하지 않는 경우 여러 개의 클래스의 기능 재사용이 필요한 경우 계층이 애매해진다
- 하지만 정해진 답은 없고 상황에 따라 다르다

## 8.4 클래스는 자신의 기능에만 집중해야 한다

- 모듈화의 핵심 목표 중 하나는 요구 사항이 변경되면 그 변경과 직접 관련된 코드만 수정한다는 것이다
- 단일 개념이 단일 클래스 내에 완전히 포함된 경우라면 이 목표를 달성할 수 있다
- 클래스가 다른 클래스의 세부 사항에 지나치게 연관되어 있을 때 이런 일이 흔히 벌어질 수 있다

### 8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다

- 한 클래스가 다른 클래스와 지나치게 연관되어 있을 때 다른 개발자가 이를 빼먹으면 문제가 생길 수 있다

### 8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들어라

- 클래스는 가능한 자신의 기능에만 충실해야 한다
- 그렇지 않은 경우 해당 논리를 다른 클래스로 옮김으로써 클래스가 서로의 세부 사항에 대해 다루는 것을 최소화할 수 있다

- 클래스는 서로에 대한 어느 정도의 지식을 필요로하지만 가능한 한 이것을 최소화하는 것이 좋다

## 8.5 관련있는 데이터는 함께 캡슐화하라

- 너무 많은 것을 한 클래스에 두는 것도 조심해야 하지만 한 클래스 안에 두는 것이 합리적일 때는 그렇게 해야 한다
- 서로 다른 데이터가 밀접하게 연관되어 함께 움직여야 할 때는 묶는 것이 합리적이다
- 그렇게 하면 코드는 여러 항목의 세부 사항을 다루는 대신 단일한 클래스가 제공하는 상위 수준의 개념을 다룰 수 있다

### 8.5.1 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다

- 캡슐화되지 않은 데이터를 다루면 해당 데이터에 대한 세부 사항을 알 수밖에 없다
- 이러한 데이터에 변경 사항이 발생하면 해당 데이터의 세부 사항을 알고있는 모든 클래스를 수정해야 할 수도 있다. 이는 모듈화의 목적과 맞지 않다

### 8.5.2 해결책: 관련된 데이터는 객체 또는 클래스로 그룹화하라

- 관련된 데이터의 세부 사항을 숨기기 위해 객체 또는 클래스로 그룹화할 수 있다
- 다만 한 클래스에 너무 많은 개념이 있으면 문제가 되므로 캡슐화할 때 조심하긴 해야 한다

## 8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라

- 간결한 추상화 계층을 가지려면 각 계층의 구현 세부 정보가 유출되지 않아야 한다
- 코드에서구현 세부 정보를 유출하는 일반적인 형태 중 하나는 해당 세부 정보와 밀접하게 연결된 유형을 반환하는 것이다

### 8.6.1 반환 유형에 구현 세부 사항이 유출될 경우 문제가 될 수 있다

- 반환 유형에 세부 사항이 담기면 여러 곳에 퍼지기 쉽고, 나중에 이를 반환하는 함수를 수정하는 것이 거의 불가능해진다
- 따라서 추상화 계층에 적합한 유형을 반환하는 것이 더 나은 방법이다

### 8.6.2 해결책: 추상화 계층에 적합한 유형을 반환하라

- 어떤 클래스는 이를 사용하는 다른 개발자에게 노출되는 개념이 최소가 되도록 노력해야 한다

- 일반적으로는 코드를 재사용하는 것이 바람직하기 때문에 이미 정의된 클래스를 재사용하는 것이 좋은 방법처럼 보일 수 있다
- 하지만 만약 이러한 클래스들이 추상화 계층에 적합하지 않다면 새롭게 유형을 정의해 더 모듈화된 코드와 간결한 추상화 계층을 얻을 수 있다

## 8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라

- 구현 세부 정보가 유출될 수 있는 또 다른 일반적인 경우는 예외를 발생할 때다
- 호출하는 쪽에서 복구하고자 하는 오류에 비검사 예외를 사용하는 경우 특히 문제가 될 수 있다

### 8.7.1 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다

- 비검사 예외는 컴파일러에 의해 어떤 것도 강제되지 않는다
- 즉, 비검사 예외는 문서와 같은 세부 조항에 의해서 전달되지만 누락되면 코드 계약을 통해 전혀 전달되지 않는다

- 만약 비검사 예외를 통해 세부 사항이 유출되는 경우 추상화 계층 개념을 위반할 뿐만 아니라 신뢰할 수 없고 오류를 일으키기도 쉽다
- 또한 해당 클래스를 다른 클래스로 교체했을 때 완전히 새로운 예외를 내부적으로 던질 수도 있으므로 클래스를 유연하게 사용하는데도 문제가 생긴다

- 구현 세부 정보 유출 위험이 비검사 예외에만 있는 것은 아니지만 비검사 예외에서 더 문제가 악화되어 발생한다
- 비검사 예외는 문서화되지 않을 가능성이 크고, 인터페이스를 구현한 클래스가 인터페이스가 규정하는 오류만 발생시켜야 하는 것은 아니다

### 8.7.2 해결책: 추상화 계층에 적절한 예외를 만들라

- 추상화 계층을 반영하는 오류 유형만을 드러내는 것이 이상적이다
- 하위 계층의 오류를 통해 현재 계층에 적합한 오류 유형으로 감싸면 가능하다
- 이렇게 하면 호출하는 쪽에 적절한 추상화 계층이 제시되면서 동시에 원래 오류의 정보가 손실되지 않게 할 수 있다

- 이렇게 추상화 계층에 맞는 예외로 변환해서 던질 때 이를 명시하면 도움이 될 수도 있다

- 단, 이 방법의 단점은 사용자 지정 예외 클래스를 만들고, 다양한 에외를 처리하는 코드가 늘어난다는 점이다
- 하지만 전체 소프트웨어 관점에서는 클래스의 동작을 예측할 수 있고 모듈화가 개선된다는 장점이 있으므로 얻는 것이 더 크다