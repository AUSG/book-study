- [Chapter 7. 코드를 오용하기 어렵게 만들라](#chapter-7-코드를-오용하기-어렵게-만들라)
  - [7.1 불변 객체로 만드는 것을 고려하라](#71-불변-객체로-만드는-것을-고려하라)
  - [7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라](#72-객체를-깊은-수준까지-불변적으로-만드는-것을-고려하라)
  - [7.3 지나치게 일반적인 데이터 유형을 피하라](#73-지나치게-일반적인-데이터-유형을-피하라)
  - [7.4 시간 처리](#74-시간-처리)
  - [7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다](#75-데이터에-대해-진실의-원천을-하나만-가져야-한다)
  - [7.6 논리에 대한 진실의 원천을 하나만 가져야 한다](#76-논리에-대한-진실의-원천을-하나만-가져야-한다)


<br/><br/>

# Chapter 7. 코드를 오용하기 어렵게 만들라
## 7.1 불변 객체로 만드는 것을 고려하라
- 불변 객체: 생성된 후에 상태를 바꿀 수 없는 객체

**[문제점]**
- 가변 객체의 문제점
  - 추론하기 어렵다.
  - 다중 스레드에서 문제가 발생할 수 있다.
- 가변 클래스는 해당 인스턴스를 전달받는 모든 코드가 객체를 변경할 수 있어 오용하기 쉽다.

**[해결책]**
- 객체를 생성할 때만 값을 할당하고 그 이후에는 변경할 수 없도록 한다.
- 불변성에 대한 디자인 패턴(빌더 패턴, copy-on-write 패턴)을 사용한다.

<br/>

## 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 깊은 가변성
  - 멤버 변수 자체가 가변적인 유형이고 다른 코드가 멤버 변수에 액세스 할 수 있는 경우에 발생한다.
- 해결책
  - 객체가 반환될 때 객체의 복사본을 만든다.
  - 불변적 자료구조를 사용한다.

<br/>

## 7.3 지나치게 일반적인 데이터 유형을 피하라
**[문제점]**
- 지나치게 일반적인 유형은 그 유형 자체로 아무것도 설명해주지 않는다. 
  - Type-safe 하지 않다. 
  - ex: 위도 경도를 `List<Double>`로 표시하는 것
- 임시방편으로 작성했다 하더라도 이 코드는 광범위하게 확산될 수 있다.
- 페어 데이터 유형은 오용하기 쉽다. (`Pair<Double, Double>`)

**[해결책]**
- 전용 유형을 사용한다. 
  - ex: 위도 경도를 표시하기 위해 LatLong을 만들어 사용

<br/>

## 7.4 시간 처리
**[문제점]**
- 정수로 시간을 나타내면 모호하다.
  - 절대 순간, 시간의 양
  - 일치하지 않는 단위
  - 시간대 처리 오류

**[해결책]**
- 언어에 맞게 적절한 자료구조를 사용한다.
- 양으로서의 시간과 순간으로서의 시간을 구분한다.

<br/>

## 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다
**[문제점]**
- 기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성할 때 논리적으로 잘못된 상태가 발생할 수 있다.

**[해결책]**
- 기본 데이터를 유일한 진실의 원천으로 사용한다.
  - 파생 데이터를 처리하는 로직은 메소드로 분리한다.
- 파생 데이터를 계산하는 데 비용이 많이 든다면 값이 필요할 때까지 지연 계산하고 결과를 캐싱한다.

<br/>

## 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다
**[문제점]**
- 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다
  - ex: 하나를 하기 위해 여러 코드를 순차적으로 불러와야 하는 상황

**[해결책]**
- 재사용 가능한 하나의 코드 계층으로 구현한다.
