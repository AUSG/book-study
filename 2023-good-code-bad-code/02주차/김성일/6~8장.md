# 6. 예측 가능한 코드를 작성하라

## 6.1. 매직값을 반환하지 말라

>   매직값 : 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가진 경우, ex) 실패했을 때 -1을 return하는 함수

-   매직값은 버그를 유발할 수 있다
    -   널 또는 옵셔널을 사용하라
        -   널이 가능한 반환 유형은 호출하는 쪽에 부담을 전가하긴 한다. 하지만 매직값에 의한 버그를 처리하는 비용보다는 적다.
-   때때로 매직값이 우연히 발생할 수 있다
    -   매직값을 반환하는 것을 개발자가 의식적으로 내린 결정인 경우에도, 사용하는 측에서 우연히 예측을 벗어나는 결과를 초래할 수 있음

 

## 6.2. 널 객체 패턴을 적절히 사용하라

-   빈 컬렉션을 반환하면 코드가 개선될 수 있다
    -   널 객체 패턴을 사용하면, 사용하는 쪽에서 적절한 처리가 필요. 빈 컬렉션을 반환할 수 있는 상황이라면, 그 경우에 더 간결한 코드를 만들 수 있음
-   빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다
-   더 복잡한 널 객체는 예측을 벗어날 수 있다
    -   무해한 혹은 기본값을 갖는 복잡한 객체를 널 객체로 사용하면 문제가 될 수 있음. 그냥 널 객체를 쓰자.

-   널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다
    -   더 복잡한 널 객체와 동일한 의미로 예측을 벗어날 수 있음



## 6.3. 예상치 못한 부수 효과를 피하라

-   분명하고 의도적인 부수 효과는 괜찮다

-   예기치 않은 부수 효과는 문제가 될 수 있다

    -   부수 효과는 비용이 많이 들 수 있다
    -   호출한 쪽의 가정을 깨뜨리기
        -   호출한 쪽에서 부수효과가 없을 것이라 기대했는데, 그 가정이 깨진다면 문제가 될 수 있음

    -   다중 쓰레드 프로그램에서의 버그 발생 가능

-   부수 효과를 피하거나 그 사실을 명백하게 할 것



## 6.4. 입력 매개변수를 수정하는 것에 주의하라

-   입력 매개변수를 수정하면 버그를 초래할 수 있다
-   변경하기 전에 복사하라



## 6.5. 오해를 일으키는 함수는 작성하지 말라

-   중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다
-   중요한 입력은 필수 항목으로 만들어라



## 6.6. 미래를 대비한 열거형 처리

-   미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다
    -   모든 경우를 처리하는 Switch 문을 사용하라
-   기본 케이스를 주의하라
-   다른 프로젝트의 열거형에 의존하는 것에 주의하라



## 6.7. 이 모든 것을 테스트로 해결할 수 없는가?

-   테스트만으로는 예측을 벗어나는 코드의 문제점을 해결할 수 없음
-   직관적이지 않거나 예상을 벗어나는 코드에 숨어 있는 오류를 테스트만으로는 방지하기 어려움
-   하지만 그래도 테스트는 중요



# 7. 코드를 오용하기 어렵게 만들어라

## 7.1. 불변 객체로 만드는 것을 고려하라

-   가변 객체는 추론하기 어렵다
-   가변 객체는 다중 스레드에서 문제가 발생할 수 있다

-   가변 클래스는 오용하기 쉽다
    -   객체를 생성할 때만 값을 할당하라
        -   하지만 클래스가 불변이 되면 쓸모가 없어질 수 있음. 이를 위한 빌더 패턴 및 쓰기 시 복사 패턴 사용



## 7.2. 객체를 깊은 수준까지 불변으로 만드는 것을 고려하라

-   깊은 가변성은 오용을 초래할 수 있음
-   방어적으로 복사하여 깊은 수준의 불변을 지키자
-   불변 클래스를 사용하여 아예 오용할 여지를 제거하기



## 7.3. 지나치게 일반적인 데이터 유형 피하라

-   지나치에 일반적인 유형은 오용될 수 있다
-   페어 유형은 오용하기 쉽다
    -   전용 유형을 사용하여 오용을 막아라



## 7.4. 시간 처리

-   정수로 시간을 나타내는 것은 문제가 될 수 있다
    -   단위나, 시간대 등의 문제가 발생할 수 있음
    -   적절한 자료 구조를 사용하라



## 7.5. 데이터에 대해 진실의 원천을 하나만 가져야 한다

-   또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다
-   기본 데이터를 유일한 진실의 원천으로 사용하라



## 7.6. 논리에 대한 진실의 원천을 하나만 가져야 한다

-   논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다
-   진실의 원천은 단 하나만 있어야 한다



# 8. 코드를 모듈화하라

## 8.1. 의존성 주입의 사용을 고려하라

-   하드 코드화된 의존성은 문제가 될 수 있다
-   의존성 주입을 사용하라

-   의존성 주입이 복잡하다면, 의존성 주입 프레임워크를 사용하라

-   의존성 주입을 염두에 두고 코드를 설계하라



## 8.2. 인터페이스에 의존하라

-   구체적인 구현에 의존하면 적응성이 제한된다
    -   가능한 경우 인터페이스에 의존하라
    -   더 간결한 추상화 계층과 더 나은 모듈화를 달성할 수 있음



## 8.3. 클래스 상속을 주의하라

-   클래스 상속은 문제가 될 수 있다

    -   상속은 추상화 계층에 방해가 될 수 있다
    -   상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다
    -   composition을 사용하라

-   진정한 is-a 관계는 어떤가

    -   진정한 is-a 관계일 때도, 상속은 문제가 될 수 있음
        -   취약한 베이스 클래스 문제
        -   다이아몬드 문제
        -   문제가 있는 계층 구조

    -   인터페이스 혹은 composition을 고려하라



## 8.4. 클래스는 자신의 기능에만 집중해야 한다

-   다른 클래스와 지나치게 연관되어 있으면 문제가 발생할 수 있다
-   자신의 기능에만 충실한 클래스를 만들라



## 8.5. 관련 있는 데이터는 함께 캡슐화하라

-   캡슐화되지 않은 데이터는 취급하기 어려울 수 있다
-   관련된 데이터는 객체 또는 클래스로 그룹화하라



## 8.6. 반환 유형에서 구현 세부 사항이 유출되지 않도록 주의하라

-   반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다
-   추상화 계층에 적합한 유형을 반환하라



## 8.7. 예외 처리시 구현 세부 사항이 유출되지 않도록 주의하라

-   예외 처리시 구현 세부 사항이 유출될 경우 문제가 될 수 있다
-   추상화 계층에 적절한 예외를 만들어라