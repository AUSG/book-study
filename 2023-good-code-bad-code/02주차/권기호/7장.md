# 코드를 오용하기 어렵게 만들어라.
서로 다른 코드들과 잘 맞물려 작동하기 위햐 오용될 가능성을 낮추는 것이 중요하다.

코드 오용의 경우)
- 호출하는 쪽에서 잘못된 입력을 제공한 경우
- 다른 코드의 부수 효과
- 정확한 시간이나 순서에 따라 함수를 호출하지 않음
- 관련 코드에서 가정과 맞지 않게 수정이 이루어짐

## 불변 객체를 고려해라.

가변객체가 발생할 수 있는 문제점
- 가변 객체는 추론하기 어렵다.
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있다.

### 가변 클래스는 오용하기 쉽다.
Setter를 통해 가변 클래스를 만들면 해당 인스턴스를 전달받는 모든 코드는 이 객체를 변경할 수 있다.

### 해결책: 객체를 생성할 때만 값을 할당하라.
모든 값이 객체의 생성 시에 제공되고 그 이후로는 변경할 수 없도록 함으로써 클래스를 불변적으로 만들 수 있고 오용도 방지할 수 있다.

### 해결책: 불변성에 대한 디자인 패턴을 사용하라.
- 빌더패턴
1. 값을 하나씩 설정할 수 있는 빌더 클래스
2. 빌더에 의해 작성된 불변적인 읽기 전용 클래스


- 쓰기 시 복사 패턴
1. 쓰기 시에 새로운 객체를 반환한다.

## 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라.

클래스가 실수로 가변적으로 될 수 있는 일반적인 경우는 깊은 가변성 때문이다.

### 깊은 가변성을 오용을 초래할 수 있다.
참조를 통해 수정이 이루어지면, 어디서 왔는지 그리고 수정하는 것이 안전한지 추적하기가 쉽지 않다.

### 해결책: 방어적으로 복사하라.
클래스가 참조하는 객체가 클래스 외부의 코드에서는 참조할 수 없도록 하여 문제를 방지할 수 있다.

### 해결책: 불변적 자료구조를 사용하라
불변 자료구조를 통해 생성되고 나면 아무도 내용을 변경할 수 없게 한다.

## 지나치게 일반적인 데이터 유형을 피하라.
정수나 리스트와 같은 유형으로 표현이 '가능'하다고 해서 그것이 반드시 '좋은' 방법은 아니다. 설명이 부족하고 허용하는 범위가 넒을수록 코드 오용은 쉬워진다.

### 지나치게 일반적인 유형은 오용될 수 있다.

`List<List<Double>>`과 같은 형식은 혼란을 야기한다.

### 해결책: 전용 유형 사용
대부분 노력이 덜 들어가고 다른 개발자가 코드를 읽을 때 이해하기 쉽고 버그의 가능성도 줄여준다.

## 시간 처리
시간에 기초한 개념을 다룰 때 적절한 데이터 유형과 언어 구성 요소를 사용하여 혼동과 오남용을 방지할 수 있는 방법을 논의한다.

### 정수로 시간을 나타내는 것은 문제가 될 수 있다.
정수는 매우 일반적인 유형이기 때문에 시간을 나타내는 데 사용하는 경우 코드가 오용되기 쉽다.

- 한순간의 시간인가, 시간의 양인가
- 일치하지 않는 단위
- 시간대 처리 오류

### 해결책: 적절한 자료구조를 사용하라.

사용하는 언어에 적합한 라이브러리를 통해 견고하게 처리할 수 있다.

## 데이터에 대해 진실의 원천을 하나만 가져야한다.
- 기본 데이터: 코드에 제공해야 할 데이터, 코드에 이 데이터를 알려주지 않고는 코드가 처리할 방법이 없다.
- 파생 데이터: 주어진 기본 데이터에 기반해서 코드가 계산할 수 있는 데이터

기본 데이터는 일반적으로 프로그램에서 진실의 원천이 된다.

### 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다.
기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성할 때, 이와 같은 논리적으로 잘못된 상태가 발생할 수 있다.

### 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라.

## 논리에 대한 진실의 원천을 하나만 가져야 한다.
진실의 원천은 코드에 제공된 데이터에만 적용되는 것이 아니라 코드에 포함된 논리에 젇용된다.

### 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다.
논리에 대한 진실의 원천이 두 개가 있는 상태에서 개발자가 하나만 수정하고 다른 하나를 수정하지 않으면 문제가 발생하기 쉽다.

### 해결책: 진실의 원천은 단 하나만 있어야 한다.
중요한 논리에 대해 진실의 원천이 하나만 존재하도록 하면 코드가 훨씬 더 견고해진다.