# 7. 호텔 예약 시스템

-   조회가 훨씬 많이 읽어나는 시스템이고, QPS가 그리 높지 않기에 RDB 사용
-   동시성 문제 해결
    -   같은 사용자가 여러번 예약을 누르는 경우
        -   클라이언트 측에서 여러번 누르는 것을 막기
        -   멱등키 사용
    -   여러 사용자가 같은 객실을 예약하려는 경우
        -   비관적 락
            -   레코드를 갱신하려고 할 때 즉시 락을 걸어 동시 업데이트를 방지
            -   데이터의 경합이 심할 때 유용
            -   데드락 발생 가능성이나 확장성이 낮다는 단점
        -   낙관적 락
            -   버전 번호 혹은 타임스탬프를 통해 락을 어플리케이션 레벨에서 구현
            -   일반적으로 비관적 락보다 빠름
            -   동시성 수준이 매우 높으면 성능이 나빠짐
        -   데이터베이스 제약 조건
            -   구현이 쉽지만 경쟁이 심하면 성능이 나빠짐
            -   제약조건은 버전 통제가 어려움
-   샤딩을 통해 데이터베이스 규모를 확장
-   호텔은 과거건보다 현재와 미래건이 중요하기에, ttl을 통해 자동 제거할 수 있는 캐시 사용에 유리
    -   캐시 evict 타이밍을 잘 잡아야함
    -   데이터 베이스 갱신때 캐시도 수정해야함. CDC 같은 것을 고려해봐도 좋음
-   각 서비스의 데이터베이스를 갖게하는 구조라면, 2PC 혹은 사가패턴을 고려해야 함



# 8. 분산 이메일 서비스

-   메일서버의 구조
    -   사용자가 메일 전송
    -   SMTP서버가 해당 메일서버에 데이터를 저장하고, 수신자측 SMTP 서버로 전송
    -   수신자측 SMTP 서버에서 데이터를 저장하고, 사용자에게 수신 알림 전송 
-   이메일은 보통 디렉터리 형식으로 저장
-   각 컴포넌트 구성
    -   웹서버 
        -   사용자 기능의 요청/응답 서비스
    -   실시간 서버
        -   새로운 이메일 내역을 클라이언트에 실시간으로 전송
        -   보통 웹소켓 사용
    -   메타데이터 데이터베읏
        -   이메일 제목, 본문, 발신인, 수신인등의 데이터를 저장
    -   첨부파일 저장소
        -   객체 저장소등을 사용
-   웹서버에서 메일 전송시 큐를 통해 SMTP에 차례로 데이터를 전송하도록 함
    -   검증등에 실패한 메시지들은 에러 큐에 넣고 처리
-   수신시에는 로드밸런서가 앞에 붙어있고, 이메일 policy에 따라 수신측의 SMTP 서버가 수신 이메일 큐로 전달. 바이러스 검사등을 진행하고 실시간 서버를 통해 수신 알림을 보냄 
-   NoSQL을 통해 유저 아이디 폴더 아이디 등을 파티션키로 지정
    -   특정 사용자의 모든 폴더 조회시 유저 아이디로 파티션닝된 데이터를 조회
    -   특정 폴더의 이메일 조회시 유저 아이디와 폴더 아이디로 파티셔닝 된 데이터를 조회하고, 이메일 ID를 timeuuid를 사용하여 클러스터 키로 사용
-   이메일 쓰레드 조회시 reference를 통해 JWZ 같은 알고리즘을 이용하여 구현

-   스팸 처리 대응
    -   전용 IP 사용
    -   이메일의 범주에 따라 전용 IP 범주화
    -   발신인 평판 올리기
    -   스팸 발송자를 차단
    -   피드백 처리
-   검색은 ES 혹은 맞춤 검색 솔루션을 사용
    -   ES의 데이터 일관성을 맞추기 위해 조회가 아닌 작업들도 백그라운드식으로 진행되어야 함
    -   소규모 서비스에서는 ES가 적절하지만 확장을 위해서는 결국 맞춤 검색 솔루션 필요



# 9. S3와 유사한 객체 저장소

-   저장소 시스템
    -   블록 저장소
        -   raw block을 서버에 볼륨 형태로 제공
    -   파일 저장소
        -   블록저장소 위에 추상화된 것
        -   계층적 디렉토리에 파일이 저장됨
    -   객체 저장소
        -   데이터 영속성을 높이기 위한 방식
        -   데이터를 수평적인 구조로 객체로 저장한다
        -   버킷 이름과 객체 이름을 디렉토리 구조처럼 표현하여 디렉토리를 흉내낼 수 있음
-   객체 저장소
    -   메타데이터
        -   객체의 실제 데이터와 분리된 정보
        -   버킷이름, 아이디, 객체 이름, 버전, 객체 아이디등을 보관
    -   객체
        -   실제 데이터
        -   데이터 저장소 서비스에 실제 저장되는 데이터
-   데이터 라우팅 서비스
    -   배치서비스를 호출하여 어떤 데이터 노드에 저장할지 판단
    -   데이터 노드에서 데이터를 읽거나 데이터 기록
-   배치 서비스
    -   어느 데이터 노드에 데이터를 저장할지 판단
    -   heartbeat 메시지를 지속적으로 주고받고 응답하지 않는 노드는 죽은 노드로 판단
    -   팩서스나 래프트 같은 합의 프로토콜을 사용하는 것을 권장
-   객체아이디와 메타데이터 이름 매핑
    -   UUID를 입력으로 주고 질의하면 객체에 대한 다중화 그룹이 결정적으로 반환되어야 함
    -   이런 경우 보통 안정해시를 사용함
-   객체 저장에는 작은 객체들을 하나의 큰 파일로 모아서 저장하며, offset을 통해 파일의 어느 부분을 읽을지 판단
-   장애 대응
    -   다중화를 통해 내구성을 높일 수 있음
    -   패리티 비트 기반의 소거 코드를 사용하면 패리티를 통해 데이터 복구 가능
-   정확성 검증
    -   데이터의 체크섬을 사용하여 비교
    -   각 객체에 대한 체크섬을 저장하고 파일이 읽기전용으로 변경되었을 때 그 파일에 대한 체크섬도 저장
    -   객체를 조회할 때 객체 데이터의 체크섬과 저장된 체크섬을 비교하여 데이터가 손상되었는지 판단하고, 다른 복제 데이터를 통해 복구 시도
-   데이터베이스 규모 확장을 위해서 샤딩을 할 수 있음
    -   하지만 메타데이터 테이블을 샤딩하면 어떤 샤드에 데이터가 있는지 모르기에 목록 출력이 어려워질 수있음
    -   전체 샤드에서 조회를 하고 취합하여 결과를 전송 하지만 이런 경우 페이지네이션이 어려워짐
        -   버킷 ID로 샤딩하는 별도 테이블에 목록 데이터를 비정규화하면 해결 가능
-   객체 버저닝
    -   메타데이터에 버전과 객체 id를 TIMEUUID로 하여 구현
    -   데이터 삭제는 삭제플래그를 사용
-   큰 파일 업로드
    -   멀티파트 업로드 방식을 사용하여 ETag로 정상적인 데이터가 업로드 됐는지 확인
    -   각 조각들을 하나의 객체로 조립하고 나서는 각 조각들이 필요 없어지기에, 이런걸 제거하는 가비지 컬렉션이 필요
-   가비지 컬렉션
    -   더 이상 사용하지 않는 데이터를 회수
    -   객체의 지연 삭제
    -   갈 곳이 없는 데이터 : 반쯤 업로드된 데이터, 취소된 멀티파트 데이터
    -   훼손된 데이터
