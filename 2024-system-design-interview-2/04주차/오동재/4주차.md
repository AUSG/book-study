# 7. 호텔 예약

# 동시성 문제

## 같은 사용자가 예약을 여러번 누르는 경우

### 클라이언트 측 처리

자바스크립트를 비활성화하면 우회할 수 있음

### 멱등api

request에 멱등key를 추가.

## 잔여객실이 하나일 때 처리

### 비관적 락

한 쪽이 수정을 위해 데이터베이스를 읽으면 그 동안 lock을 검

- 구현이 쉽고 갱신 연산을 직렬화하여 충돌을 막음. 데이터에 대한 경합이 심할 때 유용
- deadlock이 발생할 수 있음

### 낙관적 락

database에 version을 명시에 한 단계 높은 버전의 commit만 update를 허용함

- 락을 걸 필요가 없음. 버전번호를 통해 일관성을 유지할 책임은 애플리케이션에 있음
- 경쟁이 치열하지 않은 상황에서 적합. 락을 거는 비용을 절약
- 경쟁이 치열하면 계속해서 v1→v2→…→v203 등으로 갱신되다가 승인되므로 사용자 경험 안좋음

### 데이터베이스 제약 조건

total-now≥0 이라는 제약을 걸어 update를 했는데 해당 제약이 위배되면 트랜잭션이 거절됨

- 데이터에 대한 경쟁이 심하지 않을 때 잘 동작

# MSA 동기화

### 2-phase commit

모든 노드가 성공 혹은 실패를 하도록 보장.

blocking protocol이기 때문에 한 노드에 장애가 생기면 장애가 복구될 때까지 진행이 중단됨⇒ 성능이 좋진 않음

### saga pattern

# 8. 분산 이메일 서비스

# 저장

메일은 크기가 커서 SQL은 힘듦

분산 object storage 등은 검색, 읽음 표시 동기화 등이 힘듦

NoSQL + read, unread로 비정규화

# 이메일 전송 가능성

이런 것도 있구나. 새로운 IP의 메일서버는 스팸일 수도..?

그래서 뭐 전략적으로 잘 키워야 한다~

# 검색

### 엘라스틱서치

어느 정도 확장 가능

주 DB와 엘라스틱 서치 동기화해야함

적용만 하면 돼서 쉬운 편

### 맞춤형 검색 엔진

확장에 용이

하나의 시스템

직접 구현해야해서 어려움

# 규모 확장성 및 고가용성

사용자의 물리적 위치별로 데이터센터를 다중화함으로써 쉽게 구현 가능

# 9. 오브젝트 스토리지

`url : 파일 위치`가 맵핑된 데이터베이스를 따로 사용하여 구현할 수 있음

⇒ 읽기가 많으므로 SQL사용.

# 작은 파일 효율적으로 저장하기

파일시스템은 파일을 별도의 디스크 블록으로 저장함 디스크 블록의 크기는 전부 같으며 보통 4KB임. 4KB보다 작은 파일을 저장할 경우 낭비됨.

⇒ WAL을 사용할 수 있음. object storage는 읽기 전용 파일들을 저장하므로 순차적으로 데이터를 저장하여 작은 파일 여러개를 하나의 파일로 보관할 수 있음

# 데이터 내구성

## 디스크 손상 대비

### 다중화

200%의 용량 오버헤드

계산 필요 없음 복구 쉬움

쓰기도 그냥 복제만 하면 됨

### 소거 코드

50%의 용량 오버헤드

계산 어려움, 복구 오래걸림

쓰기도 계산 필요함

## 메모리 손상 대비

데이터를 주고 받을 때 체크섬 사용

<aside>
💡 체크섬이 유효해도 데이터가 100% 정확한 것은 아니지만 거의 정확함. 사실상 정확하다고 봐도 무방

</aside>

# 큰 파일 업로드 최적화

멀티 파트 업로드

⇒ 데이터를 쪼개서 보냄으로써 중간의 네트워크 오류로 처음부터 다시 보내는 상황을 방지

보내고 난 다음에는 조각들을 제거해야 함
