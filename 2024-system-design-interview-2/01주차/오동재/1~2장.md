# 1. 근접성 서비스

## non-functional requirments

- 사용자 위치는 민감한 정보 ⇒ 보호해야 함

# 데이터 베이스

- 읽기 연산 >> 쓰기 연산인 경우 관계형 데이터베이스가 바람직할 수 있음

- LBS : 쓰기 요청이 없는 읽기 요청만 발생하는 서비스
  - QPS가 높음
  - stateless하기 때문에 수평적 확장이 용이함
- 사업장 서비스 :
  - 쓰기 요청을 주로 담당하며 QPS가 높지 않음
  - 고객이 사업장 정보를 조회하면 특정 시간대에 QPS가 높아짐
- 데이터베이스 클러스터
  - primary-secondary 형태
  - 복제에 delay가 있지만 완전 실시간으로 정보가 갱신될 필요가 없는 서비스이기 때문

## 주변 사업장 검색 알고리즘

현재위치(x,y)를 기반으로 주변 사업장 정보를 반환해야함.

### 방안1) 2차원 검색

- indexing
  - 일반 DB index는 1차원 검색 속도만 개선할 수 있음

<aside>
💡 지리적 정보에 대한 indexing 방법

- 해시 기반
  - **균등 격자**(even grid), **지오해시**(Geohash), 카르테시안 계층
- 트리 기반
  - **쿼드트리**(Quadtree), **구글S2**, R트리

</aside>

> ⇒ 여러 indexing방법을 사용해 해결해보자

### 방안2) 균등 격자

지도를 그림과 같이 균등한 격자로 나누어 다루는 방법

**장점**

- 매우 _간단한 구조 ⇒ 구현 용이_

**단점**

- 불균등한 데이터 처리의 어려움
- 공간 활용의 비효율성

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/af55a34b-9237-4a8d-9996-7f267aeaa8d5/c77ffd28-e6d8-440b-b2b9-0ca8e3ebdf4a/Untitled.png)

### 방안3) 지오해시

위도 경도 데이터를 1차원 문자열로 변환. 비트를 하나씩 늘려가면서 재귀적으로 세계를 더 작은 grid로 분리해 나감. 아래 그림을 보면 이해 쉬움

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/af55a34b-9237-4a8d-9996-7f267aeaa8d5/465c52fc-ff07-4ed3-8422-7840996299aa/Untitled.png)

장점

- 문자열 기반으로 인해, 주변 지역 검색과 범위 쿼리가 간단
- 트리를 구현하지 않기때문에 구현과 사용이 비교적 쉽다.
- 색인 갱신이 쉽다.
- 공간의 정밀도를 문자열 길이 조절로 쉽게 조정

단점

- 정밀도를 고정하면 격자 크기도 고정됨
- edge case
  - 공통 접두어(prefix)를 가진 격자들은 인접한다. 하지만 **인접한다고 공통 접두어를 가지진 않는다**.
  - 완전 바로 옆에 있어도 다른 격자에 있을 수 있음

**지오해시 구현**

indexing을 구현할 일이 생긴다면 비교적 구현이 간단하고 효율적인 지오해시를 추천

구현 방안에는 크게 두 가지를 예를 들 수 있음

- 방안1. list_of_item_ids 라는 json파일에 item id를 모두 담아두는 방법
  - 추후 수정할 때 list_of_item_ids라는 json 전체를 쿼리해야 함⇒비효율
- 방안2. geohash, item_id 각각을 별도 열로 저장하는 방법
  - geohash + item_id를 compound key로 사용하면 수정이 훨씬 빠름

### 방안4) 쿼드트리

grid의 내용이 특정 기준을 만족할 때까지 2차원 공간을 재귀적으로 사분면 분할

아래 그림 예시) 인구 밀집도가 높은 지역은 격자가 정밀함

장점

- 효율적인 쿼리
- 동적분할로 공간 활용도를 높임
- 격자 크기를 동적으로 조정할 수 있음
- k번째로 가까운 아이템을 찾을 수 있음. (조금 멀 더라도 그나마 가장 가까운 아이템을 찾기 용이함)

단점

- 지오해시보다 색인 갱신이 까다로움, 트리기 때문
- 구현이 까다로움. 트리 구축을 해야하기 때문
- 초기 데이터베이스 구축도 시간이 많이 걸림 ⇒ blue green deployment 등을 잘 활용해야 함

### 방안5) 구글 S2

지구(sphere)를 힐베르트 곡선이라는 공간 채움 곡선을 사용하여 1차원 색인화하는 메모리 기반의 방안

S2는 지오펜스 구현

- 위키피디아 - 지오펜스는 실세계 지리적 영역에 설정한 가상의 경계다.

S2 내부 어려워서 잘 몰라도 됨 ㄱㅊ

### 사용 사례

| 색인 방법           | 회사                             |
| ------------------- | -------------------------------- |
| 지오해시            | Bing 지도, redis, mongo db, Lyft |
| 쿼드트리            | Yext                             |
| 지오해시 + 쿼드트리 | ElasticSearch                    |
| S2                  | Google Map, Tinder               |

# 캐시

high availability를 보장하고 대륙 경계를 넘는 트래픽의 latency를 방지하기 위해서는 레디스 클러스터를 전 세계의 각 지역별로 두고, 동일한 데이터를 각 지역에 중복해서 저장해 두어야 함

# 2. 주변 친구

> 근접성 서비스와의 차이 : 동적인 위치 정보

# non-functional requirments

- low latency
- 안정성 : 때로 데이터 몇 개가 유실돼도 ㄱㅊ
- 결과적 일관성(eventual consistency) : 위치 데이터를 저장하기 위해 엄청 강력한 일관성이 필요하진 않음

# Cassandra

위치 이동 이력 데이터베이스에 사용할 DB

막대한 쓰기 연산 부하를 감당할 수 있고 수평적 규모 확장이 가능

# 레디스

> 주기적 위치 갱신을 위해 사용.
> 초경량 메시지 버스로 레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연산

- 위치 정보를 데이터베이스에 저장할 필요가 없음

## 위치정보 캐시

위치정보는 쉽게 샤딩할 수 있음 (사용자 ID 기준으로 샤딩하면 됨)

replicaset을 사용하면 가용성을 높일 수도 있음

# service discovery

> etcd, ZooKeeper 등이 가장 널리 사용됨

### 안정 해시(consistent hash)

> https://www.toptal.com/big-data/consistent-hashing

## 대용량 트래픽 처리

### scale-out?

채널을 구독자 목록 = 친구 목록 이고 이때문에 redis channel이 stateful하다고 볼 수 있음.

⇒ 그렇기에 수평 확장 힘듦

### scale-up

이게 더 바람직함.

혹여 한 채널에 문제가 생겨도 해당 채널만 다시 생성하는 게 scale-out을 해 여러 채널에 대한 재구독을 처리하는 것보다 쉬움

<aside>
💡 **redis의 대안**
erlang이 좋은 대안이 될 수 있지만 레퍼런스가 부족할 것임
얼랭 프로세스 생성 비용 <<<< 리눅스 프로세스 생성 비용
⇒ 경량 프로세스덕분임

위 서비스에서는 웹소켓 서비스는 얼랭으로 구현하고 레디스 펍/섭 클러스터는 아예 분산 얼랭 애플리케이션으로 대체할 수 있음

</aside>

# 웹소켓 서버

웹소켓 서버는 유상태 서버라 기존 서버를 제거할 때, 노드를 제거하기 전 우선 기존 연결을 종료해야 함

로드밸런서가 인식하는 노드 상태를 ‘연결 종료 중’으로 변경해 둠

⇒ 그 서버는 새로운 웹소켓 연결이 만들어지지 않음

그리고 모든 연결이 종료되면(혹은 충분한 시간이 지나면) 서버를 제거
