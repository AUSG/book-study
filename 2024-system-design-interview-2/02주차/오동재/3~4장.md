# 3. 구글맵

# 지도 101

## 측위 시스템 positioning system

- 위도 Latitude (Lat.) : 얼마나 북/남쪽인지
- 경도 Longitude : 얼마나 동/서쪽인지

## 지도 투영법 map projection

> 3차원 위치의 2차원 변환

거의 모든 투영법은 실제 지형의 기하학 특성을 왜곡

구글 맵은 메르카토르 도법을 변경한 `웹 메르카토르` 도법을 선택

## 지오코딩

> 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스

- 인터폴레이션(interpolation) : 지오코딩을 수행하는 방법 중 하나
  - GIS(Geographic Information System)와 같은 다양한 시스템이 제공하는 데이터를 결합
  - GIS는 도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 시스템 중 하나

## 경로 탐색 알고리즘

대부분의 경로 탐색 알고리즘은 `다익스트라` 혹은 `A* 알고리즘`의 변형

### ETA

실시간 교통 현황 반영

- **완전 탐색 (O(nm))** : n개의 경로가 있고 경로들의 평균 길이가 m이라면 중간에 특정 경로가 마비됐을 때 이를 반영하기 위해 모든 경로를 다 찾아봐야 하므로 O(nm)임
- **계층적 타일 방법 (O(n))**: 최상위 타일의 교통 상태를 먼저 확인합니다. 만약 최상위 타일에 문제가 없다면, 하위 타일을 확인할 필요가 없습니다. 문제가 있는 경우에만 관련된 중간 타일로 내려가서, 그 중간 타일 내의 작은 타일들을 확인합니다.

# 데이터 베이스

## 지도 이미지 불러오기

- 읽기가 쓰기보다 많음 ⇒ redis, CDN 사용

## 사용자 위치 갱신

- 쓰기가 읽기보다 많음 ⇒ NoSQL 사용

### AP 설계

> 일관성이 크게 중요하지 않은 서비스임

- 카산드라가 적합한 데이터베이스 모델임
- 입력된 데이터 값을 동시에 여러 서비스에서 사용하기 위한 카프카 사용

# 4. 분산 메시지 큐

# 메시지 큐

## 장점

- 결합도 완화
- 규모 확장성 개선 : producer와 consumer 시스템 규모를 트래픽 부하에 맞게 독립적으로 늘릴 수 있음
- 가용성 개선 : 독립적인 장애
- 성능 개선 : 비동기 통신

## 메시지 큐 vs 이벤트 스트리밍 플랫폼

### 이벤트 스트리밍 플랫폼

- 카프카
- 펄사

### 메시지 큐

- RabbitMQ 등 MQ들

기능이 원래 상이했으나 점점 수렴하고 있음

## 구조

- 생산자 : 메시지 발행
- 소비자 : 메시지 구독
- 메시지 : 메시지
- 토픽 : pub/sub에서 그 토픽
- 파티션 : 규모 확장을 위해 토픽을 여러 대의 서버로 나누어 관리할 수 있도록 하는 파트
- 브로커 : 파티션을 유지하는 서버
- consumer group : 특정 토픽을 구독하는 소비자 그룹

# 상세 설계

## 데이터 저장소

- 데이터 베이스는 쓰기와 읽기가 모두 빈번한 작업을 처리하기 힘듦. 병목이 생길 것임
- 쓰기 우선 로그(WAL, Write-Ahead Log) : 새로운 항목이 추가되기만 하는(append-only) 일반 파일
  - MySQL의 복구 로그(redo log)와 주키퍼가 WAL을 사용

## 높은 대역폭 달성

- 중간 과정에서 불필요한 copy없애기

## 생산자측 작동

- 라우팅 계층 : 적절한 브로커에세 메시지를 보내기 위한 계층
  - 생산자 ⇒ 라우팅 계층 ⇒ 브로커 : 이러면 네트워크 전송이 하나 더 생겨서 지연됨
    ⇒ 그래서 라우팅계층을 생산자에 포함시켜서 한 네트워크 안에서 작동하게 함

## 소비자측 작동

> consumer가 메시지를 가져오느냐(풀), 브로커가 consumer에게 보내느냐.(푸시)

### 푸시 모델

- 장점
  - 낮은 지연 : 브로커가 메시지를 받는 즉시 consumer에게 보낼 수 있음
- 단점
  - consumer의 처리 속도가 생산자가 메시지를 만드는 것보다 느리면 소비자에게 큰 부하가 걸릴 수도 있음. ⇒ 생산자에게 데이터 전송 속도가 달려있으므로 consumer는 그에 맞는 컴퓨팅 자원이 필요함

### 풀 모델

- 장점
  - consumer가 처리할 수 있는만큼, 유연하게 데이터를 가져갈 수 있음. 계속 풀하면 뭐 사실상 push느낌도 남
  - 일괄 처리에 적합. 푸시모델에서는 제 때 처리 못하면 버퍼로 감. 근데 풀에서는 오프셋을 사용해서 일괄적으로 가져올 수 있음
- 단점
  - 브로커에 메시지가 없어도 풀링해오면 자원 낭비 ⇒ long polling으로 조금은 해결

## Consumer rebalancing

어떤 consumer가 어떤 partition을 책임지는 지 다시 정하는 프로세스

consumer로부터 받는 heartbeat를 보고 오프셋 정보를 관리하는데, consumer rebalancing이 필요하면 heartbeat에 대한 응답으로 재연결을 요구하고 그 때 리밸런싱함.

## state storage

브로커의 state storage에는 다음 정보들이 저장

- consumer에 대한 파티션의 배치 관계
- 각 consumer group이 각 파티션에서 마지막으로 가져간 메시지의 오프셋

state storage의 특성

- 읽기, 쓰기 빈번하지만 데이터의 양은 적음
- 데이터 갱신은 빈번하지만 삭제는 거의 없음
- 읽기와 쓰기 연산은 무작위적 패턴
- consistency가 중요(일관성)

⇒ Apache ZooKeepr 사용이 적합

## 메타데이터 저장

아래 정보들이 브로커의 메타데이터임

- 토픽 설정
- 속성 정보
- 파티션 수, 메시지 보관 기간, 사본 배치

⇒ 주키퍼에 `메타데이터 저장소`, `상태 저장소`, `조정 서비스` 역할을 주자.
