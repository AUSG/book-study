# 1. Guard Clauses

-   아래와 같은 방식 대신 Guard Clauses를 사용하라

    ```kotlin
    if (condition) {
       something();
    }
    
    // Guard Clauses
    if (!condition) return
    ```

    -   early return 이라고 불리는 방식과 유사한 듯

-   하지만 guard clauses를 너무 과도하게 사용하면, 이것이 더욱 복잡도를 높일 수도 있음

-   또한, guard clause 는 아래와 같은 경우에서만 사용가능

    ```kotlin
    if (condition) {
       ...all the rest of the code in the routine...
    }
    ```

     -    아래와 같은 상황에서는 helper method로 추출해서 사용가능

          ```kotlin
          if (condition) {
          	...some code...
          }
          ...some other code...
          ```

          

# 2. Dead Code

-   실행되지 않는 Dead code는 지워라
-   누군가 열심히 작성한 코드를 지우는게 이상하게 느껴질 수도 있고, 언젠가 또 쓰지 않을까 생각이 들 수도 있음.
    -   하지만 지워라
    -   언젠가 또 쓸 것 같으면 어떡하냐고? version control 시스템은 폼이 아니다.
-   지우기 전에 logging을 하여 실제 환경에서 사용하는지 체크하고 지워라
-   물론 지울 때도, 항상 조금씩 천천히 지워라



# 3. Normalize Symmetries

-   코드는 유기적으로 성장하며, 같은 문제에 대하여 다른 방식, 다른 시간 혹은 다른 사람으로 부터 변경될 수 있다.
    -   이로인해 코드를 읽는 것에 어려움이 생긴다.
-   코드를 쓰는 방식을 통일하여 한 방식으로 사용하라. 이렇게 하면, 읽는 사람도 쉽게 읽을 수 있다.



# 4. New Interface, Old Implementation

-   인터페이스가 이해하기 어렵다면, 인터페이스를 구현하여 사용하라.



# 5. Reading Order

-   어떤 파일을 읽다가 마지막에 전체 파일을 이해할 수 있는 세부사항이 나왔다고 가정해보자. 이런 경우에 독자를 위해 적당히 순서를 정리하자.
    -   코드는 작성되는 시간보다 읽히는 시간이 더 많다.
-   물론, 이걸 정리하다보면 다른 것도 정리하고 싶어지는 유혹에 빠질 수 있는데 일단 순서부터 정리하자.
-   몇몇 언어는 순서에 민감하여 순서를 변경하는게 어려울 수 있지만, 그런 경우에도 독자에게 가장 관련있는 정보만이라도 순서를 정리하라.
-   자기 자신도 독자이기 때문에, 독자의 관점에서 적당한 순서를 생각하여 정렬해보자.



# 6. Cohesion Order

-   넓게 분산되어 있는 코드를 변경해야할 때, 변경해야 할 요소를 인접하도록 순서를 재배치하라.
    -   서로 결합도가 높은 코드나 파일의 위치를 변경하라.
-   만약 결합도를 제거할 수 있다면, 그것을 제거하라
    -   cost(decoupling) + cost(change) < cost(coupling) + cost(change)

-   하지만 결합도를 제거하는 것은 여러 이유 때문에 어렵다.
    -   어떻게 하는지 모를 가능성
    -   시간적 비용적 문제
    -   관계 문제



# 7. Move Declaration and Initialization Together

-   변수의 이름은 변수의 역할에 대한 힌트를 제공하고, 초기화는 이름에 담긴 메시지를 강제한다.
    -   변수의 선언과 초기화가 떨어져있으면 읽기 어렵다
    -   떨어져있는 초기화 구문을 보면 변수의 맥락을 까먹을 수 있다.
-   각 변수가 사용되기 직전에 선언되고 초기화 될 수 있도록하라.
    -   데이터 종속 순서를 지켜야 함. ( b를 사용할 때, a가 먼저 초기화 되어있어야하면 순서를 잘 지켜야 함 )
    -   데이터 종속 순서를 파악하는 것은 어려울 수 있으니 차근차근 조금씩 변경해야 함.



# 8. Explaining Variables

-   표현식은 발전하면서 점점 커져간다. 
    -   너무 커져가면 그것을 분리하여 표현식의 의도를 갖는 변수로 분리하라.
-   이를 통해, 더 구체적인 표현을 하게 될 수 있고 어렵게 이해한 내용을 코드에 표현할 수 있음.
    -   또한, 다음에 변경해야 할 때 더 쉽게 읽을 수 있게함.



# 9. Explaining Constants

-   코드를 읽다보면 특정 상수가 어떤 의미를 가지고 있는지 파악하기 어려움.
-   이럴 때, symbolic constant를 만들어서 literal constant를 대체하라.
-   같은 literal이 다른 의미로 사용되고 있을 때가 있음. 이럴 때는 symbolic constant를 사용하면 어려움이 생길 수 있음



# 10. Explicit Parameters

-   몇몇 데이터가 사용되는 루틴으로 명시적으로 전달되지 않는 경우, 루틴을 분리하여 명시적으로 전달하라.
-   map의 형태로 파라미터가 전달되는 경우가 있는데, 이런 경우 어떤 데이터가 필요한지 어렵고 매개변수를 수정하여 악용할 여지가 있음.
-   또한, 환경 변수를 사용하는 경우 그것을 위로 올려서 읽기 쉽고 테스트하기 쉽게 변경해야 함.



# 11. Chunk Statements

-   구문을 읽다가 파트가 나뉜다고 생각되는 부분이 있다면, 그것을 빈줄로 구분하라.
-   이런 작은 변화가 Tidy First의 철학의 한 부분임.
    -   소프트웨어 설계는 변화를 가능하게하고, 작은 소프트웨어 설계는 작은 변화를 가능하게 한다.
    -   소프트웨어 설계는 더 많은 소프트웨어 설계를 쉽게 할 수 있도록 한다. 하지만, 소프트웨어 설계에 매몰되어 변화를 잊지말라.
-   이렇게 구문을 구분했으면, Explaining Variable, Extract Hepler 혹은 Explaining Comments 같은 방식을 사용하여 더 개선해보자.



# 12. Extract Helper

-   루틴 내부에 다른 코드와 상호작용이 제한되어있으면서, 명확한 목적이 있는 코드가 존재하는 경우가 있음.
    -   이를 helper 로 추출하라
-   이런 추출의 2가지 특별한 경우
    -   큰 루틴 내에서 몇 개의 줄을 변경해야 하는 경우.
        -   헬퍼 메소드로 추출하고, 변경한 뒤 헬퍼로 인라인하기
    -   시간적 결합도가 있는 경우 ( a() 가 b() 호출전에 호출되어야하는 경우 )
        -   그 둘을 하나의 헬퍼 메소드로 추출하여 그것을 사용하는 루틴에서 호출하도록 변경 

-   helper 메소드를 만들고 그것들의 변경을 한 번에 해주는 축복같은 도구들이 존재하니 helper를 도입하는 것을 걱정하지 마라



# 13. One Pile

-   가끔 너무 여러 부분으로 분리되어 있는 코드들이 이해를 방해하는 경우가 있음.

    -   필요한 만큼 인라인해서 하나의 큰 파일로 만들고, 거기서 정리를 시작하라.
-   코드는 읽는 것이 가장 비용이 많이 듬. 이론적으로 결합도를 줄이기 위해 작은 조각들로 코드를 배치하는 경향이 있는데, 때로는 이게 코드를 이해하기 어렵게 함.
    -   한 곳에 뭉쳐서 이해하기 쉽게하고, 그 후 다시 분리해야 함.
-   코드를 분리해야 하는 상황
    -   길고 반복되는 인자 리스트
    -   반복되는 코드 ( 특히 반복되는 조건 )
    -   헬퍼 메소드의 잘못된 이름
    -   변경 가능한 데이터 구조를 공유하는 경우



# 14. Explaining Comments

-   "아 이게 그거였구나" 라는 생각이 들면 주석을 달아라
-   미래의 독자 혹은 15분전의 날르 생각하면서 명확하지 않은 부분을 기록하라
-   결함을 찾았다면, 그 경우에도 주석을 달 좋은 타이밍임



# 15. Delete Redundant Comments

-   코드와 완전히 동일한 의미를 갖는 주석을 제거하라
-   코드가 발전함에 따라 주석이 항상 함께 발전하지 않을 수 있음.
-   완전히 동일한 의미를 갖는 주석은 독자의 시간을 낭비함



# 16. Separate Tidying

-   PR에서 일괄적으로 기능을 구현하고 코드를 정리하는 PR을 적절히 분리하라.
    -   물론 이것을 합치거나 분리하는 것도 결국 트레이드 오프
        -   모두 합쳐진 PR을 전체를 한 번에 보여주지만 리뷰어가 유용한 피드백을 주기에는 너무 많을 수 있음
        -   작은 PR은 피드백 유도가 가능하지만, 의미 없게 될 수 있음.

-   리뷰 속도도 연관이 있음. 리뷰가 빨라지면 더 작은 PR을 많이 많들 수 있음. 또한 이런 PR은 더 빠른 리뷰를 촉진함.
-   정리 PR에 대해서 리뷰하지 않는 실험도 해볼 수 있음. 이러면 더 작은 정리 PR도 많이 할 수 있게 됨.



# 17. Chaining

-   Guard clause
    -   가드 절을 사용하면, 헬퍼 메소드 등으로 추출할 가능성이 생김

-   Dead code
    -   데드코드 제거 후 어떻게 코드를 정렬할지 고민할 수 있게 됨
-   Normalize symmetries
    -   동일한 코드를 동일하게, 다른 코드를 다르게 만들면 코드를 그룹화 할 수 있게 됨.
-   New interface, old implementation
    -   새로운 인터페이스를 만들면, 그것을 사용하고 싶어지기에 하나씩 변경해야함. 이를 통해 새로운 정리정돈을 이끌 수 있음.
-   Reading order
    -   일근 순서를 바꾸면, Normalize symmetries 할 수 있는 기회를 갖게됨.
-   Cohesion order
    -   순서를 응집도에 따라 변경하면, 헬퍼 메소드로 추출할 수 있는 기회가 생김. 이는 결국 더 큰 설계 변경을 이끌 수 있음.
-   Explaining variables
    -   Explaining variable의 할당을 헬퍼 메소드로 변경할 수 있으며, 중복된 코멘트도 제거할 수 있게 될 것임
-   Explaining constants
    -   Explaining constant를 통해 cohesion order를 할 수 있게 됨. 이는 미래의 변경을 용이하게 함.
-   Explicit parameters
    -   파라미터를 explicit하게 하면, 파라미터의 집합을 그룹화하고 코드를 이동할 수 있게 됨. 정리를 하면서 드러나는 새로운 추상화에 집중할 수 있게 될 것임.
-   Chunk statements
    -   청크마다 주석을 달 수 있게 되고, 헬퍼로 추출할 수 있게 됨
-   Extract helper
    -   헬퍼로 추출하고 가드절을 도입하거나 설명하는 상수나 변수를 도입하고 중복된 주석도 제거 가능
-   One pile
    -   하나로 합치고 나서 청크단위로 나누거나 주석을 작성하거나 헬퍼로 나눌 수 있음
-   Explaining comments
    -   주석을 달고 나서 설명하는 상수나 변수를 도입하고 중복된 주석도 제거 가능
-   Delete redundant comments
    -   중복된 주석을 제거하면서 읽는 순서를 정렬하거나 파라미터를 명시적으로 개선할 수 있게 됨



# 18. Batch Sizes

-   배포당 정리를 얼마나 할 것인가? 어느 정도의 정리가 배포에 쉬울까?
    -   위에 대한 고민은 항상 트레이드 오프임
-   Collisions
    -   정리가 많아질 수록 통합에 딜레이가 발생할 수 있음
    -   merge conflict 같은 것이 발생하면, 그것을 수정하는데 비용이 듬
-   Interactions
    -   실수로 동작변경이 될 가능성도 정리 횟수에 따라 증가함
    -   이것도 merge 비용을 증가시킴
-   Sepculation
    -   다음 동작 변경을 서포트하기 위해 정리를 한다고하지만, 이것이 더 많은 비용을 가져올 수 있음.
-   리뷰 비용을 줄이는 방식도 고민해야함.



# 19. Rhythm

-   동작 변경전 한시간 이상의 정리는 동작변경을 일으키는데 필요한 최소 구조 파악에 실패했음을 의미할 수 있음.
-   80%의 변경사항은 20%의 파일에서 발생함.
-   처음에는 많은 부분을 정리하더라도, 이미 정리된 코드에서 동작을 변경하는 자신을 발견할 수 있음. 결국 대부분의 코드에 손대지 않았지만 다시 코드가 정리되지 않은 것을 발견할 수 있음.
-   그렇기에 정리는 몇분에서 한시간이 드는 작업이 될 수 있음.



# 20. Getting Untangled

-   매몰비용의 오류에 빠지지 마라.
-   다시 구현한는 것에 대한 고민을 해봐라. 다시 구현함으로써 새로운 것을 발견할 가능성이 높아지고, 더 많은 가치를 찾게 될 수 있음.
-   실타래를 풀기위해서는 실타래가 엉켜있다는 것 부터 파악해야 함.
    -   실타래를 풀어야 할 필요성을 깨닫게 되면, 작업의 규모가 작아짐.



# 21. First, After, Later, Never

-   정리에 대한 타이밍에 대해 이야기해보자.
-   Never
    -   코드의 동작을 다시는 바꾸지 않을 때
    -   하지만 이런 경우는 드물다.
    -   물론 실제로 이런 경우가 있긴함. "고장나지 않으면 고치지 말라"
-   Later
    -   나중에 한다는 것은 그냥 현재를 정당화하는 것
    -   본인에게 "시간이 충분하다면 어떻게 일할 것인지" 물어봐라
    -   즉각 적인 보상이 없는 대량의 정리를 해야하는 경우
    -   정리를 완료하면 궁극적이 보상이 있는 경우
    -   작은 단위로 정리할 수 있는 경우
-   After
    -   다음을 기다리면 비용이 더 많이 드는 경우
    -   나중에 정리하면 완료했다는 느낌을 못받는 경우
-     FIrst
    -   즉각적인 보상이 있거나 이해를 향상시키거나 값싸게 변경할 수 있는 경우
    -   어떤 정리를 어떻게 하는지 아는 경우



# 22. Beneficially Relating Elements

-   Elements
    -   경계가 존재함
    -   하위 요소가 존재함
-   Relating
    -   element 간에는 관계가 존재함
    -   그 관계는 "Calls/called by" 같은 관계임
-   Beneficially
    -   하나의 큰 덩어리는 작동하지만 그것을 이해하는 것이 어려움
    -   중간 요소를 설계하면 그것들이 서로에게 유익하게 작동함.
-   Beneficially Relating Elements
    -   요소들의 관계에서 유익함을 가져오는 것이 설계라고 할 수 있음.
    -   소프트웨어 설계를 하는 사람들은 단지 아래와 같은 행동을 할 수 있음. ( 물론 쉽지 않음 )
        -   요소를 만들고 제거함
        -   관계를 만들고 제거함
        -   관계의 이익을 증가시킴



# 23. Structure and Behavior

-   소프트웨어는 두 가지의 가치를 만듦
    -   오늘 하는 일
        -   시스템의 행동을 의미함
        -   행동은 입출력과, 불변값으로 나뉨
        -   행동은 가치를 창출하고, 사람들이 반복적으로 직접 하는 것을 대신해줌 ( 소프트웨어로 하는게 1달러 들고, 사람들이 직접하는게 10달러 들면 비즈니스가 될 수 있음 )
    -   내일 할 수 있는 새로운 가능성
        -   시스템의 구조를 의미함
        -   구조는 시스템의 행동에 영향을끼치지 않음.
        -   옵션을 창출하여 새로운 기능 추가를 어렵거나 쉽게 할 수 있음.
        -   하지만 구조는 행동처럼 가치 측정이 어려움



# 24. Economics: Time Value and Optionality

-   오늘의 1달러는 내일의 1달러보다 가치있음. 빨리 벌어서 나중에 써야 함.
-   혼란스러운 상황에선 옵션이 물건보다 나음. 불확실성에 맞서 옵션을 만들어라.
-   소프트웨어의 설계는 "빨리 벌고 나중에 써야한다" 와 "옵션을 만들어야 한다" 두 가지의 상호작용임.



# 25. A Dollar Today > A Dollar Tomorrow

-   미래의 받을 돈 보다 오늘의 돈이 가치가 있음.
-   소프트웨어 시스템의 가치는 현금과 유사한 특징을 가짐
-   먼저 정리하는 것은 정리하지 않는 행동 변화의 비용보다 더 저렴할 수 있음. 이런 경우 항상 먼저 정리해야 함



# 26. Options

-   불확실성이 높을 수록 단순히 구현하는 것보다 옵션이 더 가치있음.
-   소프트웨어 설계를 옵션의 관점에서 생각하면..
    -   행동 변화를 만들 수 있는 포텐션이 더 나음
    -   더 오래 개발할 수 있다면 더 나음
    -   미래에 더 값싸게 개발 할 수 있으면 더 나음
    -   옵션을 만들 수 있는 설계를 더 값싸게 할 수 있으면 더 나음



# 27. Options Versus Cash Flows

-   cost(tidying) + cost(behavior change after tidying) < cost(behavior change without tidying)
    -   위와 같은 상황일 때 먼저 정리하는 것이 좋다는 것은 자명함
-   cost(tidying) + cost(behavior change after tidying) > cost(behavior change without tidying)
    -   먼저 정리하지말아야하는 경우. 하지만 먼저 정리하면서 이익이 되는 경우가 있음.
    -   경제적으로 판단이 필요함.



# 28. **Reversible Structure Cahnges**

-   구조 변경과 기능변경은 이발과 타투의 차이와 유사
-   구조 변경
    -   되돌릴 수 있음. 헬퍼함수를 만들었다가 인라인 하는 것이 가능하듯이 
-   기능 변경
    -   오류가 나면 그것을 되돌릴 수 없음. 영구적인 손실로 이루어짐.
-   구조 변경은 쉽게 되돌릴 수 있기 때문에, 경제적으로 더 나음. 실수를 피하기 위해 많은 비용이 들지않음.
-   "서비스 추출"과 같은 설계는 쉽게 되돌릴 수 없음. 먼저 프로토파이핑을 해보고, 피처플래그등을 사용해야 함.
    -   이를 통해 "서비스 추출" 같은것을 되돌릴 수 있게 만듦
-   결정이 코드 베이스 전체에 대한 확장 가능성이 있다면 조금 생각해봐야 함. 그 후 조금씩 정리하여 되돌릴 수 있는 결정으로 만들어야 함.



# 29. Coupling

-   한 요소를 변경할 때, 다른 요소도 변경해야하는 결합도가 높은 경우 그 프로그램이 비싸다고 할 수 있음.
-   결합도는 소스코드를 분석하는 것만으로 확인할 수 없음. 두 요소가 결합되었는지 판단하려면 어떤 변화가 일어났거나 일어날 가능성이 있는지 알아야함.
-   결합도라는게 두 요소 사이에만 있으면 별로 문제가 없지만 실제로는 많은 요소간에 관계가 있음.
    -   1 to N
        -   하나의 요소가 N개와 결합된 경우
            -   이 경우는 소프트웨어 툴을 이용해 변경을 좀 더 쉽게 할 수 있음. ( 자동 리팩터링 기능 같은 것 .. )
    -   Cascading
        -   하나의 요소가 암시적으로 다른 요소에 변경을 가하고, 그 변경이 다른 변경을 일으키는 경우
            -   이 경우는 더 복잡함. 하나의 변경 비용이 다른 변경 비용에도 영향을 끼침.
-   결합도라는 것은 관계만을 의미하는 것이 아님. 하나의 변경이 다른 것의 변경도 유발한다는 것도 알아야함.
-   결합도는 소프트웨어의 비용을 증가시킴



# 30. Constantine’s Equivalence

-   소프트웨어 개발의 70% 정도 비용은 유지보수에 들어감.
-   결합도가 소프트웨어 개발에 영향을 끼치는 방식을 이해해야함.
-   소프트웨어의 비용은 사실상 변경의 비용이라고 할 수 있으며, 이것은 70% 라는 수치 조차 낮게 평가된 수치임.
-   가장 큰 변화의 비용이 사실상 모든 변경의 비용과 동일하며, 이것은 결합도와 관련이 있음.
    -   하나의 변경이 다른 것의 변경에 영향을 끼치기 때문
-   이로 인해 결국 소프트웨어의 비용은 결합도에 달려있다는 것을 알 수 있음.



# 31. Coupling Versus Decoupling

-   커플링은 레고조각과 같이 직접 밟기 전에는 드러나지 않는 경향이 있음.
-   당시에는 더 빠르게 개발하는 것이 더 싸서 그렇게 했을 수 있지만, 현재는 당시가 아닌 나중임.
    -   그 떄는 올바른 결정이긴 했음.
-   시스템에 커플링을 도입하는 것의 정당한 이유중 하나는 그 때는 문제가 되지 않았기 때문임.
-   또, 어떤 커플링은 사실 피할 수 없음.
-   커플링의 존재보단 그 커플링 비용을 지불할지 아니면 디커플링할지가 더 중요함. ( 이것의 축소판이 먼저 정리하기임 )
-   한 종류의 커플링을 줄일수록 다른 종류의 변화에 대한 커플링이 늘어날 수 있음. 그렇기에 모든 커플링을 제거하려고 애쓸 필요는 없음.
    -   결국 이것도 트레이드 오프임



# 32. Cohesion

-   커플링된 요소는 동일한 포함요소의 하위요소여야됨.
-   커플링되지 않은 요소는 다른 곳으로 분리되어야함.
-   10개의 함수가 포함된 모듈이 있고 3개가 커플링되어있다면, 나머지 7개는 어디로 가야할까?
    -   첫번째 방법
        -   결합된 요소를 하위 요소로 묶기. 
        -   3개를 포함한 서브모듈을 만들 수 있음.
        -   원래 모듈은 이제 나머지 7개만 남아서 커플링이 없어 응집력이 떨어질 수 있지만, 더 나빠지지는 않을 것임
    -   두번째 방법
        -   결합되지 않은 요소를 다른 곳에 배치 ( 소프트웨어 설계와 연관 되어 있음 )
        -   그 함수들이 어느 곳과 결합되어 있는지 찾고 그것을 그들과 관계있는 곳으로 배치

-   급격하게 재배치하지 말고 한번에 하나씩만 재배치해야함. 모두가 스카우트 룰을 지킨다면 최종적으로 더 나은 상태가 될 것임.

