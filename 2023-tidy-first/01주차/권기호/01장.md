# Guard Clauses

- Gaurd Cluase로 코드의 중첩을 줄이고 가독성을 높일 수 있다.

    ```
    if (condition)
        ... some code ...

        if (other condition)
            ... some code ...
    ```

    ```
    if (not condition)
        return 

    if (other condition)
        return
    ... some code ...
    ```

- Gaurd Clause를 과도하게 사용하지 마라. 
    - 7~8개의 Gaurd Clause가 포함된 루틴은 오히려 가독성을 악화한다.
- 프롬프트가 만족할 경우에만 Gaurd Clause를 사용해라.

# Dead Code
- 코드를 실해하지 않으면 삭제해라.
    - 데드 코드의 식별이 어려울 수도 있다. 코드가 사용되지 않을 것으로 의심되면 기록하여 미리 정리해라.
- 나중에 필요하면 어쩌지?
    - 버전 관리로 이전 버전에 유지되지만, 현재는 보이지 않는다.

# Normalize Symmetries
- 코드는 유기적으로 성장한다.
- 필요한 코드를 모두 한꺼번에 작성할 수 없다.

-> 3장 이해 실패.

# New Interface, Old Implementation
- 복잡하거나 혼란스러워서 호출하기 어려운 경우, 편리하고 간단한 새로운 인터페이스를 구현해서 호출해라.

# Reading Order
- Reader의 입장으로 코드 파일의 순서를 재배치해라.
  - 추가적인 개선도하지 말고, 코드 이해를 높일 방식으로 재구성해라.
  -  코드가 작성된 원래 순서에서 벗어나더라도 독자가 더 효과적으로 코드를 이해할 수 있는 방식으로 코드를 제시하는 것이 중요하다.

- 결정은 맥락 및 잠재적인 독자의 선호도에 따라 내려져야 한다

# Cohesion Order
- 널리 분산된 여러 코드를 변경할때
  - 코드를 재배치하여 변경해야 할 요소들을 인접하게 만드는 것이 좋다.
  - 즉 응집도 순서를 정렬해보는 것
- 디렉토리 내 파일에 대해서도 두 파일이 결합되어 있다면 같은 디렉토리에 위치하게 해라.
- `cost(decoupling)+cost(change)<cost(coupling)+cost(change)`
  - 결합을 없애는 비용과 변경하는 비용이, 결합을 유지하면서 변경하는 비용보다 작을 때만 결합을 없애는 것이 합리적

- 다양한 이유로 이것이 현실적으로 어려울 수 있다.
  - 결합을 없애는 것은 지적으로 어려울 수 있다 (어떻게 하는지 모를 수 있음).
  - 결합을 없애는 것은 시간/비용적으로 부담스러울 수 있다 (지금은 그 시간을 내기 어려울 수 있음).
  - 결합을 없애는 것은 관계적으로 부담스러울 수 있다 (팀이 현재 감당할 수 있는 변화 한도에 도달한 상태일 수 있음).

# Move Declaration and Initialization
- 변수의 이름은 계산에서의 역할을 나타내는 힌트를 제공하고, 초기화는 이름의 메시지를 강화한다.
- 변수 선언과 초기화를 분리하는 코드는 읽기가 어렵다.
  - 초기화를 선언으로 이동시킴으로써 가독성을 향상할 수 있다.
- 변수의 선언과 초기화를 분리한 후 초기화를 선언 바로 위로 이동시키는 것이 더 읽기 쉽다.
  - 코드를 읽는 사람이 변수를 사용하기 직전에 선언하고 초기화하는 것이 더 직관적이기에 읽기 쉽다.
- 변수 및 코드의 순서를 변경할 때에는 데이터 간의 의존성을 의식해야 한다.
  - 실수 조심!

# Explaining Variables
- 모든 표현은 작게 시작해도, 계속 커지기 마련
  -  읽기 어려워짐
- 큰 표현식의 일부를 이해했을 때 해당 표현식의 의도를 나타내는 변수로 추출해라.
  - 큰 표현식을 변수로 추출하면 코드를 이해하기 쉬워지며, 해당 표현식을 변경할 때 훨씬 용이하다.

예를 들어, 다음과 같은 그래픽 코드가 있다고 가정합니다:

```java
return new Point(
    ...expression...,
    ...expression...
);
```
이러한 표현식 중 하나를 변경하기 전에, 먼저 정돈을 고려하세요:

```java
x := ...expression...
y := ...expression...
return new Point(x, y);
```

- 이해를 쉽게 만들뿐만 아니라, 이제 이러한 표현식 중 하나를 더 쉽게 변경하고, 코드가 다음에 변경될 때 더 빠르게 읽을 수 있게 해준다.

- 항상 feat, refactor를 분리해라.

# Explaining Constraint
- 이해할 수 있는 매직 넘버를 사용하라.
- 변경되거나 함께 이해되어야 하는 상수를 한 곳에 모아라.

# Explicit Parameters
- 코드를 변경하려는데 명시적으로 전달되지 않은 데이터가 있을 때, 해당 매개변수를 분리해라.
- 상위 부분에서 매개변수를 수집하고 이를 명시적으로 두 번째 부분에 전달해라.

```javascript
params = { a: 1, b: 2 }
foo(params)
function foo(params)
    ...params.a... ...params.b...
```

`foo`를 분리하여 매개변수를 명시적으로 전달하세요:

```javascript
function foo(params)
    foo_body(params.a, params.b)

function foo_body(a, b)
   ...a... ...b...
```
- 코드가 읽기 쉬워지고 테스트 및 분석이 쉬워진다.

# Chunk Statements
- 소프트웨어 디자인을 너무 큰 일로 만들지 말라.
- 소프트웨어 디자인은 변경을 가능케 한다. 약간의 소프트웨어 디자인은 변경을 조금 더 쉽게 만들 수 있다.

- 중요한 점은 복리 효과
  - 소프트웨어 디자인은 또한 더 많은 소프트웨어 디자인을 쉽게 만든다.

# Extract Helper
- 명확한 목적과 나머지 코드와 상호 작용이 제한된 블록 코드를 발견하면, 해당 블록을 헬퍼로 추출해라.
- 동작 방식이 아닌 목적에 따라 헬퍼 루틴의 이름을 지어야 한다.

- 리팩터링을 수행하는 것은 자동 리팩터링이 없으면 까다로울 수 있다.
  - 리팩터링을 제공하는 환경에서 작업하자.


```javascript
routine()
    ...변하지 않는 부분...
    ...변해야 하는 부분...
    ...변하지 않는 부분...
```

다음과 같이 변경됩니다:

```javascript
helper()
    ...변해야 하는 부분...
routine()
    ...변하지 않는 부분...
    helper()
    ...변하지 않는 부분...
```

# One Pile
- 작은 조각들로 나누어져 있어 이해에 어려움이 있다.
- 필요한 만큼 코드를 인라인하여 모든 것을 하나의 큰 덩어리로 만든 다음, 그 상태에서 정돈해라.

- 작은 조각이 상호 작용하는 방식 때문에 코드를 이해하기 어려울 수 있다.
  - 먼저 코드를 한데 뭉쳐 놓아야 하며, 그런 다음 새로운, 이해하기 쉬운 부분을 추출해야 한다.

# Explaining Comments
- 코드를 읽다가 깨달은 순간에 이를 기록해라.
  - 코드로부터 명확하지 않는 항목들로

- 특정한 사람에게 쓰는 것이 좋다.
- 결함을 발견하면 즉시 주석을 추가하는 것이 좋다.

# Delete Redundant Comments
- 주석이 코드와 동일한 내용을 설명할 때 해당 주석을 제거해라.
- 시스템이 변경됨에 따라 정확성을 이중으로 확인할 수 없으며, 코드가 진화함에 따라 주석이 중복될 수 있다.