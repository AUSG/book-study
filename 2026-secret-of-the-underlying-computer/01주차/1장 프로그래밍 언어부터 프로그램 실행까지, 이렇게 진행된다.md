```toc
```

# 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

## 여러분이 프로그래밍 언어를 발명한다면?

- 스위치를 조합하면 복잡한 불 논리를 표현할 수 있다는 사실을 발견하고 이를 기반으로 CPU를 만들었다
- -> [Boolean algebra - Wikipedia](https://en.wikipedia.org/wiki/Boolean_algebra)

- CPU는 아주 간단한 작업만 수행할 수 있지만 무척 빠르다

- 기계어 -> 어셈블리어 -> 프로그래밍 언어 순으로 발전
- 어셈블리어를 나열해두니, 
	- 명령 -> 문장(statement)
	- 규칙 및 패턴이 보이기 시작 (if, else, for 등)
	- 반복되는 명령어 -> 함수 with 파라미터

- 위 패턴의 문장이 무한히 중첩될 수 있음 -> 일종의 재귀
- 이를 표현하면 언어의 문법이 된다.

[Backus–Naur form - Wikipedia](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)

```
if: if expr statement else statement
for: while expr statement
statement: if | for | statement
```

- 이를 바탕으로 syntax tree를 구성하면, 리프 노드는 아주 간단해져 이를 기계 명령어로 번역할 수 있음

![](files/Pasted%20image%2020260214205519.png)

- 고급 언어는 추상적 표현이 뛰어나서 사용하기 쉽지만 저수준 계층에 대한 제어 능력이 떨어진다
- 따라서 직접 저수준 계층의 세부 사항을 제어할 수 있어야 하는 운영 체제 중 일부분은 어셈블리어로 작성된다.

## 컴파일러는 어떻게 작동하는 것일까?

- 컴파일러는 소스 파일을 실행 파일로 변환

- 컴파일러는 텍스트를 잘게 쪼갠다
- `int` -> 이건 키워드고 `int`를 의미
	- 이런 것처럼 각 항목에 추가 정보를 결합한 것을 `token`이라고 함
- 컴파일러가 하는 첫 번째 작업은 소스 코드를 돌아다니면서 모든 토큰을 찾아내는 것
- 이런 과정을 어휘 분석(lexical analysis)이라고 함

![](files/Pasted%20image%2020260216144508.png)

- 단순히 토큰만 찾아내는 게 아니라, 구문에 따라 규칙을 확인함
- `while` 뒤에는 `(`가 오고 그 안에는 `bool` 표현식이 온다 등
- 성립하지 않으면 syntax error를 보고

- 이런 과정을 `parsing`이라고 하고, 트리로 해석해낸 구조를 표현 -> 구문 트리

![](files/Pasted%20image%2020260216144640.png)

- 이렇게 구문 트리를 생성하는 전체 과정을 구문 분석이라고 함

- 구문 트리가 생성되면, 이상이 없는지 확인
- 정수에 문자열을 더하지 않는지 등등
- 이를 의미 분석(semantic analysis)이라고 함

- 의미 분석이 끝나면 좀 더 다듬어진 형태인 중간 코드(Intermediate Representation Code, IR Code)를 생성
- 이 과정에서 추가적인 최적화가 진행됨

- 이 이후에는 어셈블리어 코드로 변환
- 그리고 어셈블리어를 기계 명령어로 변환

- 이렇다고 바로 실행 파일이 되냐? 그건 아님
- 기계 명령어 데이터는 대상 파일(object file)이라고 함
- 소스 파일에는 각각의 대상 파일이 있다. 소스 코드 3개면 대상 파일 3개
- 우리가 원하는 건 하나의 실행 파일
- 따라서 이런 대상 파일을 합쳐주는 무언가가 필요 -> Linker

## 링커의 말할 수 없는 비밀

- 외부 코드는 정적 라이브러리, 동적 라이브러리 형태로 제공됨

- 링커는 컴파일러가 생성한 대상 파일 여러 개를 하나로 묶어 하나의 최종 실행 파일 생성

- A 모듈이 B 모듈을 사용하는 경우 두 모듈 사이에 종속성이 있다고 표현
- 링커의 일 중 하나는 종속성이 올바르게 설정되었는지 확인하는 것
- 외부 심벌에 대한 실제 구현이 단 하나만 있어야 하고, 이를 찾아내 연결하는 과정을 symbol resolution이라고 한다

- 이렇게 다 연결하면, 하나의 실행 파일로 만들 수 있음

- 한 프로그램이 다른 프로그램을 참조하는 경우 어디에 위치할지 모르므로 임시적으로 위치를 설정함. 실제로 실행 파일을 만들 때 위치가 결정되므로 임시 위치를 실제 위치로 바꿔주는 작업이 필요
- 이를 재배치(relocation)라고 함

![](files/Pasted%20image%2020260216145153.png)

- 심벌 해석
	- 심벌? 전역 변수, 함수의 이름 등 모든 변수의 이름
	- 지역 변수는 외부에서 참조할 수 없으므로 링커의 관심 대상이 아님
	- 링커가 하는 건 참조하고 있는 각각의 모든 심벌마다 대상 정의가 존재하고, 단 하나만 존재하는지 확인

- 그렇다면 링커는 어떤 외부 심벌을 참조하고 있고, 외부에서 참조할 수 있는 심벌은 뭔지 어떻게 알까?
- 이 정보는 컴파일러가 알려준다
- 어떻게? 
- 컴파일러는 기계어뿐만 아니라 명령어를 실행시키는 데이터도 생성한다
- 데이터는 대상 파일에 반드시 포함되며, 대상 파일에는 중요한 두 영역이 포함된다.
	- 명령어 부분 : 소스 코드가 기계 명령어로 변환된 부분. 이를 code section이라고 함
	- 데이터 부분 : 소스 파일의 전역 변수가 저장되는 부분. 이를 data section이라고 함

![](files/Pasted%20image%2020260216145616.png)

- 링커가 실제 심벌을 찾지만, 링커의 부담을 줄여주기 위해 소스 파일마다 외부에서 참조 가능한 심벌이 뭐고, 어떤 심벌을 참조하고 있는지를 기록
- 이를 symbol table이라고 한다

- 수많은 기본 라이브러리가 있고, 이 중 일부를 가져다 쓴다고 해보자
- 매번 기본 라이브러리를 컴파일하고 링크하려면 시간이 오래 걸릴 거다
- 그렇다면 이런 라이브러리를 별도로 컴파일 후 패키지로 묶고, 구현된 모든 함수의 선언을 포함하는 헤더 파일을 제공하는 건 어떨까?
- 이를 정적 라이브러리라고 한다
- 윈도우에서 `.lib`, 리눅스에서는 `.a` 파일

![](files/Pasted%20image%2020260216150029.png)

- 실행 파일 생성 때는 자신 코드만 컴파일하고, 미리 컴파일된 정적 라이브러리는 링크만 하면 된다.
- 이를 정적 링크(static linking)라고 한다.

![](files/Pasted%20image%2020260216150104.png)

![](files/Pasted%20image%2020260216150125.png)

- 실행 파일에도 코드 영역, 데이터 영역이 있다
- 하지만 실행 파일에는 특수 심벌인 `_start`가 있고, CPU는 이 심벌 주소에서 프로그램 실행에 필요한 기계 명령어를 찾는다
- 그 후에 `main` 실행

- 정적 링크는 라이브러리를 실행 파일에 복사하므로 C 표준 라이브러리처럼 거의 모든 프로그램에 적용되는 걸 정적 링크하면 모든 실행 파일에 복사되므로 중복이 엄청 커진다
- 또한 정적 라이브러리가 바뀔 때마다 모든 종속된 프로그램은 재컴파일이 필요하다.

- 이에 대한 해결 방법은 동적 라이브러리(dynamic library), shared library, dynamic linked library
- 윈도우의 DLL
- 리눅스는 `.so`, `lib` 접두사
	- `libMath.so` 등 

- 동적 라이브러리에도 정적 라이브러리처럼 코드 영역, 데이터 영역 포함됨
- 단, 사용 방식이 다름
- 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등만 실행 파일에 포함됨

![](files/Pasted%20image%2020260216150433.png)

- 이렇게 참조된 동적 라이브러리 필수 정보는 실행 파일 내에 저장된다

![](files/Pasted%20image%2020260216150449.png)

- 이 정보는 동적 링크(dynamic linking)가 일어날 때 사용됨
- 두 가지 방식이 있음

- 프로그램이 메모리에 적재(Loading)될 때 진행
- 적재는 실행 파일을 실행하기 위해 디스크에서 읽어 메모리의 특정 영역으로 이동 -> 적재 도구(loader)라는 전용 프로세스 실행
- 실행 파일이 적재되고 나면 적재 도구는 실행 파일이 동적 라이브러리에 의존하는지 알 수 있고, 필요하다면 동적 링커(dynamic linker)라는 별도의 프로세스가 실행되어 참조하는 동적 라이브러리 존재 여부, 위치, 심벌 메모리 위치 등을 확인해서 링크 과정을 마무리
- 이 과정에서 문제가 생기면 실행을 종료

- 적재 중 동적 링크를 사용하려면 실행 파일이 어떤 동적 라이브러리를 참조하는지 컴파일러에 명시적으로 알려줘야 함

- 또 다른 방식은 프로그램 실행 후 런타임에 코드가 직접 동적 링크를 실행
- 이는 실행 전까지 어떤 동적 라이브러리에 의존하는지 알 필요가 없어 좀 더 동적
- 리눅스의 `dlopen`, `dlsym`, `dlclose` 등의 함수로 런타임 동적 링크

- 동적 라이브러리는 분명 중복 문제의 좋은 해결법
- 파일 사이즈는 물론, 메모리 적재 중복도 해결해줌
- 또한 라이브러리가 수정되면 라이브러리만 컴파일하면 됨 -> 프로그램 업그레이드, 버그 수정 쉽게 해줌
- 또한 런타임에 링크되는 것을 이용해서 플러그인 아키텍처 구현 가능
- 여러 언어 혼합할 때도 활용 가능
- 파이썬에서 성능이 필요한 부분을 동적 라이브러리로 C/C++로 작성된 함수를 직접 호출

- 그렇다면 단점은?
- 동적이므로 정적 링크보다 약간 성능이 떨어짐
- 또한 동적 라이브러리 코드는 특정 메모리 주소와 독립적으로 동작하므로 위치 독립 코드(position-independent code)라고 불림
- 동적 라이브러리의 코드는 임의의 메모리 절대 주소로 참조할 수 없음 (메모리에 복사본을 유지하고 여러 프로세스가 공유하므로)
- 따라서 런타임에 성능 손실이 약간 있지만 이러한 점을 이용해서 얻을 수 있는 이점도 큼

- 반대로 장점이 단점이 될 수 있음
- 실행 파일만으로 실행이 불가능하고, 동적 라이브러리 종속성 문제가 발생함

- 모든 변수, 함수에는 메모리 주소가 존재
- 근데 컴파일할 때 어떻게 주소를 정할 수 있을까? 알 수 없음
- 따라서 컴파일 시점에는 0x00으로 지정하여 호출한다는 사실만 기록

![](files/Pasted%20image%2020260216200035.png)

- 이렇게 컴파일러가 떠넘긴 부분은 링커가 채워야 함
- call 명령을 찾아서 최종 실행 시점의 메모리 주소로 변경
- 링커를 위해 컴파일러는 메모리 주소를 확정할 수 없는 변수를 발견할 때마다 `.relo.text`에 해당 명령어를 저장하고, `.relo.data`에는 해당 명령어로 데이터를 저장
- `.relo.text`에 코드 영역의 시작 주소 기준 오프셋이 60바이트인 위치에서 foo 심벌을 발견했지만, 실행 시에 어떤 주소에서 실행해야 할지 알 수 없다. 링커가 수정해야 한다. 등의 메시지를 남김

![](files/Pasted%20image%2020260216200132.png)

- 심벌 해석 단계에서는 대상 파일에서 동일한 유형끼리 결합
- 이렇게 모두 결합되면 메모리 주소를 결정할 수 있음
- 링커는 각 대상 파일의 `.relo.text` 영역을 하나씩 읽어 수정해나감
- 이를 재배치라고 함

- 근데 실제 실행되는 주소는 런타임 시점에나 알 수 있지 않나? 매번 바뀌지 않나? 링커는 이걸 어떻게 처리하지?
- 가상 메모리 덕분에 가능


![](files/Pasted%20image%2020260216200443.png)

- 왜 코드 영역은 항상 `0x400000`에서 시작할까?
- 프로그램마다 자신이 모든 메모리를 독점하는 것처럼 착각하게 만든다~
- 링커는 명령어나 데이터가 실제로 물리 메모리 어디에 존재하는지 전혀 신경 쓰지 않는다

- 그렇다면 실제 데이터를 어떻게 물리 메모리에서 찾을 수 있을까?
- 가상 메모리 영역이 어디에 적재되는지 알 수 있다면 mapping이 생긴다
	- 정확히는 메모리 페이지 단위로

```
가상 메모리        물리 메모리
0x400000       0x80ef0000
```

- 이를 기록한 걸 페이지 테이블이라고 한다

![](files/Pasted%20image%2020260216200655.png)

- 모든 프로세스의 가상 메모리는 표준화되어 있고, 크기도 동일
- 프로세스마다 각 영역의 크기는 달라도 영역 배치 순서는 동일하다
- 실제 메모리의 크기는 가상 메모리 크기와 무관하고, 물리 메모리에는 힙 영역, 스택 영역 등 영역 구분도 존재하지 않음
- 프로세스는 자신만의 페이지 테이블을 지니고 있고, 같은 가상 메모리 주소라도 페이지 테이블에 따라서 서로 다른 물리 메모리 주소를 획득함

## 컴퓨터 과학에서 추상화가 중요한 이유

- CPU 하드웨어는 다 다르지만 명령어 집합(instruction set)이라는 개념으로 내부 구현 세부 사항을 보호
- 기계 명령어에 대한 추상화는 고급 프로그래밍 언어로 이어진다
- 입출력 장치는 파일로 추상화되어 있고
- 실행 중인 프로그램은 프로세스로 추상화된다
- 물리 메모리, 파일은 가상 메모리로 추상화된다
- mmap 등을 통해 가상 메모리를 사용하더라도 실제 메모리 읽고 쓰는 것처럼 쉽게 파일 조작할 수 있다
- 네트워크 프로그래밍은 소켓으로 추상화된다
- 프로세스, 실행 환경 등은 컨테이너로 추상화된다
- CPU, OS, 애플리케이션 등은 가상 머신으로 묶여 추상화된다
