# Ch2. 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다

> 다시 한 번 읽어보기. . .

## 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

### 모든 것은 CPU에서 시작된다

- CPU가 하는 일은 단순하다
  - 메모리에서 명령어를 가져온다 (fetch)
  - 명령어를 실행한다 (execute)
  - 위 과정을 반복

- PC 레지스터 (Program Counter)
  - CPU가 다음에 실행할 명령어의 메모리 주소를 저장
  - 기본적으로 1씩 자동 증가
  - 분기문(if, else, jump 등)을 만나면 해당 위치로 동적 변경

- 프로그램 시작 시 흐름
  - 소스 파일 -> 컴파일 -> 실행 파일 생성 -> 디스크에 저장
  - 프로그램 실행 시 실행 파일을 메모리에 적재 (loading)
  - main 함수에 해당하는 기계 명령어 주소를 PC 레지스터에 기록
  - CPU가 해당 주소부터 명령어 실행 시작

### CPU에서 운영체제까지

- 운영체제 (Operating System)
  - 실행 파일을 메모리에 적재하는 작업을 자동화 -> Loader
  - 여러 프로그램을 동시에 실행하는 것처럼 보이게 함 -> 멀티태스킹
  - 각 프로그램이 CPU와 메모리를 독점하는 것처럼 보이게 함 -> 가상 메모리

- 멀티태스킹의 원리
  - 프로그램 A 실행 -> A 중지 후 B 실행 -> B 중지 후 A 재개
  - 매우 빠른 속도로 전환하면 동시에 실행되는 것처럼 보임
  - 중지/재개를 위해 실행 상태 정보를 저장할 구조체 필요 -> 프로세스

### 프로세스 (Process)

- 프로세스란?
  - 실행 중인 프로그램의 상태를 저장하는 구조체
  - CPU가 어떤 명령어까지 실행했는지, 레지스터 값 등 상태 정보 포함
  - 이 정보로 프로그램을 일시 중지했다가 재개할 수 있음

- 프로세스 주소 공간
  - 코드 영역: 컴파일된 기계 명령어 저장
  - 데이터 영역: 전역 변수 저장
  - 힙 영역: malloc, new로 동적 할당된 메모리
  - 스택 영역: 함수 호출 시 지역 변수, 매개변수, 반환 주소 저장

- 다중 프로세스 프로그래밍의 단점
  - 프로세스 생성 시 오버헤드 발생
  - 프로세스마다 독립적인 주소 공간 -> 프로세스 간 통신이 복잡함

### 프로세스에서 스레드로

- 프로세스의 한계
  - 진입 함수가 main 하나뿐 -> 하나의 CPU에서만 실행 가능
  - 여러 CPU가 동일 프로세스의 명령어를 실행하려면?

- 스레드 (Thread)
  - PC 레지스터가 main이 아닌 다른 함수를 가리키게 하여 새로운 실행 흐름 생성
  - 하나의 프로세스 내에 여러 실행 흐름 존재 가능
  - 동일한 프로세스 주소 공간을 공유 -> 프로세스 간 통신 불필요

- 스레드의 특징
  - 프로세스보다 가볍고 생성 속도가 빠름
  - 스레드 간 변수 공유 가능
  - 다중 코어 CPU를 최대한 활용 가능 -> 동시성의 기초

---

## 2.2 스레드 간 공유되는 프로세스 리소스

### 다중 스레드와 메모리 구조

- 스택 프레임 (Stack Frame)
  - 함수 실행 시 필요한 정보 저장 (매개변수, 지역 변수, 반환 주소 등)
  - 함수 호출/반환 시 LIFO 방식으로 스택 프레임 증감

- 스레드별 스택 영역
  - 각 스레드는 독립적인 스택 영역을 가짐
  - 스레드가 많아지면 그만큼 메모리 공간 소모

### 스레드 공유 리소스 vs 전용 리소스

- 스레드 공유 리소스
  - 코드 영역: 모든 스레드가 공유, 읽기 전용이므로 스레드 안전 문제 없음
  - 데이터 영역: 전역 변수 저장, 모든 스레드 접근 가능
  - 힙 영역: 동적 할당 메모리, 포인터로 접근 가능하면 모든 스레드가 공유

- 스레드 전용 리소스
  - 스택 영역: 각 스레드 전용
  - 단, 다른 스레드의 스택 포인터를 알면 접근 가능 -> 버그 가능성

- 스레드 전용 저장소 (Thread Local Storage)
  - `__thread` 키워드로 선언된 변수
  - 모든 스레드에서 접근 가능하지만, 실제 인스턴스는 스레드마다 별도 존재
  - 한 스레드에서 값 변경해도 다른 스레드에 영향 없음

### 동적 링크 라이브러리와 파일

- 동적 링크 시 코드와 데이터는 스택과 힙 사이 여유 공간에 배치
- 모든 스레드가 공유 가능
- 프로그램이 연 파일 정보도 프로세스 주소 공간에 저장 -> 스레드 간 공유

---

## 2.3 스레드 풀 (Thread Pool)

### 요청 당 스레드 방식의 문제점

- 요청마다 스레드 생성 -> 처리 완료 후 종료
- 짧은 작업에는 부적합
  - 스레드 생성/종료 오버헤드
  - 스레드마다 스택 영역 필요 -> 메모리 소비
  - 스레드 전환 오버헤드

### 스레드 풀의 동작 방식

- 핵심: 스레드 재사용
  - 스레드 여러 개를 미리 생성
  - 작업이 생기면 대기 중인 스레드에게 할당
  - 스레드 생성/종료가 빈번하지 않아 메모리 안정적

- 작업 전달 방식 (생산자-소비자 패턴)
  - 작업 = 처리할 데이터 + 데이터 처리 함수
  - 생산자가 작업 대기열(큐)에 작업 추가
  - 스레드 풀의 스레드가 대기열에서 작업을 가져와 실행
  - 작업 대기열 접근 시 동기화/상호 배제 필요

### 스레드 풀의 적정 스레드 수

- CPU 집약적 작업
  - 외부 입출력 없이 연산만 수행
  - 스레드 수 ≈ CPU 코어 수

- I/O 집약적 작업
  - 입출력 대기 시간이 긴 작업
  - 성능 테스트로 적정 스레드 수 결정 필요

---

## 2.4 스레드 안전 (Thread Safety)

### 스레드 안전이란?

- 어떤 코드가 스레드 몇 개에서 호출되든, 어떤 순서로 호출되든 올바른 결과가 나오는 것
- 스레드 안전 코드 작성의 핵심: 전용 리소스와 공유 리소스 구분

### 스레드 전용 리소스

- 함수의 지역 변수
- 스레드의 스택 영역
- 스레드 전용 저장소 (`__thread`)

### 스레드 공유 리소스

- 힙 영역
- 데이터 영역 (전역 변수)
- 코드 영역 (읽기 전용이므로 안전)

### 스레드 안전 코드 작성법

- 무상태 함수
  - 지역 변수만 사용하는 함수 -> 스레드 안전

- 함수 매개변수
  - 값으로 전달 (call by value) -> 스레드 안전
  - 포인터로 전달 -> 포인터가 가리키는 대상에 따라 다름
    - 지역 변수 포인터 -> 안전
    - 전역 변수 포인터 -> 락 등으로 보호 필요

- 전역 변수 사용
  - 읽기 전용으로만 사용 -> 스레드 안전
  - 수정 필요 시 -> 스레드 전용 저장소로 선언하거나 동기화 필요

- 함수 반환값
  - 값 반환 -> 스레드 안전
  - 포인터 반환 (특히 static 변수 주소) -> 스레드 안전하지 않음

- 스레드 안전하지 않은 함수 호출
  - 호출 전후에 락으로 보호하면 호출하는 함수는 스레드 안전

### 스레드 안전 구현 정리

- 스레드 간 어떤 리소스를 공유하는지 파악
- 공유가 필요한 경우
  - 스레드 전용 저장소 활용
  - 읽기 전용으로 사용
  - 원자성 연산 사용
  - 동기화 시 상호 배제 (뮤텍스, 스핀락, 세마포어 등)

---

## 2.5 코루틴 (Coroutine)

### 커널 스레드 vs 코루틴

- 커널 스레드
  - 스레드 생성, 스케줄링, 종료를 운영체제가 관리
  - 개발자가 직접 제어 불가

- 코루틴
  - 운영체제에 의존하지 않고 사용자가 직접 구현하는 실행 흐름
  - 스레드보다 더 가벼움

### 일반 함수 vs 코루틴

- 일반 함수
  - return을 만나거나 코드 끝까지 실행되어야 반환
  - 반환 후 스택 영역에 정보 저장하지 않음
  - 다시 호출하면 처음부터 시작

- 코루틴
  - 일시 중지(yield)와 재개 기능 존재
  - 자신의 실행 상태를 저장 가능
  - 반환 후에도 다시 호출하면 마지막 중지 지점에서 이어서 실행

### 코루틴의 구현

- 일시 중지 시 저장해야 할 정보
  - CPU 레지스터 정보
  - 런타임 스택 프레임 정보
  - 함수 실행 상태 정보

- 스레드 vs 코루틴 상태 저장 위치
  - 스레드: 프로세스 주소 공간의 스택 영역
  - 코루틴: 힙 영역

- 코루틴의 장점
  - 메모리가 충분하면 코루틴 개수 제한 없음
  - 코루틴 간 전환이 가벼워 효율적

### 코루틴의 사용 목적

- 개발자가 동기 방식으로 비동기 프로그래밍을 가능하게 함
- 높은 동시성이 필요한 서버 환경에서 주로 활용
