# 3장 솔루션 아키텍처의 특성

- 비기능적 요구사항을 잘 충족해야 함

## 확장성과 탄력성

- 수평 확장(Scale out): 주로 서버에 해당
- 수직 확장(Scale up): 주로 DB에 해당
- 아키텍처 확장시
  - On Premise: 예측 쉽지 않음
  - Cloud: 예측이 더 쉽다
- 정적 컨텐츠 확장
  - CDN을 적용해서 엣지로케이션 영역에서 컨텐츠를 캐싱하자
- 서버플릿 탄력성
  - 확장시 세션 유지를 위해 NoSQL을 이용한 세션 유지
- DB 확장
  - 추가 읽기 복제본 생성, Redis를 활용한 캐시 등으로 DB 부하 줄이기
  - 용량이 꽉차면 샤드 분할해보자

## 고가용성과 복원력

- 다운타임 최소화 하는 것이 중요
  - 2개의 가용영역을 활용한다.
- 사용자의 개입 없는 복구가 가능해야 함

## 내결함성과 중복성

- 내결함성과 중복성, 비용은 비례함
- RTO(Recovery Time Object): 비즈니스가 허용 가능한 가동 중지 시간
- RPO(Recovery Point Object): 비즈니스가 허용 가능한 데이터 손실의 양
- 위 두가지를 챙기려면 비용이 증가함

| 재해 복구 계획 | 설명                                           | RTO/RPO  |
| -------------- | ---------------------------------------------- | -------- |
| 백업 및 복구   | 백업한 것 다시 처음부터 적용                   | 최대     |
| 파일럿 라이트  | 머신 이미지, 데이터 주기적 백업 후 장애시 적용 | 중       |
| 웜 스탠바이    | 주요 서버와 DB 동기화                          | 하       |
| 멀티 사이트    | 완전 복제                                      | 0에 수렴 |

## 확장성과 재사용성

- 느슨한 결합의 아키텍처
  - RESTful, 큐 기반 설계
- OOAD(객체지향 분석과 설계)로 API 프레임워크 작성 필요

## 사용성과 접근성

- 사용성: 사용자의 빠른 탐색의 논리 학습, 실수했을 때 빠른 회복
- 접근성: 다양한 네트워크/기기/언어
- 개선을 위해 A/B 테스트 활용 가능

## 이식성과 상호운용성

- JSON/XML과 같은 메시지 방식 통일
- 표준 형식/프로토콜 따르도록 설계

## 운영우수성과 유지 보수

- 로깅
- 모니터링
- 경고
- 자동화
- CI/CD
- 배포방식 설정

## 보안과 규정 준수

- 인증과 권한 - OAuth 2.0, OpenID
- 웹 보안 - XSS, SQL injection 공격, DDos, 방화벽 활용
- 네트워크 보안 - 침입 탐지시스템(IDS), 침입 방지시스템(IPS)
- 인프라보안
- 데이터 보안 - SSL/TLS

## 비용 최적화와 예산

- 빌드와 소스 비용 평가는 필수적임

# 4장 솔루션 아키텍처 설계 원칙

## 워크로드 확장

- 예측 확장
  - 워크로드의 기록데이터 기반으로 예측함
  - 예: AWS 대시보드에서 지난 CPU 기록을 기반으로 예측 CPU 데이터 제공
- 사후 대응 확장
  - 웹 계층 트래픽을 오프로드
    - 정적 컨텐츠 캐싱
  - 세션용 NoSQL 적용
  - 트랜잭션용 RDBMS 적용
  - 인메모리 캐싱

## 탄력적 아키텍처 적용

- 필요할 때마다 중복 아키텍처 구현
- RTO, RPO를 고려한 백업과 재해 복구 계획 짜기
- CDN, WAF를 통해 보안/트래픽 대응
- AutoScaling Group을 통해 서버 확장 대응

## 성능을 위한 설계

- 성능 높아짐 → 사용자 참여 증가 → ROI 증가
- 부하 테스트로 성능과 동시성 문제 둘다 테스트하기
  - 스토리지: 쓰기가 많은 경우 IOPS 높은 녀석으로
  - 인스턴스: 충분한 메모리와 CPU를 커버할 수 있는 녀석으로
- 캐싱 적용하기

## 교체 가능한 자원 활용

- 불변의 인프라
  - 애플리케이션 업그레이드 시 HW/SW 모두 교체
  - 무상태(stateless)로 항상 운영해야함
  - 보안과 소프트웨어 둘다 갖춰진 이미지를 사용해서 배포
- 카나리 배포, A/B 테스트도 좋은 방법

## 느슨한 결합

- Load Balancer || Queue 를 통한 느슨한 아키텍처
- SOA(서비스 지향 아키텍처)를 생각하자 → MSA가 좋은 예
  - SOAP, RESTful 두 프로토콜 방식 사용

<aside>
💡

항상 MSA가 옳은가? 모놀리식은?

</aside>

## 요구사항에 맞는 스토리지 활용

- 표 확인하기 - 154p
- 스토리지 옵션 정할 때 꼭 확인할 것: 데이터가 쓰이는 빈도
  - 핫데이터
  - 웜데이터
  - 콜드데이터

## 데이터 기반 설계

- 솔루션 설계는 데이터 영향을 받음
  - 서비스가 읽기 중심인지 쓰기 중심인지 알아야 함
- 모니터링 → 지표수집 & 시각화

## 아키텍처 제약사항 극복

- 고려할 것) 비용, 시간, 일정, 예산, 범위, 자원
- 최소실행 가능제품 (MVP, Minimum Viable Product)
  - MoSCoW: 요구사항의 우선순위를 정하는 방법
- 우선순위를 기반으로 요구사항을 충족하는 아키텍처를 짜야함

## 보안 강화

- 고려해야 할 보안 종류
  - 데이터센터의 물리적 보안
  - 네트워크 보안
  - IAM
  - 전송중 데이터 보안
  - 미사용 데이터 보안
  - 보안 모니터링
- 실 세계에서는 데이터의 보안 중요도와 암호화시 성능/대기시간 균형을 잘 맞춰야 함
- 현지 법률도 췍

## 자동화 적용

- 자동화 하면 시간도 절약되고 뿌듯하고 좋아요.
- 애플리케이션 테스트
  - 운영 테스트 자동화 (유닛, e2e, 인수 등등)
  - 카나리 배포, A/B테스트
- IT인프라: IaC
- 로깅/모니터링/경고
- 배포자동화: CI/CD
- 보안 자동화: 자동 IP 차단 등

# 5장 클라우드 마이그레이션과 하이브리드 클라우드의 아키텍처 설계

- 클라우드 마이그레이션하면 민첩성 증가, 개발 속도 증가

## 클라우드 네이티브 아키텍처의 장점

- 비용, 짧은 주기의 개발, 회복성/탄력성
- 특히 데이터 처리에 강점을 보임

## 퍼블릭 클라우드 설계

- 종류: AWS, 애저, GCP + 알리바바, 오라클, IBM 등

## 클라우드 마이그레이션 전략 수립

- 리프트 앤 시프트
  - 특징
    - 기존 애플리케이션 형태 그대로 클라우드로 이동
    - 마이그레이션 속도 빠름
    - 클라우드 활용도는 떨어짐
  - 종류
    - 리호스트
      - 가장 빠르고 예측 가능하고, 반복 가능함
      - 자원 절약 가능
      - 그대로 이사하는 형태
    - 리플랫폼
      - 애플리케이션 아키텍처를 변경하지 않고 플랫폼(OS)만 업데이트
      - 철저한 테스트 필요함
    - 재배치
      - 이미 애플리케이션이 컨테이너에 배포되어있는 경우 사용
      - 아주 간단함
- 클라우드 네이티브를 사용하도록 리팩토링
  - 방식
    - 리팩터
      - 마이그레이션 전 애플리케이션 재구성/재작성
      - 마이크로 서비스의 모듈식으로 변경. ROI를 잘 따져서 실행해야 함
    - 재구매
      - 클라우드 라이선스를 재구매하는 방식
- 기존 애플리케이션 폐기
  - 새롭게 교체하기

## 클라우드 전략 선택

- p181쪽 표 참고
- 단계적 마이그레이션 아주 중요 → 이후 최적화 하기

## 클라우드 마이그레이션 단계

- 클라우드 CoE(Center of Excellence) 설정하기
- 클라우드 마이그레이션 팩토리
  - 탐색 → 분석 → 계획 → 설계 → 마이그레이션 → 통합 → 검증 → 운영 → 최적화

### 탐색

- 포트폴리오 탐색 - 현재 마이그레이션과 관련된 모든 IT 자산
- 클라우드 마이그레이션 여부 확정
  - 애플리케이션 종속성 → 상용 솔루션 사용 가능
  - 마이그레이션 기간
  - 총 단계수 등등
- 정보 분석 필요함
  - 네트워크 데이터, 포트연결, 시스템, 프로세스 정보가 분석 대상
  - 지표로 뽑아내서 프로비저닝 정도에 따른 마이그레이션
- 이후 전략 / 우선순위 지정

### 마이그레이션 계획 수립

- 해야할 것
  - 전략 선택
  - 목표 정의
  - 적절한 자원 크기 결정
  - 우선순위 결정
  - 마이그레이션 패턴 식별
  - 팀 만들기
  - 도구 식별
- 애플리케이션 마이그레이션
  1. 현재 애플리케이션 수량화
  2. 현재 종속성 식별
  3. 우선순위 결정
  - 이후 마이그레이션 전/중/후 지표 수집하고, 테스트 계획 세워야 함(컷 오버 전략, 롤백 플랜)

### 애플리케이션 설계

- 알아야 하고 고려해야할 것
  - 사용자 계정
  - 네트워크 구성/연결
  - 보안, 거버넌스 (표준 정책)
  - 모니터링

### 마이그레이션 설계

- 전 - 계획 되돌아보기, 확인하기
- 중 - 클라우드와 네트워크 연결이 양호한지 확인

### 데이터 마이그레이션

- 방법
  - 양이 많지 않은 경우
    - 복제, 붙여넣기
    - 재구성 후 점진적 이동
  - 양이 많은 경우
    - 바로 클라우드 데이터 센터로 가져다 넣기
  - CDC(Change Data Capture)를 이용해 트래픽을 받으며 마이그레이션 하기

### 서버 마이그레이션

- 방법
  - OS 복제
  - 재해 복구 복제
  - VM 복제
  - 컨테이너화
  - 사용자 데이터 복사

### 통합/검증/전환

- 네트워크, 설정 자원, 종속성 연결, 단위테스트와 인수테스트, 트래픽 전환 (블루/그린 배포), 데이터는 CDC 이용

### 운영

- 데브옵스 접근방식 이용
  - 운영 - 개발 밀접하게

# 6장 솔루션 아키텍처 설계 패턴

## 멀티티어 아키텍처

- Presentation: 레이턴시 살피기
- Business
- Database: 보안 신경쓰기

## 멀티 테넌트 SaaS 기반 아키텍처 구축

- 예: 지라
- 테넌트별 데이터 격리 중요
  - DB수준 격리
  - 테이블 수준 격리
  - 행수준 격리

## 상태 저장과 상태 비저장 아키텍처 설계 구축

- 사용자 상태를 NoSQL에 저장해야 함. (MSA 정신)
  - DynamoDB, MongoDB
- 쿠키는 클라이언트에서 관리

## SOA 의 이해

- 결합 느슨하게
- 개발 오버헤드 증가 위험 있음 → 거버넌스 만들고 자동화로 해결
- SOAP와 RESTful 사용.

## 서버리스 아키텍처 구축

- 오토 스케일링 필요 없음
- 예: AWS Lambda, AWS DynamoDB 등
- YAML로 정의가능 (AWS CloudFormation)

## 마이크로 아키텍처 구축

- 경계 컨텍스트: 단일 비즈니스 도메인을 위해 함께 결합되는 단위
- 챙겨야 할 것
  - 별도 데이터 스토리지
  - 비상태 유지
  - 별도의 빌드 체계
  - 컨테이너 기반
  - 서버리스
  - 블루-그린 배포
  - 모니터링

## 큐기반 아키텍처

- 서비스간 큐 추가해서 느슨한 결합
- 큐체인 패턴: 여러단계를 큐를 이용해서 처리
- 작업 관찰자 패턴: 큐의 메시지 숫자에 따라서 오토스케일링 그룹을 만들 수 있음

## 이벤트 기반 아키텍처

- 일련의 이벤트 흐름을 큐를 이용해서 해결
- 게시자/구독자 모델 (예: 파일전송)
- 이벤트 스트림 모델 (예: 키네시스를 이용한 클릭 이벤트 스트림)

## 캐시 기반 아키텍처 구분

- 캐싱 종류
  - 클라이언트: HTTP 캐싱, 쿠키
  - DNS 캐싱
  - 웹 캐싱: 정적 컨텐츠
  - 애플리케이션 캐싱: 쿼리, 응답 캐싱
- 패턴
  - 3 티어 웹 아키텍처 캐시 배포 패턴
    - 사용자 세션: DynamoDB
    - DNS-IP: Route 53
    - 정적 컨텐츠 캐싱: CloudFront
  - 분산 패턴 이름 변경
    - CDN 즉시 업데이트 필요할 시에 사용
  - 캐시 프록시 패턴
    - 캐시 계층을 추가해서 동적/정적 컨텐츠 서빙
  - 프록시 재작성 패턴
    - 정적 웹사이트 컨텐츠의 액세스 대상을 변경하고 싶지만 기존 시스템은 변경하고 싶지 않을 때 사용
  - 앱 캐싱 패턴
    - 애플리케이션과 DB 사이에 캐싱레이어 존재
      - 지연 캐싱 (캐시 어사이드 패턴)
      - 라이트 스루
- Memcached / Redis

## 회로 차단기 패턴 (서킷 브레이커)

- 다운스트림 서비스가 운영이 안될 때 호출 자체를 하지 않음

## 격벽패턴 (Bulkhead)

- 종속성이 많은 하나의 서비스 내부를 분리해 일부 실패하더라도 운영이 계속 가능하도록 설계

## 유동 IP 패턴 생성

- 하드코딩된 IP 구성을 피함.
- 네트워크 인터페이스를 활용함

## 컨테이너로 애플리케이션 배포

- 컨테이너로의 이식성 향상 (예: 도커)
- ECS, EKS가 관리형 서비스

## 애플리케이션 아키텍처에서 데이터베이스 처리

- 수평확장 어려움
  - 일기 전용 복제본 사용하기
  - 샤딩하기
- 고가용성 데이터베이스 패턴
  - 예시
    - 가용영역 1: 마스터 DB 인스턴스, 읽기 전용 복제본
    - 가용영역 2: 스탠바이 DB 인스턴스, 읽기 전용 복제본
  - RPO/RTO에 맞추어 백업/보관 설정

## 안티 패턴

- 수동 시스템 확장
- 자동화가 되지 않은 경우 (모니터링, 알람)
- 고정 IP주소 사용
- 모놀리식 방식
- 한 종류의 DB만 사용
- 단일 DB 인스턴스를 사용
- 캐시없는 정적 컨텐츠 서빙하기
