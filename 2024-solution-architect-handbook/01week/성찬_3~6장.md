# 3장 솔루션 아키텍처의 특성
## 확장성과 탄력성
* 확장성
  * 시스템에서 증가하는 워크로드를 처리할 수 있는 기능을 제공하는 것
* 탄력성
  * 기능을 추가해 확장하는 것 뿐만 아니라 비용 절감을 위해 시스템 축소 가능한 것
* 확장 시 용량 딜레마
  * 확장 시 하드웨어가 준비되는 기간을 고려해서 확장성 고려가 되어야 한다.
* 3-tier 아키텍처의 확장
  * 구성 요소 
    * ELB, VM Server, DataBase, Object Storage, DNS, CDN, VPM
  * VM Server
    * Server metric based auto scaling
  * Static Contents
    * Content Serving
      * CDN edge location caching
    * Object Storage 사용으로 VM Server 의 기능과 분리시키는 것이 좋음
  * Server Fleet
    * Session Storage 를 분리해서 VM Server의 State를 없애자
  * Database
    * Write 노드와 Read Replica 설정
    * Cache 운영
    * 샤딩

## 고가용성과 복원력 (High Availability)
* 데이터 센터의 물리적 위치에서 워크로드를 계획한다.
  * Multi AZ
    * StandBy DB
      * Q) StandBy DB가 Master로 올라올 때 까지는 어쩔꺼임?
* 자가 복구 원칙 적용
  * ELB의 헬스체크

## 내결함성과 중복성
* 중단이 발생하더라도 시스템 성능을 손상시키지 않고 부하 용량을 처리하는 것
  * 완전한 내결함성 아키텍처는 중복성 증가로 인해 높은 비용을 수반한다.
  * 애플리케이션 중요도에 따라서 내결함성 비율을 설정하는 것이 좋다.

## 재해 복구와 비즈니스 연속성
* Recovery Time Objective
  * 중대한 영향 없이 비즈니스가 허용할 수 있는 가동 중지 시간
* Recovery Point Objective
  * 비즈니스가 허용할 수 있는 데이터 손실 양
* 비용이 막대하기 때문에 중요도에 따라서 잘 설정하자.
* 재해 복구 방법
  * 수동 복구
    * 다른 리전에 DB Snapshot 남기고 재해발생 시 수동으로 복원 시도
  * Pilot Lite
    * 머신 이미지 백업 및 동기화 재해 발생 시 수평적 확장 시도
  * Warm Standby
    * 서버와 DB를 모두 소규모 인스턴스로 유지, 재해 발생 시 수평적 확장 시도
  * Multi Site
    * 클론 아키텍처 떠놓기

## 확장성과 재사용성
* 모듈화를 잘해서 재사용하기 좋게 만들어라.

## 사용성과 접근성
* 사용성
  * 사용하기 쉬운것
* 접근성
  * 사용자의 환경과 관계없이 접근하기 좋은 것
    * 언어, 디바이스, 네트워크 상황
* A/B 테스트, 피드백 수집

## 이식성과 상호 운용성
* 상호 운용성
  * 표준을 통해 다른 애플리케이션과 함꼐 동작할 수 있는 것
* 시스템 이식성
  * 소프트웨어가 다양한 OS, 하드웨어에서 동작 가능해야 한다.

## 운영 우수성과 유지 보수
* 운영 우수성
  * 로깅, 모니터링
* 유지보수
  * CI/CD
  * 롤백전략, 블루그린배포
## 보안과 규정 준수
* 현지 법률 준수
* 인증 
  * 사내 인증
    * SAML, LDAP
  * 서비스 인증  
    * OAuth, OpenID
* 웹 보안
  * XSS, SQL Injection, DDoS, WAF
* 네트워크 보안
  * VPC 구성, IDS, IPS
* 인프라 보안
  * 물리적 액세스 차단
* 데이터 보안
  * SSL/TLS
  * 모든 계층에 모니터링 후 침임 시 알림을 보내는 DevSecOps 를 필수
  * PCI DSS, PII 준수

## 비용 최적화와 예산

# 4장 솔루션 아키텍처 설계 원칙
## 워크로드 확장
* 예측확장: 모니터링, AI
* 사후확장: 수동 교체

## 탄력적 아키텍처 구축
* 원하는 시간 내에 복구돼야 한다.
  * 복구 시간 정의
  * 중복 아키텍처 구성 요소 식별 및 구현
  * RTO, RPO 내 복구 계획 식별 및 구현
  * 변경 시기와 아키텍처 구성 요소 교체 시기 이해
* 모든 계층에 복구 가능한 아키텍처를 고려해야 한다.

## 성능을 위한 설계
아키텍처 설계의 모든 계층에 캐싱을 적용
Q. 성능만 보면 좋을 수 있다. 캐시 최신성을 고려 했을 때 정말 좋은 선택일까? 장애 요소가 될 수 있지 않을까?

## 교체 가능한 자원 사용
* stateless application
* IP, DNS 하드코딩 x
### 카나리 테스트
배포 중 블루,그린 배포 상태에서 일부 트래픽만 신규로 흘림
Q. 카나리 하고 있는 조직? 유저 식별 카나리 가능?

## 느슨한 결합
서버 간 직접 통신하지 말고 중간 홉을 하나 두어서 디커플링하자
홉: LB, Queue

## 요구 사항에 맞는 스토리지 사용

## 데이터 기반 설계

## 아키텍처 제약 사항 극복

## MVP 방식 채택
MoSCoW: Must Have, Should have, Could have, Won't have

## 보안 강화

## 자동화 적용

# 5장 클라우드 마이그레이션과 하이브리드 클라우드 아키텍처 설계
## 클라우드 네이티브 아키텍처의 장점
* 비용절감
* 빠른 실험
* 빠른 확장

## 퍼블릭 클라우드 선택

## 클라우드 마이그레이션 전략 수립
* 리프트 앤 시프트 마이그레이션
  * 가장 빠른 마이그레이션 모드
  * 리호스트 (?)
    * 예측 가능, 반복 가능, 경제적
    * 온프레미스가 그대로 클라우드로 전환
    * UseCase
      * 임시 개발, 테스트 환경
      * SAP, SharePoint 같은 패키지 소프트웨어 실행하는 경우
      * 애플리케이션 로드맵 없는 경우
  * 리플랫폼
    * OS, Server, DB 버전 수명이 다할 때 사용
  * 재배치
    * 온프레미스 데이터 센터에서 컨테이너 혹은 VMware로 마이그레이션
* 리팩터링
  * 직접 리소스 갈아서 리팩토링
* 재구매
  * 라이센스 재구매
* 유지나 폐기
  * 모든 구성요소를 클라우드로 변경할 필요는 없다.

## 클라우드 마이그레이션 단계
* 탐색: 클라우드 마이그레이션 포트폴리오와 온프레미스 워크로드 검색
* 분석: 탐색된 데이터와 워크로드 분석
* 계획: 클라우드로의 마이그레이션 계획과 마이그레이션 전략 정의
* 설계: 마이그레이션 전략에 따라 애플리케이션 설계
* 마이그레이션: 마이그레이션 전략 실행
* 통합: 종송석과 통합
* 검증: 마이그레이션 후 기능 검증
* 운영: 클라우드에서 운영할 계획
* 최적화: 클라우드에 대한 워크로드 최적화

### 워크로드 탐색
그냥 꼼꼼하게 일을 진행하라고 해

### 정보 분석
꼼꼼하게 일 진행해라 2

### 마이그레이션 계획 수립
이걸 왜 공부해야하지?

# 6장 솔루션 아키텍처 설계 패턴
## 멀티티어 아키텍처 구축
* 느슨하게 결합된 설계 원칙과 확장성 및 탄력성 속성 적용
* 프레젠테이션, 비즈니스, 데이터베이스, 서비스와 같은 계층을 나눠서 독립적으로 구현하고 확장
* 새로운 기술을 쉽게 도입하고 개발을 좀 더 효율적으로 수행

## 멀티테넌트 SaaS 기반 아키텍처 구축
* 고객 단위로 고유한 구성, ID, 데이터로 격리된 테넌트와 함께 앱과 데이터베이스를 공유한다.
* 고객은 코드 변경 없이 구성 변경을 통해 인터페이스를 사용자 정의할 수 있다.

## 상태 저장과 상태 비저장 아키텍처 설계 구축
* 상태 저장 애플리케이션은 수평 확장 어렵다. 수평 확장 하려면 세션 상태 공유 설계를 잘 해야한다.

## 서비스 지향 아키텍처의 이해
* 

## 서버리스 아키텍처 구축
* 람다 앞에 APIGateway 를 두자

## 마이크로서비스 아키텍처 구축
* 단일 비즈니스 도메인을 단위로 경계 컨텍스트를 구성해야 한다.
* 모범사례
  * 별도 데이터 스토리지 구축
  * 서버를 상태 비저장으로 유지
  * 별도 빌드 체계 구축
  * 컨테이너 배포
  * 서버리스 전환(?)
  * 블루그린 배포
  * 모니터링

## 큐 기반 아키텍처 구축
* 큐 체인 패턴
  * 시스템과 작업 사이에 큐를 이용해 느슨한 시스템 설계
* 작업 관찰자 패턴
  * 큐를 오토스케일링

## 이벤트 기반 아키텍처 구축
* Pub/Sub 모델
  * 이벤트 게시 시 구독자에게 알림
* 이벤트 스트림 모델
  * 생산자는 연속적인 이벤트 흐름을 보내고 소비자는 이벤트를 소비한다.

## 캐시 기반 아키텍처 구축
* 
